package saramakeycloak

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/Nerzal/gocloak.GoCloak -o ./go_cloak_mock_test.go

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_gocloak "github.com/Nerzal/gocloak"
	jwt "github.com/dgrijalva/jwt-go"
	"github.com/gojuno/minimock/v3"
)

// GoCloakMock implements gocloak.GoCloak
type GoCloakMock struct {
	t minimock.Tester

	funcCreateClient          func(accessToken string, realm string, clientID mm_gocloak.Client) (err error)
	inspectFuncCreateClient   func(accessToken string, realm string, clientID mm_gocloak.Client)
	afterCreateClientCounter  uint64
	beforeCreateClientCounter uint64
	CreateClientMock          mGoCloakMockCreateClient

	funcCreateClientScope          func(accessToken string, realm string, scope mm_gocloak.ClientScope) (err error)
	inspectFuncCreateClientScope   func(accessToken string, realm string, scope mm_gocloak.ClientScope)
	afterCreateClientScopeCounter  uint64
	beforeCreateClientScopeCounter uint64
	CreateClientScopeMock          mGoCloakMockCreateClientScope

	funcCreateComponent          func(accessToken string, realm string, component mm_gocloak.Component) (err error)
	inspectFuncCreateComponent   func(accessToken string, realm string, component mm_gocloak.Component)
	afterCreateComponentCounter  uint64
	beforeCreateComponentCounter uint64
	CreateComponentMock          mGoCloakMockCreateComponent

	funcCreateGroup          func(accessToken string, realm string, group mm_gocloak.Group) (err error)
	inspectFuncCreateGroup   func(accessToken string, realm string, group mm_gocloak.Group)
	afterCreateGroupCounter  uint64
	beforeCreateGroupCounter uint64
	CreateGroupMock          mGoCloakMockCreateGroup

	funcCreateRole          func(accessToken string, realm string, clientID string, role mm_gocloak.Role) (err error)
	inspectFuncCreateRole   func(accessToken string, realm string, clientID string, role mm_gocloak.Role)
	afterCreateRoleCounter  uint64
	beforeCreateRoleCounter uint64
	CreateRoleMock          mGoCloakMockCreateRole

	funcCreateUser          func(token string, realm string, user mm_gocloak.User) (sp1 *string, err error)
	inspectFuncCreateUser   func(token string, realm string, user mm_gocloak.User)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mGoCloakMockCreateUser

	funcDecodeAccessToken          func(accessToken string, realm string) (tp1 *jwt.Token, mp1 *jwt.MapClaims, err error)
	inspectFuncDecodeAccessToken   func(accessToken string, realm string)
	afterDecodeAccessTokenCounter  uint64
	beforeDecodeAccessTokenCounter uint64
	DecodeAccessTokenMock          mGoCloakMockDecodeAccessToken

	funcDecodeAccessTokenCustomClaims          func(accessToken string, realm string, claims jwt.Claims) (tp1 *jwt.Token, err error)
	inspectFuncDecodeAccessTokenCustomClaims   func(accessToken string, realm string, claims jwt.Claims)
	afterDecodeAccessTokenCustomClaimsCounter  uint64
	beforeDecodeAccessTokenCustomClaimsCounter uint64
	DecodeAccessTokenCustomClaimsMock          mGoCloakMockDecodeAccessTokenCustomClaims

	funcDeleteClient          func(accessToken string, realm string, clientID string) (err error)
	inspectFuncDeleteClient   func(accessToken string, realm string, clientID string)
	afterDeleteClientCounter  uint64
	beforeDeleteClientCounter uint64
	DeleteClientMock          mGoCloakMockDeleteClient

	funcDeleteClientScope          func(accessToken string, realm string, scopeID string) (err error)
	inspectFuncDeleteClientScope   func(accessToken string, realm string, scopeID string)
	afterDeleteClientScopeCounter  uint64
	beforeDeleteClientScopeCounter uint64
	DeleteClientScopeMock          mGoCloakMockDeleteClientScope

	funcDeleteComponent          func(accessToken string, realm string, componentID string) (err error)
	inspectFuncDeleteComponent   func(accessToken string, realm string, componentID string)
	afterDeleteComponentCounter  uint64
	beforeDeleteComponentCounter uint64
	DeleteComponentMock          mGoCloakMockDeleteComponent

	funcDeleteGroup          func(accessToken string, realm string, groupID string) (err error)
	inspectFuncDeleteGroup   func(accessToken string, realm string, groupID string)
	afterDeleteGroupCounter  uint64
	beforeDeleteGroupCounter uint64
	DeleteGroupMock          mGoCloakMockDeleteGroup

	funcDeleteRole          func(accessToken string, realm string, clientID string, roleName string) (err error)
	inspectFuncDeleteRole   func(accessToken string, realm string, clientID string, roleName string)
	afterDeleteRoleCounter  uint64
	beforeDeleteRoleCounter uint64
	DeleteRoleMock          mGoCloakMockDeleteRole

	funcDeleteUser          func(accessToken string, realm string, userID string) (err error)
	inspectFuncDeleteUser   func(accessToken string, realm string, userID string)
	afterDeleteUserCounter  uint64
	beforeDeleteUserCounter uint64
	DeleteUserMock          mGoCloakMockDeleteUser

	funcGetCerts          func(realm string) (cp1 *mm_gocloak.CertResponse, err error)
	inspectFuncGetCerts   func(realm string)
	afterGetCertsCounter  uint64
	beforeGetCertsCounter uint64
	GetCertsMock          mGoCloakMockGetCerts

	funcGetClients          func(accessToken string, realm string) (cap1 *[]mm_gocloak.Client, err error)
	inspectFuncGetClients   func(accessToken string, realm string)
	afterGetClientsCounter  uint64
	beforeGetClientsCounter uint64
	GetClientsMock          mGoCloakMockGetClients

	funcGetComponents          func(accessToken string, realm string) (cap1 *[]mm_gocloak.Component, err error)
	inspectFuncGetComponents   func(accessToken string, realm string)
	afterGetComponentsCounter  uint64
	beforeGetComponentsCounter uint64
	GetComponentsMock          mGoCloakMockGetComponents

	funcGetGroup          func(accessToken string, realm string, groupID string) (gp1 *mm_gocloak.Group, err error)
	inspectFuncGetGroup   func(accessToken string, realm string, groupID string)
	afterGetGroupCounter  uint64
	beforeGetGroupCounter uint64
	GetGroupMock          mGoCloakMockGetGroup

	funcGetGroups          func(accessToken string, realm string) (gap1 *[]mm_gocloak.Group, err error)
	inspectFuncGetGroups   func(accessToken string, realm string)
	afterGetGroupsCounter  uint64
	beforeGetGroupsCounter uint64
	GetGroupsMock          mGoCloakMockGetGroups

	funcGetIssuer          func(realm string) (ip1 *mm_gocloak.IssuerResponse, err error)
	inspectFuncGetIssuer   func(realm string)
	afterGetIssuerCounter  uint64
	beforeGetIssuerCounter uint64
	GetIssuerMock          mGoCloakMockGetIssuer

	funcGetKeyStoreConfig          func(accessToken string, realm string) (kp1 *mm_gocloak.KeyStoreConfig, err error)
	inspectFuncGetKeyStoreConfig   func(accessToken string, realm string)
	afterGetKeyStoreConfigCounter  uint64
	beforeGetKeyStoreConfigCounter uint64
	GetKeyStoreConfigMock          mGoCloakMockGetKeyStoreConfig

	funcGetRealmRolesByGroupID          func(accessToken string, realm string, groupID string) (rap1 *[]mm_gocloak.Role, err error)
	inspectFuncGetRealmRolesByGroupID   func(accessToken string, realm string, groupID string)
	afterGetRealmRolesByGroupIDCounter  uint64
	beforeGetRealmRolesByGroupIDCounter uint64
	GetRealmRolesByGroupIDMock          mGoCloakMockGetRealmRolesByGroupID

	funcGetRealmRolesByUserID          func(accessToken string, realm string, userID string) (rap1 *[]mm_gocloak.Role, err error)
	inspectFuncGetRealmRolesByUserID   func(accessToken string, realm string, userID string)
	afterGetRealmRolesByUserIDCounter  uint64
	beforeGetRealmRolesByUserIDCounter uint64
	GetRealmRolesByUserIDMock          mGoCloakMockGetRealmRolesByUserID

	funcGetRoleMappingByGroupID          func(accessToken string, realm string, groupID string) (rap1 *[]mm_gocloak.RoleMapping, err error)
	inspectFuncGetRoleMappingByGroupID   func(accessToken string, realm string, groupID string)
	afterGetRoleMappingByGroupIDCounter  uint64
	beforeGetRoleMappingByGroupIDCounter uint64
	GetRoleMappingByGroupIDMock          mGoCloakMockGetRoleMappingByGroupID

	funcGetRoleMappingByUserID          func(accessToken string, realm string, userID string) (rap1 *[]mm_gocloak.RoleMapping, err error)
	inspectFuncGetRoleMappingByUserID   func(accessToken string, realm string, userID string)
	afterGetRoleMappingByUserIDCounter  uint64
	beforeGetRoleMappingByUserIDCounter uint64
	GetRoleMappingByUserIDMock          mGoCloakMockGetRoleMappingByUserID

	funcGetRoles          func(accessToken string, realm string) (rap1 *[]mm_gocloak.Role, err error)
	inspectFuncGetRoles   func(accessToken string, realm string)
	afterGetRolesCounter  uint64
	beforeGetRolesCounter uint64
	GetRolesMock          mGoCloakMockGetRoles

	funcGetRolesByClientID          func(accessToken string, realm string, clientID string) (rap1 *[]mm_gocloak.Role, err error)
	inspectFuncGetRolesByClientID   func(accessToken string, realm string, clientID string)
	afterGetRolesByClientIDCounter  uint64
	beforeGetRolesByClientIDCounter uint64
	GetRolesByClientIDMock          mGoCloakMockGetRolesByClientID

	funcGetUserByID          func(accessToken string, realm string, userID string) (up1 *mm_gocloak.User, err error)
	inspectFuncGetUserByID   func(accessToken string, realm string, userID string)
	afterGetUserByIDCounter  uint64
	beforeGetUserByIDCounter uint64
	GetUserByIDMock          mGoCloakMockGetUserByID

	funcGetUserCount          func(accessToken string, realm string) (i1 int, err error)
	inspectFuncGetUserCount   func(accessToken string, realm string)
	afterGetUserCountCounter  uint64
	beforeGetUserCountCounter uint64
	GetUserCountMock          mGoCloakMockGetUserCount

	funcGetUserGroups          func(accessToken string, realm string, userID string) (uap1 *[]mm_gocloak.UserGroup, err error)
	inspectFuncGetUserGroups   func(accessToken string, realm string, userID string)
	afterGetUserGroupsCounter  uint64
	beforeGetUserGroupsCounter uint64
	GetUserGroupsMock          mGoCloakMockGetUserGroups

	funcGetUsers          func(accessToken string, realm string) (uap1 *[]mm_gocloak.User, err error)
	inspectFuncGetUsers   func(accessToken string, realm string)
	afterGetUsersCounter  uint64
	beforeGetUsersCounter uint64
	GetUsersMock          mGoCloakMockGetUsers

	funcGetUsersByRoleName          func(token string, realm string, roleName string) (uap1 *[]mm_gocloak.User, err error)
	inspectFuncGetUsersByRoleName   func(token string, realm string, roleName string)
	afterGetUsersByRoleNameCounter  uint64
	beforeGetUsersByRoleNameCounter uint64
	GetUsersByRoleNameMock          mGoCloakMockGetUsersByRoleName

	funcLogin          func(clientID string, clientSecret string, realm string, username string, password string) (jp1 *mm_gocloak.JWT, err error)
	inspectFuncLogin   func(clientID string, clientSecret string, realm string, username string, password string)
	afterLoginCounter  uint64
	beforeLoginCounter uint64
	LoginMock          mGoCloakMockLogin

	funcLoginAdmin          func(username string, password string, realm string) (jp1 *mm_gocloak.JWT, err error)
	inspectFuncLoginAdmin   func(username string, password string, realm string)
	afterLoginAdminCounter  uint64
	beforeLoginAdminCounter uint64
	LoginAdminMock          mGoCloakMockLoginAdmin

	funcLoginClient          func(clientID string, clientSecret string, realm string) (jp1 *mm_gocloak.JWT, err error)
	inspectFuncLoginClient   func(clientID string, clientSecret string, realm string)
	afterLoginClientCounter  uint64
	beforeLoginClientCounter uint64
	LoginClientMock          mGoCloakMockLoginClient

	funcRefreshToken          func(refreshToken string, clientID string, clientSecret string, realm string) (jp1 *mm_gocloak.JWT, err error)
	inspectFuncRefreshToken   func(refreshToken string, clientID string, clientSecret string, realm string)
	afterRefreshTokenCounter  uint64
	beforeRefreshTokenCounter uint64
	RefreshTokenMock          mGoCloakMockRefreshToken

	funcRequestPermission          func(clientID string, clientSecret string, realm string, username string, password string, permission string) (jp1 *mm_gocloak.JWT, err error)
	inspectFuncRequestPermission   func(clientID string, clientSecret string, realm string, username string, password string, permission string)
	afterRequestPermissionCounter  uint64
	beforeRequestPermissionCounter uint64
	RequestPermissionMock          mGoCloakMockRequestPermission

	funcRetrospectToken          func(accessToken string, clientID string, clientSecret string, realm string) (rp1 *mm_gocloak.RetrospecTokenResult, err error)
	inspectFuncRetrospectToken   func(accessToken string, clientID string, clientSecret string, realm string)
	afterRetrospectTokenCounter  uint64
	beforeRetrospectTokenCounter uint64
	RetrospectTokenMock          mGoCloakMockRetrospectToken

	funcSetPassword          func(token string, userID string, realm string, password string, temporary bool) (err error)
	inspectFuncSetPassword   func(token string, userID string, realm string, password string, temporary bool)
	afterSetPasswordCounter  uint64
	beforeSetPasswordCounter uint64
	SetPasswordMock          mGoCloakMockSetPassword

	funcUpdateClient          func(accessToken string, realm string, clientID mm_gocloak.Client) (err error)
	inspectFuncUpdateClient   func(accessToken string, realm string, clientID mm_gocloak.Client)
	afterUpdateClientCounter  uint64
	beforeUpdateClientCounter uint64
	UpdateClientMock          mGoCloakMockUpdateClient

	funcUpdateClientScope          func(accessToken string, realm string, scope mm_gocloak.ClientScope) (err error)
	inspectFuncUpdateClientScope   func(accessToken string, realm string, scope mm_gocloak.ClientScope)
	afterUpdateClientScopeCounter  uint64
	beforeUpdateClientScopeCounter uint64
	UpdateClientScopeMock          mGoCloakMockUpdateClientScope

	funcUpdateGroup          func(accessToken string, realm string, group mm_gocloak.Group) (err error)
	inspectFuncUpdateGroup   func(accessToken string, realm string, group mm_gocloak.Group)
	afterUpdateGroupCounter  uint64
	beforeUpdateGroupCounter uint64
	UpdateGroupMock          mGoCloakMockUpdateGroup

	funcUpdateRole          func(accessToken string, realm string, clientID string, role mm_gocloak.Role) (err error)
	inspectFuncUpdateRole   func(accessToken string, realm string, clientID string, role mm_gocloak.Role)
	afterUpdateRoleCounter  uint64
	beforeUpdateRoleCounter uint64
	UpdateRoleMock          mGoCloakMockUpdateRole

	funcUpdateUser          func(accessToken string, realm string, user mm_gocloak.User) (err error)
	inspectFuncUpdateUser   func(accessToken string, realm string, user mm_gocloak.User)
	afterUpdateUserCounter  uint64
	beforeUpdateUserCounter uint64
	UpdateUserMock          mGoCloakMockUpdateUser

	funcUserAttributeContains          func(attributes map[string][]string, attribute string, value string) (b1 bool)
	inspectFuncUserAttributeContains   func(attributes map[string][]string, attribute string, value string)
	afterUserAttributeContainsCounter  uint64
	beforeUserAttributeContainsCounter uint64
	UserAttributeContainsMock          mGoCloakMockUserAttributeContains
}

// NewGoCloakMock returns a mock for gocloak.GoCloak
func NewGoCloakMock(t minimock.Tester) *GoCloakMock {
	m := &GoCloakMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateClientMock = mGoCloakMockCreateClient{mock: m}
	m.CreateClientMock.callArgs = []*GoCloakMockCreateClientParams{}

	m.CreateClientScopeMock = mGoCloakMockCreateClientScope{mock: m}
	m.CreateClientScopeMock.callArgs = []*GoCloakMockCreateClientScopeParams{}

	m.CreateComponentMock = mGoCloakMockCreateComponent{mock: m}
	m.CreateComponentMock.callArgs = []*GoCloakMockCreateComponentParams{}

	m.CreateGroupMock = mGoCloakMockCreateGroup{mock: m}
	m.CreateGroupMock.callArgs = []*GoCloakMockCreateGroupParams{}

	m.CreateRoleMock = mGoCloakMockCreateRole{mock: m}
	m.CreateRoleMock.callArgs = []*GoCloakMockCreateRoleParams{}

	m.CreateUserMock = mGoCloakMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*GoCloakMockCreateUserParams{}

	m.DecodeAccessTokenMock = mGoCloakMockDecodeAccessToken{mock: m}
	m.DecodeAccessTokenMock.callArgs = []*GoCloakMockDecodeAccessTokenParams{}

	m.DecodeAccessTokenCustomClaimsMock = mGoCloakMockDecodeAccessTokenCustomClaims{mock: m}
	m.DecodeAccessTokenCustomClaimsMock.callArgs = []*GoCloakMockDecodeAccessTokenCustomClaimsParams{}

	m.DeleteClientMock = mGoCloakMockDeleteClient{mock: m}
	m.DeleteClientMock.callArgs = []*GoCloakMockDeleteClientParams{}

	m.DeleteClientScopeMock = mGoCloakMockDeleteClientScope{mock: m}
	m.DeleteClientScopeMock.callArgs = []*GoCloakMockDeleteClientScopeParams{}

	m.DeleteComponentMock = mGoCloakMockDeleteComponent{mock: m}
	m.DeleteComponentMock.callArgs = []*GoCloakMockDeleteComponentParams{}

	m.DeleteGroupMock = mGoCloakMockDeleteGroup{mock: m}
	m.DeleteGroupMock.callArgs = []*GoCloakMockDeleteGroupParams{}

	m.DeleteRoleMock = mGoCloakMockDeleteRole{mock: m}
	m.DeleteRoleMock.callArgs = []*GoCloakMockDeleteRoleParams{}

	m.DeleteUserMock = mGoCloakMockDeleteUser{mock: m}
	m.DeleteUserMock.callArgs = []*GoCloakMockDeleteUserParams{}

	m.GetCertsMock = mGoCloakMockGetCerts{mock: m}
	m.GetCertsMock.callArgs = []*GoCloakMockGetCertsParams{}

	m.GetClientsMock = mGoCloakMockGetClients{mock: m}
	m.GetClientsMock.callArgs = []*GoCloakMockGetClientsParams{}

	m.GetComponentsMock = mGoCloakMockGetComponents{mock: m}
	m.GetComponentsMock.callArgs = []*GoCloakMockGetComponentsParams{}

	m.GetGroupMock = mGoCloakMockGetGroup{mock: m}
	m.GetGroupMock.callArgs = []*GoCloakMockGetGroupParams{}

	m.GetGroupsMock = mGoCloakMockGetGroups{mock: m}
	m.GetGroupsMock.callArgs = []*GoCloakMockGetGroupsParams{}

	m.GetIssuerMock = mGoCloakMockGetIssuer{mock: m}
	m.GetIssuerMock.callArgs = []*GoCloakMockGetIssuerParams{}

	m.GetKeyStoreConfigMock = mGoCloakMockGetKeyStoreConfig{mock: m}
	m.GetKeyStoreConfigMock.callArgs = []*GoCloakMockGetKeyStoreConfigParams{}

	m.GetRealmRolesByGroupIDMock = mGoCloakMockGetRealmRolesByGroupID{mock: m}
	m.GetRealmRolesByGroupIDMock.callArgs = []*GoCloakMockGetRealmRolesByGroupIDParams{}

	m.GetRealmRolesByUserIDMock = mGoCloakMockGetRealmRolesByUserID{mock: m}
	m.GetRealmRolesByUserIDMock.callArgs = []*GoCloakMockGetRealmRolesByUserIDParams{}

	m.GetRoleMappingByGroupIDMock = mGoCloakMockGetRoleMappingByGroupID{mock: m}
	m.GetRoleMappingByGroupIDMock.callArgs = []*GoCloakMockGetRoleMappingByGroupIDParams{}

	m.GetRoleMappingByUserIDMock = mGoCloakMockGetRoleMappingByUserID{mock: m}
	m.GetRoleMappingByUserIDMock.callArgs = []*GoCloakMockGetRoleMappingByUserIDParams{}

	m.GetRolesMock = mGoCloakMockGetRoles{mock: m}
	m.GetRolesMock.callArgs = []*GoCloakMockGetRolesParams{}

	m.GetRolesByClientIDMock = mGoCloakMockGetRolesByClientID{mock: m}
	m.GetRolesByClientIDMock.callArgs = []*GoCloakMockGetRolesByClientIDParams{}

	m.GetUserByIDMock = mGoCloakMockGetUserByID{mock: m}
	m.GetUserByIDMock.callArgs = []*GoCloakMockGetUserByIDParams{}

	m.GetUserCountMock = mGoCloakMockGetUserCount{mock: m}
	m.GetUserCountMock.callArgs = []*GoCloakMockGetUserCountParams{}

	m.GetUserGroupsMock = mGoCloakMockGetUserGroups{mock: m}
	m.GetUserGroupsMock.callArgs = []*GoCloakMockGetUserGroupsParams{}

	m.GetUsersMock = mGoCloakMockGetUsers{mock: m}
	m.GetUsersMock.callArgs = []*GoCloakMockGetUsersParams{}

	m.GetUsersByRoleNameMock = mGoCloakMockGetUsersByRoleName{mock: m}
	m.GetUsersByRoleNameMock.callArgs = []*GoCloakMockGetUsersByRoleNameParams{}

	m.LoginMock = mGoCloakMockLogin{mock: m}
	m.LoginMock.callArgs = []*GoCloakMockLoginParams{}

	m.LoginAdminMock = mGoCloakMockLoginAdmin{mock: m}
	m.LoginAdminMock.callArgs = []*GoCloakMockLoginAdminParams{}

	m.LoginClientMock = mGoCloakMockLoginClient{mock: m}
	m.LoginClientMock.callArgs = []*GoCloakMockLoginClientParams{}

	m.RefreshTokenMock = mGoCloakMockRefreshToken{mock: m}
	m.RefreshTokenMock.callArgs = []*GoCloakMockRefreshTokenParams{}

	m.RequestPermissionMock = mGoCloakMockRequestPermission{mock: m}
	m.RequestPermissionMock.callArgs = []*GoCloakMockRequestPermissionParams{}

	m.RetrospectTokenMock = mGoCloakMockRetrospectToken{mock: m}
	m.RetrospectTokenMock.callArgs = []*GoCloakMockRetrospectTokenParams{}

	m.SetPasswordMock = mGoCloakMockSetPassword{mock: m}
	m.SetPasswordMock.callArgs = []*GoCloakMockSetPasswordParams{}

	m.UpdateClientMock = mGoCloakMockUpdateClient{mock: m}
	m.UpdateClientMock.callArgs = []*GoCloakMockUpdateClientParams{}

	m.UpdateClientScopeMock = mGoCloakMockUpdateClientScope{mock: m}
	m.UpdateClientScopeMock.callArgs = []*GoCloakMockUpdateClientScopeParams{}

	m.UpdateGroupMock = mGoCloakMockUpdateGroup{mock: m}
	m.UpdateGroupMock.callArgs = []*GoCloakMockUpdateGroupParams{}

	m.UpdateRoleMock = mGoCloakMockUpdateRole{mock: m}
	m.UpdateRoleMock.callArgs = []*GoCloakMockUpdateRoleParams{}

	m.UpdateUserMock = mGoCloakMockUpdateUser{mock: m}
	m.UpdateUserMock.callArgs = []*GoCloakMockUpdateUserParams{}

	m.UserAttributeContainsMock = mGoCloakMockUserAttributeContains{mock: m}
	m.UserAttributeContainsMock.callArgs = []*GoCloakMockUserAttributeContainsParams{}

	return m
}

type mGoCloakMockCreateClient struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockCreateClientExpectation
	expectations       []*GoCloakMockCreateClientExpectation

	callArgs []*GoCloakMockCreateClientParams
	mutex    sync.RWMutex
}

// GoCloakMockCreateClientExpectation specifies expectation struct of the GoCloak.CreateClient
type GoCloakMockCreateClientExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockCreateClientParams
	results *GoCloakMockCreateClientResults
	Counter uint64
}

// GoCloakMockCreateClientParams contains parameters of the GoCloak.CreateClient
type GoCloakMockCreateClientParams struct {
	accessToken string
	realm       string
	clientID    mm_gocloak.Client
}

// GoCloakMockCreateClientResults contains results of the GoCloak.CreateClient
type GoCloakMockCreateClientResults struct {
	err error
}

// Expect sets up expected params for GoCloak.CreateClient
func (mmCreateClient *mGoCloakMockCreateClient) Expect(accessToken string, realm string, clientID mm_gocloak.Client) *mGoCloakMockCreateClient {
	if mmCreateClient.mock.funcCreateClient != nil {
		mmCreateClient.mock.t.Fatalf("GoCloakMock.CreateClient mock is already set by Set")
	}

	if mmCreateClient.defaultExpectation == nil {
		mmCreateClient.defaultExpectation = &GoCloakMockCreateClientExpectation{}
	}

	mmCreateClient.defaultExpectation.params = &GoCloakMockCreateClientParams{accessToken, realm, clientID}
	for _, e := range mmCreateClient.expectations {
		if minimock.Equal(e.params, mmCreateClient.defaultExpectation.params) {
			mmCreateClient.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateClient.defaultExpectation.params)
		}
	}

	return mmCreateClient
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.CreateClient
func (mmCreateClient *mGoCloakMockCreateClient) Inspect(f func(accessToken string, realm string, clientID mm_gocloak.Client)) *mGoCloakMockCreateClient {
	if mmCreateClient.mock.inspectFuncCreateClient != nil {
		mmCreateClient.mock.t.Fatalf("Inspect function is already set for GoCloakMock.CreateClient")
	}

	mmCreateClient.mock.inspectFuncCreateClient = f

	return mmCreateClient
}

// Return sets up results that will be returned by GoCloak.CreateClient
func (mmCreateClient *mGoCloakMockCreateClient) Return(err error) *GoCloakMock {
	if mmCreateClient.mock.funcCreateClient != nil {
		mmCreateClient.mock.t.Fatalf("GoCloakMock.CreateClient mock is already set by Set")
	}

	if mmCreateClient.defaultExpectation == nil {
		mmCreateClient.defaultExpectation = &GoCloakMockCreateClientExpectation{mock: mmCreateClient.mock}
	}
	mmCreateClient.defaultExpectation.results = &GoCloakMockCreateClientResults{err}
	return mmCreateClient.mock
}

//Set uses given function f to mock the GoCloak.CreateClient method
func (mmCreateClient *mGoCloakMockCreateClient) Set(f func(accessToken string, realm string, clientID mm_gocloak.Client) (err error)) *GoCloakMock {
	if mmCreateClient.defaultExpectation != nil {
		mmCreateClient.mock.t.Fatalf("Default expectation is already set for the GoCloak.CreateClient method")
	}

	if len(mmCreateClient.expectations) > 0 {
		mmCreateClient.mock.t.Fatalf("Some expectations are already set for the GoCloak.CreateClient method")
	}

	mmCreateClient.mock.funcCreateClient = f
	return mmCreateClient.mock
}

// When sets expectation for the GoCloak.CreateClient which will trigger the result defined by the following
// Then helper
func (mmCreateClient *mGoCloakMockCreateClient) When(accessToken string, realm string, clientID mm_gocloak.Client) *GoCloakMockCreateClientExpectation {
	if mmCreateClient.mock.funcCreateClient != nil {
		mmCreateClient.mock.t.Fatalf("GoCloakMock.CreateClient mock is already set by Set")
	}

	expectation := &GoCloakMockCreateClientExpectation{
		mock:   mmCreateClient.mock,
		params: &GoCloakMockCreateClientParams{accessToken, realm, clientID},
	}
	mmCreateClient.expectations = append(mmCreateClient.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.CreateClient return parameters for the expectation previously defined by the When method
func (e *GoCloakMockCreateClientExpectation) Then(err error) *GoCloakMock {
	e.results = &GoCloakMockCreateClientResults{err}
	return e.mock
}

// CreateClient implements gocloak.GoCloak
func (mmCreateClient *GoCloakMock) CreateClient(accessToken string, realm string, clientID mm_gocloak.Client) (err error) {
	mm_atomic.AddUint64(&mmCreateClient.beforeCreateClientCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateClient.afterCreateClientCounter, 1)

	if mmCreateClient.inspectFuncCreateClient != nil {
		mmCreateClient.inspectFuncCreateClient(accessToken, realm, clientID)
	}

	mm_params := &GoCloakMockCreateClientParams{accessToken, realm, clientID}

	// Record call args
	mmCreateClient.CreateClientMock.mutex.Lock()
	mmCreateClient.CreateClientMock.callArgs = append(mmCreateClient.CreateClientMock.callArgs, mm_params)
	mmCreateClient.CreateClientMock.mutex.Unlock()

	for _, e := range mmCreateClient.CreateClientMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateClient.CreateClientMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateClient.CreateClientMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateClient.CreateClientMock.defaultExpectation.params
		mm_got := GoCloakMockCreateClientParams{accessToken, realm, clientID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateClient.t.Errorf("GoCloakMock.CreateClient got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateClient.CreateClientMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateClient.t.Fatal("No results are set for the GoCloakMock.CreateClient")
		}
		return (*mm_results).err
	}
	if mmCreateClient.funcCreateClient != nil {
		return mmCreateClient.funcCreateClient(accessToken, realm, clientID)
	}
	mmCreateClient.t.Fatalf("Unexpected call to GoCloakMock.CreateClient. %v %v %v", accessToken, realm, clientID)
	return
}

// CreateClientAfterCounter returns a count of finished GoCloakMock.CreateClient invocations
func (mmCreateClient *GoCloakMock) CreateClientAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateClient.afterCreateClientCounter)
}

// CreateClientBeforeCounter returns a count of GoCloakMock.CreateClient invocations
func (mmCreateClient *GoCloakMock) CreateClientBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateClient.beforeCreateClientCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.CreateClient.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateClient *mGoCloakMockCreateClient) Calls() []*GoCloakMockCreateClientParams {
	mmCreateClient.mutex.RLock()

	argCopy := make([]*GoCloakMockCreateClientParams, len(mmCreateClient.callArgs))
	copy(argCopy, mmCreateClient.callArgs)

	mmCreateClient.mutex.RUnlock()

	return argCopy
}

// MinimockCreateClientDone returns true if the count of the CreateClient invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockCreateClientDone() bool {
	for _, e := range m.CreateClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateClientMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateClientCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateClient != nil && mm_atomic.LoadUint64(&m.afterCreateClientCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateClientInspect logs each unmet expectation
func (m *GoCloakMock) MinimockCreateClientInspect() {
	for _, e := range m.CreateClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.CreateClient with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateClientMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateClientCounter) < 1 {
		if m.CreateClientMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.CreateClient")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.CreateClient with params: %#v", *m.CreateClientMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateClient != nil && mm_atomic.LoadUint64(&m.afterCreateClientCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.CreateClient")
	}
}

type mGoCloakMockCreateClientScope struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockCreateClientScopeExpectation
	expectations       []*GoCloakMockCreateClientScopeExpectation

	callArgs []*GoCloakMockCreateClientScopeParams
	mutex    sync.RWMutex
}

// GoCloakMockCreateClientScopeExpectation specifies expectation struct of the GoCloak.CreateClientScope
type GoCloakMockCreateClientScopeExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockCreateClientScopeParams
	results *GoCloakMockCreateClientScopeResults
	Counter uint64
}

// GoCloakMockCreateClientScopeParams contains parameters of the GoCloak.CreateClientScope
type GoCloakMockCreateClientScopeParams struct {
	accessToken string
	realm       string
	scope       mm_gocloak.ClientScope
}

// GoCloakMockCreateClientScopeResults contains results of the GoCloak.CreateClientScope
type GoCloakMockCreateClientScopeResults struct {
	err error
}

// Expect sets up expected params for GoCloak.CreateClientScope
func (mmCreateClientScope *mGoCloakMockCreateClientScope) Expect(accessToken string, realm string, scope mm_gocloak.ClientScope) *mGoCloakMockCreateClientScope {
	if mmCreateClientScope.mock.funcCreateClientScope != nil {
		mmCreateClientScope.mock.t.Fatalf("GoCloakMock.CreateClientScope mock is already set by Set")
	}

	if mmCreateClientScope.defaultExpectation == nil {
		mmCreateClientScope.defaultExpectation = &GoCloakMockCreateClientScopeExpectation{}
	}

	mmCreateClientScope.defaultExpectation.params = &GoCloakMockCreateClientScopeParams{accessToken, realm, scope}
	for _, e := range mmCreateClientScope.expectations {
		if minimock.Equal(e.params, mmCreateClientScope.defaultExpectation.params) {
			mmCreateClientScope.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateClientScope.defaultExpectation.params)
		}
	}

	return mmCreateClientScope
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.CreateClientScope
func (mmCreateClientScope *mGoCloakMockCreateClientScope) Inspect(f func(accessToken string, realm string, scope mm_gocloak.ClientScope)) *mGoCloakMockCreateClientScope {
	if mmCreateClientScope.mock.inspectFuncCreateClientScope != nil {
		mmCreateClientScope.mock.t.Fatalf("Inspect function is already set for GoCloakMock.CreateClientScope")
	}

	mmCreateClientScope.mock.inspectFuncCreateClientScope = f

	return mmCreateClientScope
}

// Return sets up results that will be returned by GoCloak.CreateClientScope
func (mmCreateClientScope *mGoCloakMockCreateClientScope) Return(err error) *GoCloakMock {
	if mmCreateClientScope.mock.funcCreateClientScope != nil {
		mmCreateClientScope.mock.t.Fatalf("GoCloakMock.CreateClientScope mock is already set by Set")
	}

	if mmCreateClientScope.defaultExpectation == nil {
		mmCreateClientScope.defaultExpectation = &GoCloakMockCreateClientScopeExpectation{mock: mmCreateClientScope.mock}
	}
	mmCreateClientScope.defaultExpectation.results = &GoCloakMockCreateClientScopeResults{err}
	return mmCreateClientScope.mock
}

//Set uses given function f to mock the GoCloak.CreateClientScope method
func (mmCreateClientScope *mGoCloakMockCreateClientScope) Set(f func(accessToken string, realm string, scope mm_gocloak.ClientScope) (err error)) *GoCloakMock {
	if mmCreateClientScope.defaultExpectation != nil {
		mmCreateClientScope.mock.t.Fatalf("Default expectation is already set for the GoCloak.CreateClientScope method")
	}

	if len(mmCreateClientScope.expectations) > 0 {
		mmCreateClientScope.mock.t.Fatalf("Some expectations are already set for the GoCloak.CreateClientScope method")
	}

	mmCreateClientScope.mock.funcCreateClientScope = f
	return mmCreateClientScope.mock
}

// When sets expectation for the GoCloak.CreateClientScope which will trigger the result defined by the following
// Then helper
func (mmCreateClientScope *mGoCloakMockCreateClientScope) When(accessToken string, realm string, scope mm_gocloak.ClientScope) *GoCloakMockCreateClientScopeExpectation {
	if mmCreateClientScope.mock.funcCreateClientScope != nil {
		mmCreateClientScope.mock.t.Fatalf("GoCloakMock.CreateClientScope mock is already set by Set")
	}

	expectation := &GoCloakMockCreateClientScopeExpectation{
		mock:   mmCreateClientScope.mock,
		params: &GoCloakMockCreateClientScopeParams{accessToken, realm, scope},
	}
	mmCreateClientScope.expectations = append(mmCreateClientScope.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.CreateClientScope return parameters for the expectation previously defined by the When method
func (e *GoCloakMockCreateClientScopeExpectation) Then(err error) *GoCloakMock {
	e.results = &GoCloakMockCreateClientScopeResults{err}
	return e.mock
}

// CreateClientScope implements gocloak.GoCloak
func (mmCreateClientScope *GoCloakMock) CreateClientScope(accessToken string, realm string, scope mm_gocloak.ClientScope) (err error) {
	mm_atomic.AddUint64(&mmCreateClientScope.beforeCreateClientScopeCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateClientScope.afterCreateClientScopeCounter, 1)

	if mmCreateClientScope.inspectFuncCreateClientScope != nil {
		mmCreateClientScope.inspectFuncCreateClientScope(accessToken, realm, scope)
	}

	mm_params := &GoCloakMockCreateClientScopeParams{accessToken, realm, scope}

	// Record call args
	mmCreateClientScope.CreateClientScopeMock.mutex.Lock()
	mmCreateClientScope.CreateClientScopeMock.callArgs = append(mmCreateClientScope.CreateClientScopeMock.callArgs, mm_params)
	mmCreateClientScope.CreateClientScopeMock.mutex.Unlock()

	for _, e := range mmCreateClientScope.CreateClientScopeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateClientScope.CreateClientScopeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateClientScope.CreateClientScopeMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateClientScope.CreateClientScopeMock.defaultExpectation.params
		mm_got := GoCloakMockCreateClientScopeParams{accessToken, realm, scope}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateClientScope.t.Errorf("GoCloakMock.CreateClientScope got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateClientScope.CreateClientScopeMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateClientScope.t.Fatal("No results are set for the GoCloakMock.CreateClientScope")
		}
		return (*mm_results).err
	}
	if mmCreateClientScope.funcCreateClientScope != nil {
		return mmCreateClientScope.funcCreateClientScope(accessToken, realm, scope)
	}
	mmCreateClientScope.t.Fatalf("Unexpected call to GoCloakMock.CreateClientScope. %v %v %v", accessToken, realm, scope)
	return
}

// CreateClientScopeAfterCounter returns a count of finished GoCloakMock.CreateClientScope invocations
func (mmCreateClientScope *GoCloakMock) CreateClientScopeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateClientScope.afterCreateClientScopeCounter)
}

// CreateClientScopeBeforeCounter returns a count of GoCloakMock.CreateClientScope invocations
func (mmCreateClientScope *GoCloakMock) CreateClientScopeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateClientScope.beforeCreateClientScopeCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.CreateClientScope.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateClientScope *mGoCloakMockCreateClientScope) Calls() []*GoCloakMockCreateClientScopeParams {
	mmCreateClientScope.mutex.RLock()

	argCopy := make([]*GoCloakMockCreateClientScopeParams, len(mmCreateClientScope.callArgs))
	copy(argCopy, mmCreateClientScope.callArgs)

	mmCreateClientScope.mutex.RUnlock()

	return argCopy
}

// MinimockCreateClientScopeDone returns true if the count of the CreateClientScope invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockCreateClientScopeDone() bool {
	for _, e := range m.CreateClientScopeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateClientScopeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateClientScopeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateClientScope != nil && mm_atomic.LoadUint64(&m.afterCreateClientScopeCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateClientScopeInspect logs each unmet expectation
func (m *GoCloakMock) MinimockCreateClientScopeInspect() {
	for _, e := range m.CreateClientScopeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.CreateClientScope with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateClientScopeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateClientScopeCounter) < 1 {
		if m.CreateClientScopeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.CreateClientScope")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.CreateClientScope with params: %#v", *m.CreateClientScopeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateClientScope != nil && mm_atomic.LoadUint64(&m.afterCreateClientScopeCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.CreateClientScope")
	}
}

type mGoCloakMockCreateComponent struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockCreateComponentExpectation
	expectations       []*GoCloakMockCreateComponentExpectation

	callArgs []*GoCloakMockCreateComponentParams
	mutex    sync.RWMutex
}

// GoCloakMockCreateComponentExpectation specifies expectation struct of the GoCloak.CreateComponent
type GoCloakMockCreateComponentExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockCreateComponentParams
	results *GoCloakMockCreateComponentResults
	Counter uint64
}

// GoCloakMockCreateComponentParams contains parameters of the GoCloak.CreateComponent
type GoCloakMockCreateComponentParams struct {
	accessToken string
	realm       string
	component   mm_gocloak.Component
}

// GoCloakMockCreateComponentResults contains results of the GoCloak.CreateComponent
type GoCloakMockCreateComponentResults struct {
	err error
}

// Expect sets up expected params for GoCloak.CreateComponent
func (mmCreateComponent *mGoCloakMockCreateComponent) Expect(accessToken string, realm string, component mm_gocloak.Component) *mGoCloakMockCreateComponent {
	if mmCreateComponent.mock.funcCreateComponent != nil {
		mmCreateComponent.mock.t.Fatalf("GoCloakMock.CreateComponent mock is already set by Set")
	}

	if mmCreateComponent.defaultExpectation == nil {
		mmCreateComponent.defaultExpectation = &GoCloakMockCreateComponentExpectation{}
	}

	mmCreateComponent.defaultExpectation.params = &GoCloakMockCreateComponentParams{accessToken, realm, component}
	for _, e := range mmCreateComponent.expectations {
		if minimock.Equal(e.params, mmCreateComponent.defaultExpectation.params) {
			mmCreateComponent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateComponent.defaultExpectation.params)
		}
	}

	return mmCreateComponent
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.CreateComponent
func (mmCreateComponent *mGoCloakMockCreateComponent) Inspect(f func(accessToken string, realm string, component mm_gocloak.Component)) *mGoCloakMockCreateComponent {
	if mmCreateComponent.mock.inspectFuncCreateComponent != nil {
		mmCreateComponent.mock.t.Fatalf("Inspect function is already set for GoCloakMock.CreateComponent")
	}

	mmCreateComponent.mock.inspectFuncCreateComponent = f

	return mmCreateComponent
}

// Return sets up results that will be returned by GoCloak.CreateComponent
func (mmCreateComponent *mGoCloakMockCreateComponent) Return(err error) *GoCloakMock {
	if mmCreateComponent.mock.funcCreateComponent != nil {
		mmCreateComponent.mock.t.Fatalf("GoCloakMock.CreateComponent mock is already set by Set")
	}

	if mmCreateComponent.defaultExpectation == nil {
		mmCreateComponent.defaultExpectation = &GoCloakMockCreateComponentExpectation{mock: mmCreateComponent.mock}
	}
	mmCreateComponent.defaultExpectation.results = &GoCloakMockCreateComponentResults{err}
	return mmCreateComponent.mock
}

//Set uses given function f to mock the GoCloak.CreateComponent method
func (mmCreateComponent *mGoCloakMockCreateComponent) Set(f func(accessToken string, realm string, component mm_gocloak.Component) (err error)) *GoCloakMock {
	if mmCreateComponent.defaultExpectation != nil {
		mmCreateComponent.mock.t.Fatalf("Default expectation is already set for the GoCloak.CreateComponent method")
	}

	if len(mmCreateComponent.expectations) > 0 {
		mmCreateComponent.mock.t.Fatalf("Some expectations are already set for the GoCloak.CreateComponent method")
	}

	mmCreateComponent.mock.funcCreateComponent = f
	return mmCreateComponent.mock
}

// When sets expectation for the GoCloak.CreateComponent which will trigger the result defined by the following
// Then helper
func (mmCreateComponent *mGoCloakMockCreateComponent) When(accessToken string, realm string, component mm_gocloak.Component) *GoCloakMockCreateComponentExpectation {
	if mmCreateComponent.mock.funcCreateComponent != nil {
		mmCreateComponent.mock.t.Fatalf("GoCloakMock.CreateComponent mock is already set by Set")
	}

	expectation := &GoCloakMockCreateComponentExpectation{
		mock:   mmCreateComponent.mock,
		params: &GoCloakMockCreateComponentParams{accessToken, realm, component},
	}
	mmCreateComponent.expectations = append(mmCreateComponent.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.CreateComponent return parameters for the expectation previously defined by the When method
func (e *GoCloakMockCreateComponentExpectation) Then(err error) *GoCloakMock {
	e.results = &GoCloakMockCreateComponentResults{err}
	return e.mock
}

// CreateComponent implements gocloak.GoCloak
func (mmCreateComponent *GoCloakMock) CreateComponent(accessToken string, realm string, component mm_gocloak.Component) (err error) {
	mm_atomic.AddUint64(&mmCreateComponent.beforeCreateComponentCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateComponent.afterCreateComponentCounter, 1)

	if mmCreateComponent.inspectFuncCreateComponent != nil {
		mmCreateComponent.inspectFuncCreateComponent(accessToken, realm, component)
	}

	mm_params := &GoCloakMockCreateComponentParams{accessToken, realm, component}

	// Record call args
	mmCreateComponent.CreateComponentMock.mutex.Lock()
	mmCreateComponent.CreateComponentMock.callArgs = append(mmCreateComponent.CreateComponentMock.callArgs, mm_params)
	mmCreateComponent.CreateComponentMock.mutex.Unlock()

	for _, e := range mmCreateComponent.CreateComponentMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateComponent.CreateComponentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateComponent.CreateComponentMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateComponent.CreateComponentMock.defaultExpectation.params
		mm_got := GoCloakMockCreateComponentParams{accessToken, realm, component}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateComponent.t.Errorf("GoCloakMock.CreateComponent got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateComponent.CreateComponentMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateComponent.t.Fatal("No results are set for the GoCloakMock.CreateComponent")
		}
		return (*mm_results).err
	}
	if mmCreateComponent.funcCreateComponent != nil {
		return mmCreateComponent.funcCreateComponent(accessToken, realm, component)
	}
	mmCreateComponent.t.Fatalf("Unexpected call to GoCloakMock.CreateComponent. %v %v %v", accessToken, realm, component)
	return
}

// CreateComponentAfterCounter returns a count of finished GoCloakMock.CreateComponent invocations
func (mmCreateComponent *GoCloakMock) CreateComponentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateComponent.afterCreateComponentCounter)
}

// CreateComponentBeforeCounter returns a count of GoCloakMock.CreateComponent invocations
func (mmCreateComponent *GoCloakMock) CreateComponentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateComponent.beforeCreateComponentCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.CreateComponent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateComponent *mGoCloakMockCreateComponent) Calls() []*GoCloakMockCreateComponentParams {
	mmCreateComponent.mutex.RLock()

	argCopy := make([]*GoCloakMockCreateComponentParams, len(mmCreateComponent.callArgs))
	copy(argCopy, mmCreateComponent.callArgs)

	mmCreateComponent.mutex.RUnlock()

	return argCopy
}

// MinimockCreateComponentDone returns true if the count of the CreateComponent invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockCreateComponentDone() bool {
	for _, e := range m.CreateComponentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateComponentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateComponentCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateComponent != nil && mm_atomic.LoadUint64(&m.afterCreateComponentCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateComponentInspect logs each unmet expectation
func (m *GoCloakMock) MinimockCreateComponentInspect() {
	for _, e := range m.CreateComponentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.CreateComponent with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateComponentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateComponentCounter) < 1 {
		if m.CreateComponentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.CreateComponent")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.CreateComponent with params: %#v", *m.CreateComponentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateComponent != nil && mm_atomic.LoadUint64(&m.afterCreateComponentCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.CreateComponent")
	}
}

type mGoCloakMockCreateGroup struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockCreateGroupExpectation
	expectations       []*GoCloakMockCreateGroupExpectation

	callArgs []*GoCloakMockCreateGroupParams
	mutex    sync.RWMutex
}

// GoCloakMockCreateGroupExpectation specifies expectation struct of the GoCloak.CreateGroup
type GoCloakMockCreateGroupExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockCreateGroupParams
	results *GoCloakMockCreateGroupResults
	Counter uint64
}

// GoCloakMockCreateGroupParams contains parameters of the GoCloak.CreateGroup
type GoCloakMockCreateGroupParams struct {
	accessToken string
	realm       string
	group       mm_gocloak.Group
}

// GoCloakMockCreateGroupResults contains results of the GoCloak.CreateGroup
type GoCloakMockCreateGroupResults struct {
	err error
}

// Expect sets up expected params for GoCloak.CreateGroup
func (mmCreateGroup *mGoCloakMockCreateGroup) Expect(accessToken string, realm string, group mm_gocloak.Group) *mGoCloakMockCreateGroup {
	if mmCreateGroup.mock.funcCreateGroup != nil {
		mmCreateGroup.mock.t.Fatalf("GoCloakMock.CreateGroup mock is already set by Set")
	}

	if mmCreateGroup.defaultExpectation == nil {
		mmCreateGroup.defaultExpectation = &GoCloakMockCreateGroupExpectation{}
	}

	mmCreateGroup.defaultExpectation.params = &GoCloakMockCreateGroupParams{accessToken, realm, group}
	for _, e := range mmCreateGroup.expectations {
		if minimock.Equal(e.params, mmCreateGroup.defaultExpectation.params) {
			mmCreateGroup.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateGroup.defaultExpectation.params)
		}
	}

	return mmCreateGroup
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.CreateGroup
func (mmCreateGroup *mGoCloakMockCreateGroup) Inspect(f func(accessToken string, realm string, group mm_gocloak.Group)) *mGoCloakMockCreateGroup {
	if mmCreateGroup.mock.inspectFuncCreateGroup != nil {
		mmCreateGroup.mock.t.Fatalf("Inspect function is already set for GoCloakMock.CreateGroup")
	}

	mmCreateGroup.mock.inspectFuncCreateGroup = f

	return mmCreateGroup
}

// Return sets up results that will be returned by GoCloak.CreateGroup
func (mmCreateGroup *mGoCloakMockCreateGroup) Return(err error) *GoCloakMock {
	if mmCreateGroup.mock.funcCreateGroup != nil {
		mmCreateGroup.mock.t.Fatalf("GoCloakMock.CreateGroup mock is already set by Set")
	}

	if mmCreateGroup.defaultExpectation == nil {
		mmCreateGroup.defaultExpectation = &GoCloakMockCreateGroupExpectation{mock: mmCreateGroup.mock}
	}
	mmCreateGroup.defaultExpectation.results = &GoCloakMockCreateGroupResults{err}
	return mmCreateGroup.mock
}

//Set uses given function f to mock the GoCloak.CreateGroup method
func (mmCreateGroup *mGoCloakMockCreateGroup) Set(f func(accessToken string, realm string, group mm_gocloak.Group) (err error)) *GoCloakMock {
	if mmCreateGroup.defaultExpectation != nil {
		mmCreateGroup.mock.t.Fatalf("Default expectation is already set for the GoCloak.CreateGroup method")
	}

	if len(mmCreateGroup.expectations) > 0 {
		mmCreateGroup.mock.t.Fatalf("Some expectations are already set for the GoCloak.CreateGroup method")
	}

	mmCreateGroup.mock.funcCreateGroup = f
	return mmCreateGroup.mock
}

// When sets expectation for the GoCloak.CreateGroup which will trigger the result defined by the following
// Then helper
func (mmCreateGroup *mGoCloakMockCreateGroup) When(accessToken string, realm string, group mm_gocloak.Group) *GoCloakMockCreateGroupExpectation {
	if mmCreateGroup.mock.funcCreateGroup != nil {
		mmCreateGroup.mock.t.Fatalf("GoCloakMock.CreateGroup mock is already set by Set")
	}

	expectation := &GoCloakMockCreateGroupExpectation{
		mock:   mmCreateGroup.mock,
		params: &GoCloakMockCreateGroupParams{accessToken, realm, group},
	}
	mmCreateGroup.expectations = append(mmCreateGroup.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.CreateGroup return parameters for the expectation previously defined by the When method
func (e *GoCloakMockCreateGroupExpectation) Then(err error) *GoCloakMock {
	e.results = &GoCloakMockCreateGroupResults{err}
	return e.mock
}

// CreateGroup implements gocloak.GoCloak
func (mmCreateGroup *GoCloakMock) CreateGroup(accessToken string, realm string, group mm_gocloak.Group) (err error) {
	mm_atomic.AddUint64(&mmCreateGroup.beforeCreateGroupCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateGroup.afterCreateGroupCounter, 1)

	if mmCreateGroup.inspectFuncCreateGroup != nil {
		mmCreateGroup.inspectFuncCreateGroup(accessToken, realm, group)
	}

	mm_params := &GoCloakMockCreateGroupParams{accessToken, realm, group}

	// Record call args
	mmCreateGroup.CreateGroupMock.mutex.Lock()
	mmCreateGroup.CreateGroupMock.callArgs = append(mmCreateGroup.CreateGroupMock.callArgs, mm_params)
	mmCreateGroup.CreateGroupMock.mutex.Unlock()

	for _, e := range mmCreateGroup.CreateGroupMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateGroup.CreateGroupMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateGroup.CreateGroupMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateGroup.CreateGroupMock.defaultExpectation.params
		mm_got := GoCloakMockCreateGroupParams{accessToken, realm, group}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateGroup.t.Errorf("GoCloakMock.CreateGroup got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateGroup.CreateGroupMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateGroup.t.Fatal("No results are set for the GoCloakMock.CreateGroup")
		}
		return (*mm_results).err
	}
	if mmCreateGroup.funcCreateGroup != nil {
		return mmCreateGroup.funcCreateGroup(accessToken, realm, group)
	}
	mmCreateGroup.t.Fatalf("Unexpected call to GoCloakMock.CreateGroup. %v %v %v", accessToken, realm, group)
	return
}

// CreateGroupAfterCounter returns a count of finished GoCloakMock.CreateGroup invocations
func (mmCreateGroup *GoCloakMock) CreateGroupAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateGroup.afterCreateGroupCounter)
}

// CreateGroupBeforeCounter returns a count of GoCloakMock.CreateGroup invocations
func (mmCreateGroup *GoCloakMock) CreateGroupBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateGroup.beforeCreateGroupCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.CreateGroup.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateGroup *mGoCloakMockCreateGroup) Calls() []*GoCloakMockCreateGroupParams {
	mmCreateGroup.mutex.RLock()

	argCopy := make([]*GoCloakMockCreateGroupParams, len(mmCreateGroup.callArgs))
	copy(argCopy, mmCreateGroup.callArgs)

	mmCreateGroup.mutex.RUnlock()

	return argCopy
}

// MinimockCreateGroupDone returns true if the count of the CreateGroup invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockCreateGroupDone() bool {
	for _, e := range m.CreateGroupMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateGroupMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateGroupCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateGroup != nil && mm_atomic.LoadUint64(&m.afterCreateGroupCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateGroupInspect logs each unmet expectation
func (m *GoCloakMock) MinimockCreateGroupInspect() {
	for _, e := range m.CreateGroupMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.CreateGroup with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateGroupMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateGroupCounter) < 1 {
		if m.CreateGroupMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.CreateGroup")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.CreateGroup with params: %#v", *m.CreateGroupMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateGroup != nil && mm_atomic.LoadUint64(&m.afterCreateGroupCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.CreateGroup")
	}
}

type mGoCloakMockCreateRole struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockCreateRoleExpectation
	expectations       []*GoCloakMockCreateRoleExpectation

	callArgs []*GoCloakMockCreateRoleParams
	mutex    sync.RWMutex
}

// GoCloakMockCreateRoleExpectation specifies expectation struct of the GoCloak.CreateRole
type GoCloakMockCreateRoleExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockCreateRoleParams
	results *GoCloakMockCreateRoleResults
	Counter uint64
}

// GoCloakMockCreateRoleParams contains parameters of the GoCloak.CreateRole
type GoCloakMockCreateRoleParams struct {
	accessToken string
	realm       string
	clientID    string
	role        mm_gocloak.Role
}

// GoCloakMockCreateRoleResults contains results of the GoCloak.CreateRole
type GoCloakMockCreateRoleResults struct {
	err error
}

// Expect sets up expected params for GoCloak.CreateRole
func (mmCreateRole *mGoCloakMockCreateRole) Expect(accessToken string, realm string, clientID string, role mm_gocloak.Role) *mGoCloakMockCreateRole {
	if mmCreateRole.mock.funcCreateRole != nil {
		mmCreateRole.mock.t.Fatalf("GoCloakMock.CreateRole mock is already set by Set")
	}

	if mmCreateRole.defaultExpectation == nil {
		mmCreateRole.defaultExpectation = &GoCloakMockCreateRoleExpectation{}
	}

	mmCreateRole.defaultExpectation.params = &GoCloakMockCreateRoleParams{accessToken, realm, clientID, role}
	for _, e := range mmCreateRole.expectations {
		if minimock.Equal(e.params, mmCreateRole.defaultExpectation.params) {
			mmCreateRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateRole.defaultExpectation.params)
		}
	}

	return mmCreateRole
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.CreateRole
func (mmCreateRole *mGoCloakMockCreateRole) Inspect(f func(accessToken string, realm string, clientID string, role mm_gocloak.Role)) *mGoCloakMockCreateRole {
	if mmCreateRole.mock.inspectFuncCreateRole != nil {
		mmCreateRole.mock.t.Fatalf("Inspect function is already set for GoCloakMock.CreateRole")
	}

	mmCreateRole.mock.inspectFuncCreateRole = f

	return mmCreateRole
}

// Return sets up results that will be returned by GoCloak.CreateRole
func (mmCreateRole *mGoCloakMockCreateRole) Return(err error) *GoCloakMock {
	if mmCreateRole.mock.funcCreateRole != nil {
		mmCreateRole.mock.t.Fatalf("GoCloakMock.CreateRole mock is already set by Set")
	}

	if mmCreateRole.defaultExpectation == nil {
		mmCreateRole.defaultExpectation = &GoCloakMockCreateRoleExpectation{mock: mmCreateRole.mock}
	}
	mmCreateRole.defaultExpectation.results = &GoCloakMockCreateRoleResults{err}
	return mmCreateRole.mock
}

//Set uses given function f to mock the GoCloak.CreateRole method
func (mmCreateRole *mGoCloakMockCreateRole) Set(f func(accessToken string, realm string, clientID string, role mm_gocloak.Role) (err error)) *GoCloakMock {
	if mmCreateRole.defaultExpectation != nil {
		mmCreateRole.mock.t.Fatalf("Default expectation is already set for the GoCloak.CreateRole method")
	}

	if len(mmCreateRole.expectations) > 0 {
		mmCreateRole.mock.t.Fatalf("Some expectations are already set for the GoCloak.CreateRole method")
	}

	mmCreateRole.mock.funcCreateRole = f
	return mmCreateRole.mock
}

// When sets expectation for the GoCloak.CreateRole which will trigger the result defined by the following
// Then helper
func (mmCreateRole *mGoCloakMockCreateRole) When(accessToken string, realm string, clientID string, role mm_gocloak.Role) *GoCloakMockCreateRoleExpectation {
	if mmCreateRole.mock.funcCreateRole != nil {
		mmCreateRole.mock.t.Fatalf("GoCloakMock.CreateRole mock is already set by Set")
	}

	expectation := &GoCloakMockCreateRoleExpectation{
		mock:   mmCreateRole.mock,
		params: &GoCloakMockCreateRoleParams{accessToken, realm, clientID, role},
	}
	mmCreateRole.expectations = append(mmCreateRole.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.CreateRole return parameters for the expectation previously defined by the When method
func (e *GoCloakMockCreateRoleExpectation) Then(err error) *GoCloakMock {
	e.results = &GoCloakMockCreateRoleResults{err}
	return e.mock
}

// CreateRole implements gocloak.GoCloak
func (mmCreateRole *GoCloakMock) CreateRole(accessToken string, realm string, clientID string, role mm_gocloak.Role) (err error) {
	mm_atomic.AddUint64(&mmCreateRole.beforeCreateRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateRole.afterCreateRoleCounter, 1)

	if mmCreateRole.inspectFuncCreateRole != nil {
		mmCreateRole.inspectFuncCreateRole(accessToken, realm, clientID, role)
	}

	mm_params := &GoCloakMockCreateRoleParams{accessToken, realm, clientID, role}

	// Record call args
	mmCreateRole.CreateRoleMock.mutex.Lock()
	mmCreateRole.CreateRoleMock.callArgs = append(mmCreateRole.CreateRoleMock.callArgs, mm_params)
	mmCreateRole.CreateRoleMock.mutex.Unlock()

	for _, e := range mmCreateRole.CreateRoleMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateRole.CreateRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateRole.CreateRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateRole.CreateRoleMock.defaultExpectation.params
		mm_got := GoCloakMockCreateRoleParams{accessToken, realm, clientID, role}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateRole.t.Errorf("GoCloakMock.CreateRole got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateRole.CreateRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateRole.t.Fatal("No results are set for the GoCloakMock.CreateRole")
		}
		return (*mm_results).err
	}
	if mmCreateRole.funcCreateRole != nil {
		return mmCreateRole.funcCreateRole(accessToken, realm, clientID, role)
	}
	mmCreateRole.t.Fatalf("Unexpected call to GoCloakMock.CreateRole. %v %v %v %v", accessToken, realm, clientID, role)
	return
}

// CreateRoleAfterCounter returns a count of finished GoCloakMock.CreateRole invocations
func (mmCreateRole *GoCloakMock) CreateRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateRole.afterCreateRoleCounter)
}

// CreateRoleBeforeCounter returns a count of GoCloakMock.CreateRole invocations
func (mmCreateRole *GoCloakMock) CreateRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateRole.beforeCreateRoleCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.CreateRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateRole *mGoCloakMockCreateRole) Calls() []*GoCloakMockCreateRoleParams {
	mmCreateRole.mutex.RLock()

	argCopy := make([]*GoCloakMockCreateRoleParams, len(mmCreateRole.callArgs))
	copy(argCopy, mmCreateRole.callArgs)

	mmCreateRole.mutex.RUnlock()

	return argCopy
}

// MinimockCreateRoleDone returns true if the count of the CreateRole invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockCreateRoleDone() bool {
	for _, e := range m.CreateRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateRoleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateRoleCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateRole != nil && mm_atomic.LoadUint64(&m.afterCreateRoleCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateRoleInspect logs each unmet expectation
func (m *GoCloakMock) MinimockCreateRoleInspect() {
	for _, e := range m.CreateRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.CreateRole with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateRoleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateRoleCounter) < 1 {
		if m.CreateRoleMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.CreateRole")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.CreateRole with params: %#v", *m.CreateRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateRole != nil && mm_atomic.LoadUint64(&m.afterCreateRoleCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.CreateRole")
	}
}

type mGoCloakMockCreateUser struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockCreateUserExpectation
	expectations       []*GoCloakMockCreateUserExpectation

	callArgs []*GoCloakMockCreateUserParams
	mutex    sync.RWMutex
}

// GoCloakMockCreateUserExpectation specifies expectation struct of the GoCloak.CreateUser
type GoCloakMockCreateUserExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockCreateUserParams
	results *GoCloakMockCreateUserResults
	Counter uint64
}

// GoCloakMockCreateUserParams contains parameters of the GoCloak.CreateUser
type GoCloakMockCreateUserParams struct {
	token string
	realm string
	user  mm_gocloak.User
}

// GoCloakMockCreateUserResults contains results of the GoCloak.CreateUser
type GoCloakMockCreateUserResults struct {
	sp1 *string
	err error
}

// Expect sets up expected params for GoCloak.CreateUser
func (mmCreateUser *mGoCloakMockCreateUser) Expect(token string, realm string, user mm_gocloak.User) *mGoCloakMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("GoCloakMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &GoCloakMockCreateUserExpectation{}
	}

	mmCreateUser.defaultExpectation.params = &GoCloakMockCreateUserParams{token, realm, user}
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.CreateUser
func (mmCreateUser *mGoCloakMockCreateUser) Inspect(f func(token string, realm string, user mm_gocloak.User)) *mGoCloakMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for GoCloakMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by GoCloak.CreateUser
func (mmCreateUser *mGoCloakMockCreateUser) Return(sp1 *string, err error) *GoCloakMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("GoCloakMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &GoCloakMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &GoCloakMockCreateUserResults{sp1, err}
	return mmCreateUser.mock
}

//Set uses given function f to mock the GoCloak.CreateUser method
func (mmCreateUser *mGoCloakMockCreateUser) Set(f func(token string, realm string, user mm_gocloak.User) (sp1 *string, err error)) *GoCloakMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the GoCloak.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the GoCloak.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	return mmCreateUser.mock
}

// When sets expectation for the GoCloak.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mGoCloakMockCreateUser) When(token string, realm string, user mm_gocloak.User) *GoCloakMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("GoCloakMock.CreateUser mock is already set by Set")
	}

	expectation := &GoCloakMockCreateUserExpectation{
		mock:   mmCreateUser.mock,
		params: &GoCloakMockCreateUserParams{token, realm, user},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.CreateUser return parameters for the expectation previously defined by the When method
func (e *GoCloakMockCreateUserExpectation) Then(sp1 *string, err error) *GoCloakMock {
	e.results = &GoCloakMockCreateUserResults{sp1, err}
	return e.mock
}

// CreateUser implements gocloak.GoCloak
func (mmCreateUser *GoCloakMock) CreateUser(token string, realm string, user mm_gocloak.User) (sp1 *string, err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(token, realm, user)
	}

	mm_params := &GoCloakMockCreateUserParams{token, realm, user}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_got := GoCloakMockCreateUserParams{token, realm, user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("GoCloakMock.CreateUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the GoCloakMock.CreateUser")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(token, realm, user)
	}
	mmCreateUser.t.Fatalf("Unexpected call to GoCloakMock.CreateUser. %v %v %v", token, realm, user)
	return
}

// CreateUserAfterCounter returns a count of finished GoCloakMock.CreateUser invocations
func (mmCreateUser *GoCloakMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of GoCloakMock.CreateUser invocations
func (mmCreateUser *GoCloakMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mGoCloakMockCreateUser) Calls() []*GoCloakMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*GoCloakMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockCreateUserDone() bool {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *GoCloakMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.CreateUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.CreateUser")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.CreateUser with params: %#v", *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.CreateUser")
	}
}

type mGoCloakMockDecodeAccessToken struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockDecodeAccessTokenExpectation
	expectations       []*GoCloakMockDecodeAccessTokenExpectation

	callArgs []*GoCloakMockDecodeAccessTokenParams
	mutex    sync.RWMutex
}

// GoCloakMockDecodeAccessTokenExpectation specifies expectation struct of the GoCloak.DecodeAccessToken
type GoCloakMockDecodeAccessTokenExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockDecodeAccessTokenParams
	results *GoCloakMockDecodeAccessTokenResults
	Counter uint64
}

// GoCloakMockDecodeAccessTokenParams contains parameters of the GoCloak.DecodeAccessToken
type GoCloakMockDecodeAccessTokenParams struct {
	accessToken string
	realm       string
}

// GoCloakMockDecodeAccessTokenResults contains results of the GoCloak.DecodeAccessToken
type GoCloakMockDecodeAccessTokenResults struct {
	tp1 *jwt.Token
	mp1 *jwt.MapClaims
	err error
}

// Expect sets up expected params for GoCloak.DecodeAccessToken
func (mmDecodeAccessToken *mGoCloakMockDecodeAccessToken) Expect(accessToken string, realm string) *mGoCloakMockDecodeAccessToken {
	if mmDecodeAccessToken.mock.funcDecodeAccessToken != nil {
		mmDecodeAccessToken.mock.t.Fatalf("GoCloakMock.DecodeAccessToken mock is already set by Set")
	}

	if mmDecodeAccessToken.defaultExpectation == nil {
		mmDecodeAccessToken.defaultExpectation = &GoCloakMockDecodeAccessTokenExpectation{}
	}

	mmDecodeAccessToken.defaultExpectation.params = &GoCloakMockDecodeAccessTokenParams{accessToken, realm}
	for _, e := range mmDecodeAccessToken.expectations {
		if minimock.Equal(e.params, mmDecodeAccessToken.defaultExpectation.params) {
			mmDecodeAccessToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDecodeAccessToken.defaultExpectation.params)
		}
	}

	return mmDecodeAccessToken
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.DecodeAccessToken
func (mmDecodeAccessToken *mGoCloakMockDecodeAccessToken) Inspect(f func(accessToken string, realm string)) *mGoCloakMockDecodeAccessToken {
	if mmDecodeAccessToken.mock.inspectFuncDecodeAccessToken != nil {
		mmDecodeAccessToken.mock.t.Fatalf("Inspect function is already set for GoCloakMock.DecodeAccessToken")
	}

	mmDecodeAccessToken.mock.inspectFuncDecodeAccessToken = f

	return mmDecodeAccessToken
}

// Return sets up results that will be returned by GoCloak.DecodeAccessToken
func (mmDecodeAccessToken *mGoCloakMockDecodeAccessToken) Return(tp1 *jwt.Token, mp1 *jwt.MapClaims, err error) *GoCloakMock {
	if mmDecodeAccessToken.mock.funcDecodeAccessToken != nil {
		mmDecodeAccessToken.mock.t.Fatalf("GoCloakMock.DecodeAccessToken mock is already set by Set")
	}

	if mmDecodeAccessToken.defaultExpectation == nil {
		mmDecodeAccessToken.defaultExpectation = &GoCloakMockDecodeAccessTokenExpectation{mock: mmDecodeAccessToken.mock}
	}
	mmDecodeAccessToken.defaultExpectation.results = &GoCloakMockDecodeAccessTokenResults{tp1, mp1, err}
	return mmDecodeAccessToken.mock
}

//Set uses given function f to mock the GoCloak.DecodeAccessToken method
func (mmDecodeAccessToken *mGoCloakMockDecodeAccessToken) Set(f func(accessToken string, realm string) (tp1 *jwt.Token, mp1 *jwt.MapClaims, err error)) *GoCloakMock {
	if mmDecodeAccessToken.defaultExpectation != nil {
		mmDecodeAccessToken.mock.t.Fatalf("Default expectation is already set for the GoCloak.DecodeAccessToken method")
	}

	if len(mmDecodeAccessToken.expectations) > 0 {
		mmDecodeAccessToken.mock.t.Fatalf("Some expectations are already set for the GoCloak.DecodeAccessToken method")
	}

	mmDecodeAccessToken.mock.funcDecodeAccessToken = f
	return mmDecodeAccessToken.mock
}

// When sets expectation for the GoCloak.DecodeAccessToken which will trigger the result defined by the following
// Then helper
func (mmDecodeAccessToken *mGoCloakMockDecodeAccessToken) When(accessToken string, realm string) *GoCloakMockDecodeAccessTokenExpectation {
	if mmDecodeAccessToken.mock.funcDecodeAccessToken != nil {
		mmDecodeAccessToken.mock.t.Fatalf("GoCloakMock.DecodeAccessToken mock is already set by Set")
	}

	expectation := &GoCloakMockDecodeAccessTokenExpectation{
		mock:   mmDecodeAccessToken.mock,
		params: &GoCloakMockDecodeAccessTokenParams{accessToken, realm},
	}
	mmDecodeAccessToken.expectations = append(mmDecodeAccessToken.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.DecodeAccessToken return parameters for the expectation previously defined by the When method
func (e *GoCloakMockDecodeAccessTokenExpectation) Then(tp1 *jwt.Token, mp1 *jwt.MapClaims, err error) *GoCloakMock {
	e.results = &GoCloakMockDecodeAccessTokenResults{tp1, mp1, err}
	return e.mock
}

// DecodeAccessToken implements gocloak.GoCloak
func (mmDecodeAccessToken *GoCloakMock) DecodeAccessToken(accessToken string, realm string) (tp1 *jwt.Token, mp1 *jwt.MapClaims, err error) {
	mm_atomic.AddUint64(&mmDecodeAccessToken.beforeDecodeAccessTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmDecodeAccessToken.afterDecodeAccessTokenCounter, 1)

	if mmDecodeAccessToken.inspectFuncDecodeAccessToken != nil {
		mmDecodeAccessToken.inspectFuncDecodeAccessToken(accessToken, realm)
	}

	mm_params := &GoCloakMockDecodeAccessTokenParams{accessToken, realm}

	// Record call args
	mmDecodeAccessToken.DecodeAccessTokenMock.mutex.Lock()
	mmDecodeAccessToken.DecodeAccessTokenMock.callArgs = append(mmDecodeAccessToken.DecodeAccessTokenMock.callArgs, mm_params)
	mmDecodeAccessToken.DecodeAccessTokenMock.mutex.Unlock()

	for _, e := range mmDecodeAccessToken.DecodeAccessTokenMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1, e.results.mp1, e.results.err
		}
	}

	if mmDecodeAccessToken.DecodeAccessTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDecodeAccessToken.DecodeAccessTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmDecodeAccessToken.DecodeAccessTokenMock.defaultExpectation.params
		mm_got := GoCloakMockDecodeAccessTokenParams{accessToken, realm}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDecodeAccessToken.t.Errorf("GoCloakMock.DecodeAccessToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDecodeAccessToken.DecodeAccessTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmDecodeAccessToken.t.Fatal("No results are set for the GoCloakMock.DecodeAccessToken")
		}
		return (*mm_results).tp1, (*mm_results).mp1, (*mm_results).err
	}
	if mmDecodeAccessToken.funcDecodeAccessToken != nil {
		return mmDecodeAccessToken.funcDecodeAccessToken(accessToken, realm)
	}
	mmDecodeAccessToken.t.Fatalf("Unexpected call to GoCloakMock.DecodeAccessToken. %v %v", accessToken, realm)
	return
}

// DecodeAccessTokenAfterCounter returns a count of finished GoCloakMock.DecodeAccessToken invocations
func (mmDecodeAccessToken *GoCloakMock) DecodeAccessTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDecodeAccessToken.afterDecodeAccessTokenCounter)
}

// DecodeAccessTokenBeforeCounter returns a count of GoCloakMock.DecodeAccessToken invocations
func (mmDecodeAccessToken *GoCloakMock) DecodeAccessTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDecodeAccessToken.beforeDecodeAccessTokenCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.DecodeAccessToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDecodeAccessToken *mGoCloakMockDecodeAccessToken) Calls() []*GoCloakMockDecodeAccessTokenParams {
	mmDecodeAccessToken.mutex.RLock()

	argCopy := make([]*GoCloakMockDecodeAccessTokenParams, len(mmDecodeAccessToken.callArgs))
	copy(argCopy, mmDecodeAccessToken.callArgs)

	mmDecodeAccessToken.mutex.RUnlock()

	return argCopy
}

// MinimockDecodeAccessTokenDone returns true if the count of the DecodeAccessToken invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockDecodeAccessTokenDone() bool {
	for _, e := range m.DecodeAccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DecodeAccessTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDecodeAccessTokenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDecodeAccessToken != nil && mm_atomic.LoadUint64(&m.afterDecodeAccessTokenCounter) < 1 {
		return false
	}
	return true
}

// MinimockDecodeAccessTokenInspect logs each unmet expectation
func (m *GoCloakMock) MinimockDecodeAccessTokenInspect() {
	for _, e := range m.DecodeAccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.DecodeAccessToken with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DecodeAccessTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDecodeAccessTokenCounter) < 1 {
		if m.DecodeAccessTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.DecodeAccessToken")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.DecodeAccessToken with params: %#v", *m.DecodeAccessTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDecodeAccessToken != nil && mm_atomic.LoadUint64(&m.afterDecodeAccessTokenCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.DecodeAccessToken")
	}
}

type mGoCloakMockDecodeAccessTokenCustomClaims struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockDecodeAccessTokenCustomClaimsExpectation
	expectations       []*GoCloakMockDecodeAccessTokenCustomClaimsExpectation

	callArgs []*GoCloakMockDecodeAccessTokenCustomClaimsParams
	mutex    sync.RWMutex
}

// GoCloakMockDecodeAccessTokenCustomClaimsExpectation specifies expectation struct of the GoCloak.DecodeAccessTokenCustomClaims
type GoCloakMockDecodeAccessTokenCustomClaimsExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockDecodeAccessTokenCustomClaimsParams
	results *GoCloakMockDecodeAccessTokenCustomClaimsResults
	Counter uint64
}

// GoCloakMockDecodeAccessTokenCustomClaimsParams contains parameters of the GoCloak.DecodeAccessTokenCustomClaims
type GoCloakMockDecodeAccessTokenCustomClaimsParams struct {
	accessToken string
	realm       string
	claims      jwt.Claims
}

// GoCloakMockDecodeAccessTokenCustomClaimsResults contains results of the GoCloak.DecodeAccessTokenCustomClaims
type GoCloakMockDecodeAccessTokenCustomClaimsResults struct {
	tp1 *jwt.Token
	err error
}

// Expect sets up expected params for GoCloak.DecodeAccessTokenCustomClaims
func (mmDecodeAccessTokenCustomClaims *mGoCloakMockDecodeAccessTokenCustomClaims) Expect(accessToken string, realm string, claims jwt.Claims) *mGoCloakMockDecodeAccessTokenCustomClaims {
	if mmDecodeAccessTokenCustomClaims.mock.funcDecodeAccessTokenCustomClaims != nil {
		mmDecodeAccessTokenCustomClaims.mock.t.Fatalf("GoCloakMock.DecodeAccessTokenCustomClaims mock is already set by Set")
	}

	if mmDecodeAccessTokenCustomClaims.defaultExpectation == nil {
		mmDecodeAccessTokenCustomClaims.defaultExpectation = &GoCloakMockDecodeAccessTokenCustomClaimsExpectation{}
	}

	mmDecodeAccessTokenCustomClaims.defaultExpectation.params = &GoCloakMockDecodeAccessTokenCustomClaimsParams{accessToken, realm, claims}
	for _, e := range mmDecodeAccessTokenCustomClaims.expectations {
		if minimock.Equal(e.params, mmDecodeAccessTokenCustomClaims.defaultExpectation.params) {
			mmDecodeAccessTokenCustomClaims.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDecodeAccessTokenCustomClaims.defaultExpectation.params)
		}
	}

	return mmDecodeAccessTokenCustomClaims
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.DecodeAccessTokenCustomClaims
func (mmDecodeAccessTokenCustomClaims *mGoCloakMockDecodeAccessTokenCustomClaims) Inspect(f func(accessToken string, realm string, claims jwt.Claims)) *mGoCloakMockDecodeAccessTokenCustomClaims {
	if mmDecodeAccessTokenCustomClaims.mock.inspectFuncDecodeAccessTokenCustomClaims != nil {
		mmDecodeAccessTokenCustomClaims.mock.t.Fatalf("Inspect function is already set for GoCloakMock.DecodeAccessTokenCustomClaims")
	}

	mmDecodeAccessTokenCustomClaims.mock.inspectFuncDecodeAccessTokenCustomClaims = f

	return mmDecodeAccessTokenCustomClaims
}

// Return sets up results that will be returned by GoCloak.DecodeAccessTokenCustomClaims
func (mmDecodeAccessTokenCustomClaims *mGoCloakMockDecodeAccessTokenCustomClaims) Return(tp1 *jwt.Token, err error) *GoCloakMock {
	if mmDecodeAccessTokenCustomClaims.mock.funcDecodeAccessTokenCustomClaims != nil {
		mmDecodeAccessTokenCustomClaims.mock.t.Fatalf("GoCloakMock.DecodeAccessTokenCustomClaims mock is already set by Set")
	}

	if mmDecodeAccessTokenCustomClaims.defaultExpectation == nil {
		mmDecodeAccessTokenCustomClaims.defaultExpectation = &GoCloakMockDecodeAccessTokenCustomClaimsExpectation{mock: mmDecodeAccessTokenCustomClaims.mock}
	}
	mmDecodeAccessTokenCustomClaims.defaultExpectation.results = &GoCloakMockDecodeAccessTokenCustomClaimsResults{tp1, err}
	return mmDecodeAccessTokenCustomClaims.mock
}

//Set uses given function f to mock the GoCloak.DecodeAccessTokenCustomClaims method
func (mmDecodeAccessTokenCustomClaims *mGoCloakMockDecodeAccessTokenCustomClaims) Set(f func(accessToken string, realm string, claims jwt.Claims) (tp1 *jwt.Token, err error)) *GoCloakMock {
	if mmDecodeAccessTokenCustomClaims.defaultExpectation != nil {
		mmDecodeAccessTokenCustomClaims.mock.t.Fatalf("Default expectation is already set for the GoCloak.DecodeAccessTokenCustomClaims method")
	}

	if len(mmDecodeAccessTokenCustomClaims.expectations) > 0 {
		mmDecodeAccessTokenCustomClaims.mock.t.Fatalf("Some expectations are already set for the GoCloak.DecodeAccessTokenCustomClaims method")
	}

	mmDecodeAccessTokenCustomClaims.mock.funcDecodeAccessTokenCustomClaims = f
	return mmDecodeAccessTokenCustomClaims.mock
}

// When sets expectation for the GoCloak.DecodeAccessTokenCustomClaims which will trigger the result defined by the following
// Then helper
func (mmDecodeAccessTokenCustomClaims *mGoCloakMockDecodeAccessTokenCustomClaims) When(accessToken string, realm string, claims jwt.Claims) *GoCloakMockDecodeAccessTokenCustomClaimsExpectation {
	if mmDecodeAccessTokenCustomClaims.mock.funcDecodeAccessTokenCustomClaims != nil {
		mmDecodeAccessTokenCustomClaims.mock.t.Fatalf("GoCloakMock.DecodeAccessTokenCustomClaims mock is already set by Set")
	}

	expectation := &GoCloakMockDecodeAccessTokenCustomClaimsExpectation{
		mock:   mmDecodeAccessTokenCustomClaims.mock,
		params: &GoCloakMockDecodeAccessTokenCustomClaimsParams{accessToken, realm, claims},
	}
	mmDecodeAccessTokenCustomClaims.expectations = append(mmDecodeAccessTokenCustomClaims.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.DecodeAccessTokenCustomClaims return parameters for the expectation previously defined by the When method
func (e *GoCloakMockDecodeAccessTokenCustomClaimsExpectation) Then(tp1 *jwt.Token, err error) *GoCloakMock {
	e.results = &GoCloakMockDecodeAccessTokenCustomClaimsResults{tp1, err}
	return e.mock
}

// DecodeAccessTokenCustomClaims implements gocloak.GoCloak
func (mmDecodeAccessTokenCustomClaims *GoCloakMock) DecodeAccessTokenCustomClaims(accessToken string, realm string, claims jwt.Claims) (tp1 *jwt.Token, err error) {
	mm_atomic.AddUint64(&mmDecodeAccessTokenCustomClaims.beforeDecodeAccessTokenCustomClaimsCounter, 1)
	defer mm_atomic.AddUint64(&mmDecodeAccessTokenCustomClaims.afterDecodeAccessTokenCustomClaimsCounter, 1)

	if mmDecodeAccessTokenCustomClaims.inspectFuncDecodeAccessTokenCustomClaims != nil {
		mmDecodeAccessTokenCustomClaims.inspectFuncDecodeAccessTokenCustomClaims(accessToken, realm, claims)
	}

	mm_params := &GoCloakMockDecodeAccessTokenCustomClaimsParams{accessToken, realm, claims}

	// Record call args
	mmDecodeAccessTokenCustomClaims.DecodeAccessTokenCustomClaimsMock.mutex.Lock()
	mmDecodeAccessTokenCustomClaims.DecodeAccessTokenCustomClaimsMock.callArgs = append(mmDecodeAccessTokenCustomClaims.DecodeAccessTokenCustomClaimsMock.callArgs, mm_params)
	mmDecodeAccessTokenCustomClaims.DecodeAccessTokenCustomClaimsMock.mutex.Unlock()

	for _, e := range mmDecodeAccessTokenCustomClaims.DecodeAccessTokenCustomClaimsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1, e.results.err
		}
	}

	if mmDecodeAccessTokenCustomClaims.DecodeAccessTokenCustomClaimsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDecodeAccessTokenCustomClaims.DecodeAccessTokenCustomClaimsMock.defaultExpectation.Counter, 1)
		mm_want := mmDecodeAccessTokenCustomClaims.DecodeAccessTokenCustomClaimsMock.defaultExpectation.params
		mm_got := GoCloakMockDecodeAccessTokenCustomClaimsParams{accessToken, realm, claims}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDecodeAccessTokenCustomClaims.t.Errorf("GoCloakMock.DecodeAccessTokenCustomClaims got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDecodeAccessTokenCustomClaims.DecodeAccessTokenCustomClaimsMock.defaultExpectation.results
		if mm_results == nil {
			mmDecodeAccessTokenCustomClaims.t.Fatal("No results are set for the GoCloakMock.DecodeAccessTokenCustomClaims")
		}
		return (*mm_results).tp1, (*mm_results).err
	}
	if mmDecodeAccessTokenCustomClaims.funcDecodeAccessTokenCustomClaims != nil {
		return mmDecodeAccessTokenCustomClaims.funcDecodeAccessTokenCustomClaims(accessToken, realm, claims)
	}
	mmDecodeAccessTokenCustomClaims.t.Fatalf("Unexpected call to GoCloakMock.DecodeAccessTokenCustomClaims. %v %v %v", accessToken, realm, claims)
	return
}

// DecodeAccessTokenCustomClaimsAfterCounter returns a count of finished GoCloakMock.DecodeAccessTokenCustomClaims invocations
func (mmDecodeAccessTokenCustomClaims *GoCloakMock) DecodeAccessTokenCustomClaimsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDecodeAccessTokenCustomClaims.afterDecodeAccessTokenCustomClaimsCounter)
}

// DecodeAccessTokenCustomClaimsBeforeCounter returns a count of GoCloakMock.DecodeAccessTokenCustomClaims invocations
func (mmDecodeAccessTokenCustomClaims *GoCloakMock) DecodeAccessTokenCustomClaimsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDecodeAccessTokenCustomClaims.beforeDecodeAccessTokenCustomClaimsCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.DecodeAccessTokenCustomClaims.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDecodeAccessTokenCustomClaims *mGoCloakMockDecodeAccessTokenCustomClaims) Calls() []*GoCloakMockDecodeAccessTokenCustomClaimsParams {
	mmDecodeAccessTokenCustomClaims.mutex.RLock()

	argCopy := make([]*GoCloakMockDecodeAccessTokenCustomClaimsParams, len(mmDecodeAccessTokenCustomClaims.callArgs))
	copy(argCopy, mmDecodeAccessTokenCustomClaims.callArgs)

	mmDecodeAccessTokenCustomClaims.mutex.RUnlock()

	return argCopy
}

// MinimockDecodeAccessTokenCustomClaimsDone returns true if the count of the DecodeAccessTokenCustomClaims invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockDecodeAccessTokenCustomClaimsDone() bool {
	for _, e := range m.DecodeAccessTokenCustomClaimsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DecodeAccessTokenCustomClaimsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDecodeAccessTokenCustomClaimsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDecodeAccessTokenCustomClaims != nil && mm_atomic.LoadUint64(&m.afterDecodeAccessTokenCustomClaimsCounter) < 1 {
		return false
	}
	return true
}

// MinimockDecodeAccessTokenCustomClaimsInspect logs each unmet expectation
func (m *GoCloakMock) MinimockDecodeAccessTokenCustomClaimsInspect() {
	for _, e := range m.DecodeAccessTokenCustomClaimsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.DecodeAccessTokenCustomClaims with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DecodeAccessTokenCustomClaimsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDecodeAccessTokenCustomClaimsCounter) < 1 {
		if m.DecodeAccessTokenCustomClaimsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.DecodeAccessTokenCustomClaims")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.DecodeAccessTokenCustomClaims with params: %#v", *m.DecodeAccessTokenCustomClaimsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDecodeAccessTokenCustomClaims != nil && mm_atomic.LoadUint64(&m.afterDecodeAccessTokenCustomClaimsCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.DecodeAccessTokenCustomClaims")
	}
}

type mGoCloakMockDeleteClient struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockDeleteClientExpectation
	expectations       []*GoCloakMockDeleteClientExpectation

	callArgs []*GoCloakMockDeleteClientParams
	mutex    sync.RWMutex
}

// GoCloakMockDeleteClientExpectation specifies expectation struct of the GoCloak.DeleteClient
type GoCloakMockDeleteClientExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockDeleteClientParams
	results *GoCloakMockDeleteClientResults
	Counter uint64
}

// GoCloakMockDeleteClientParams contains parameters of the GoCloak.DeleteClient
type GoCloakMockDeleteClientParams struct {
	accessToken string
	realm       string
	clientID    string
}

// GoCloakMockDeleteClientResults contains results of the GoCloak.DeleteClient
type GoCloakMockDeleteClientResults struct {
	err error
}

// Expect sets up expected params for GoCloak.DeleteClient
func (mmDeleteClient *mGoCloakMockDeleteClient) Expect(accessToken string, realm string, clientID string) *mGoCloakMockDeleteClient {
	if mmDeleteClient.mock.funcDeleteClient != nil {
		mmDeleteClient.mock.t.Fatalf("GoCloakMock.DeleteClient mock is already set by Set")
	}

	if mmDeleteClient.defaultExpectation == nil {
		mmDeleteClient.defaultExpectation = &GoCloakMockDeleteClientExpectation{}
	}

	mmDeleteClient.defaultExpectation.params = &GoCloakMockDeleteClientParams{accessToken, realm, clientID}
	for _, e := range mmDeleteClient.expectations {
		if minimock.Equal(e.params, mmDeleteClient.defaultExpectation.params) {
			mmDeleteClient.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteClient.defaultExpectation.params)
		}
	}

	return mmDeleteClient
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.DeleteClient
func (mmDeleteClient *mGoCloakMockDeleteClient) Inspect(f func(accessToken string, realm string, clientID string)) *mGoCloakMockDeleteClient {
	if mmDeleteClient.mock.inspectFuncDeleteClient != nil {
		mmDeleteClient.mock.t.Fatalf("Inspect function is already set for GoCloakMock.DeleteClient")
	}

	mmDeleteClient.mock.inspectFuncDeleteClient = f

	return mmDeleteClient
}

// Return sets up results that will be returned by GoCloak.DeleteClient
func (mmDeleteClient *mGoCloakMockDeleteClient) Return(err error) *GoCloakMock {
	if mmDeleteClient.mock.funcDeleteClient != nil {
		mmDeleteClient.mock.t.Fatalf("GoCloakMock.DeleteClient mock is already set by Set")
	}

	if mmDeleteClient.defaultExpectation == nil {
		mmDeleteClient.defaultExpectation = &GoCloakMockDeleteClientExpectation{mock: mmDeleteClient.mock}
	}
	mmDeleteClient.defaultExpectation.results = &GoCloakMockDeleteClientResults{err}
	return mmDeleteClient.mock
}

//Set uses given function f to mock the GoCloak.DeleteClient method
func (mmDeleteClient *mGoCloakMockDeleteClient) Set(f func(accessToken string, realm string, clientID string) (err error)) *GoCloakMock {
	if mmDeleteClient.defaultExpectation != nil {
		mmDeleteClient.mock.t.Fatalf("Default expectation is already set for the GoCloak.DeleteClient method")
	}

	if len(mmDeleteClient.expectations) > 0 {
		mmDeleteClient.mock.t.Fatalf("Some expectations are already set for the GoCloak.DeleteClient method")
	}

	mmDeleteClient.mock.funcDeleteClient = f
	return mmDeleteClient.mock
}

// When sets expectation for the GoCloak.DeleteClient which will trigger the result defined by the following
// Then helper
func (mmDeleteClient *mGoCloakMockDeleteClient) When(accessToken string, realm string, clientID string) *GoCloakMockDeleteClientExpectation {
	if mmDeleteClient.mock.funcDeleteClient != nil {
		mmDeleteClient.mock.t.Fatalf("GoCloakMock.DeleteClient mock is already set by Set")
	}

	expectation := &GoCloakMockDeleteClientExpectation{
		mock:   mmDeleteClient.mock,
		params: &GoCloakMockDeleteClientParams{accessToken, realm, clientID},
	}
	mmDeleteClient.expectations = append(mmDeleteClient.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.DeleteClient return parameters for the expectation previously defined by the When method
func (e *GoCloakMockDeleteClientExpectation) Then(err error) *GoCloakMock {
	e.results = &GoCloakMockDeleteClientResults{err}
	return e.mock
}

// DeleteClient implements gocloak.GoCloak
func (mmDeleteClient *GoCloakMock) DeleteClient(accessToken string, realm string, clientID string) (err error) {
	mm_atomic.AddUint64(&mmDeleteClient.beforeDeleteClientCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteClient.afterDeleteClientCounter, 1)

	if mmDeleteClient.inspectFuncDeleteClient != nil {
		mmDeleteClient.inspectFuncDeleteClient(accessToken, realm, clientID)
	}

	mm_params := &GoCloakMockDeleteClientParams{accessToken, realm, clientID}

	// Record call args
	mmDeleteClient.DeleteClientMock.mutex.Lock()
	mmDeleteClient.DeleteClientMock.callArgs = append(mmDeleteClient.DeleteClientMock.callArgs, mm_params)
	mmDeleteClient.DeleteClientMock.mutex.Unlock()

	for _, e := range mmDeleteClient.DeleteClientMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteClient.DeleteClientMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteClient.DeleteClientMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteClient.DeleteClientMock.defaultExpectation.params
		mm_got := GoCloakMockDeleteClientParams{accessToken, realm, clientID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteClient.t.Errorf("GoCloakMock.DeleteClient got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteClient.DeleteClientMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteClient.t.Fatal("No results are set for the GoCloakMock.DeleteClient")
		}
		return (*mm_results).err
	}
	if mmDeleteClient.funcDeleteClient != nil {
		return mmDeleteClient.funcDeleteClient(accessToken, realm, clientID)
	}
	mmDeleteClient.t.Fatalf("Unexpected call to GoCloakMock.DeleteClient. %v %v %v", accessToken, realm, clientID)
	return
}

// DeleteClientAfterCounter returns a count of finished GoCloakMock.DeleteClient invocations
func (mmDeleteClient *GoCloakMock) DeleteClientAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteClient.afterDeleteClientCounter)
}

// DeleteClientBeforeCounter returns a count of GoCloakMock.DeleteClient invocations
func (mmDeleteClient *GoCloakMock) DeleteClientBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteClient.beforeDeleteClientCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.DeleteClient.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteClient *mGoCloakMockDeleteClient) Calls() []*GoCloakMockDeleteClientParams {
	mmDeleteClient.mutex.RLock()

	argCopy := make([]*GoCloakMockDeleteClientParams, len(mmDeleteClient.callArgs))
	copy(argCopy, mmDeleteClient.callArgs)

	mmDeleteClient.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteClientDone returns true if the count of the DeleteClient invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockDeleteClientDone() bool {
	for _, e := range m.DeleteClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteClientMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteClientCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteClient != nil && mm_atomic.LoadUint64(&m.afterDeleteClientCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteClientInspect logs each unmet expectation
func (m *GoCloakMock) MinimockDeleteClientInspect() {
	for _, e := range m.DeleteClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.DeleteClient with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteClientMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteClientCounter) < 1 {
		if m.DeleteClientMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.DeleteClient")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.DeleteClient with params: %#v", *m.DeleteClientMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteClient != nil && mm_atomic.LoadUint64(&m.afterDeleteClientCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.DeleteClient")
	}
}

type mGoCloakMockDeleteClientScope struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockDeleteClientScopeExpectation
	expectations       []*GoCloakMockDeleteClientScopeExpectation

	callArgs []*GoCloakMockDeleteClientScopeParams
	mutex    sync.RWMutex
}

// GoCloakMockDeleteClientScopeExpectation specifies expectation struct of the GoCloak.DeleteClientScope
type GoCloakMockDeleteClientScopeExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockDeleteClientScopeParams
	results *GoCloakMockDeleteClientScopeResults
	Counter uint64
}

// GoCloakMockDeleteClientScopeParams contains parameters of the GoCloak.DeleteClientScope
type GoCloakMockDeleteClientScopeParams struct {
	accessToken string
	realm       string
	scopeID     string
}

// GoCloakMockDeleteClientScopeResults contains results of the GoCloak.DeleteClientScope
type GoCloakMockDeleteClientScopeResults struct {
	err error
}

// Expect sets up expected params for GoCloak.DeleteClientScope
func (mmDeleteClientScope *mGoCloakMockDeleteClientScope) Expect(accessToken string, realm string, scopeID string) *mGoCloakMockDeleteClientScope {
	if mmDeleteClientScope.mock.funcDeleteClientScope != nil {
		mmDeleteClientScope.mock.t.Fatalf("GoCloakMock.DeleteClientScope mock is already set by Set")
	}

	if mmDeleteClientScope.defaultExpectation == nil {
		mmDeleteClientScope.defaultExpectation = &GoCloakMockDeleteClientScopeExpectation{}
	}

	mmDeleteClientScope.defaultExpectation.params = &GoCloakMockDeleteClientScopeParams{accessToken, realm, scopeID}
	for _, e := range mmDeleteClientScope.expectations {
		if minimock.Equal(e.params, mmDeleteClientScope.defaultExpectation.params) {
			mmDeleteClientScope.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteClientScope.defaultExpectation.params)
		}
	}

	return mmDeleteClientScope
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.DeleteClientScope
func (mmDeleteClientScope *mGoCloakMockDeleteClientScope) Inspect(f func(accessToken string, realm string, scopeID string)) *mGoCloakMockDeleteClientScope {
	if mmDeleteClientScope.mock.inspectFuncDeleteClientScope != nil {
		mmDeleteClientScope.mock.t.Fatalf("Inspect function is already set for GoCloakMock.DeleteClientScope")
	}

	mmDeleteClientScope.mock.inspectFuncDeleteClientScope = f

	return mmDeleteClientScope
}

// Return sets up results that will be returned by GoCloak.DeleteClientScope
func (mmDeleteClientScope *mGoCloakMockDeleteClientScope) Return(err error) *GoCloakMock {
	if mmDeleteClientScope.mock.funcDeleteClientScope != nil {
		mmDeleteClientScope.mock.t.Fatalf("GoCloakMock.DeleteClientScope mock is already set by Set")
	}

	if mmDeleteClientScope.defaultExpectation == nil {
		mmDeleteClientScope.defaultExpectation = &GoCloakMockDeleteClientScopeExpectation{mock: mmDeleteClientScope.mock}
	}
	mmDeleteClientScope.defaultExpectation.results = &GoCloakMockDeleteClientScopeResults{err}
	return mmDeleteClientScope.mock
}

//Set uses given function f to mock the GoCloak.DeleteClientScope method
func (mmDeleteClientScope *mGoCloakMockDeleteClientScope) Set(f func(accessToken string, realm string, scopeID string) (err error)) *GoCloakMock {
	if mmDeleteClientScope.defaultExpectation != nil {
		mmDeleteClientScope.mock.t.Fatalf("Default expectation is already set for the GoCloak.DeleteClientScope method")
	}

	if len(mmDeleteClientScope.expectations) > 0 {
		mmDeleteClientScope.mock.t.Fatalf("Some expectations are already set for the GoCloak.DeleteClientScope method")
	}

	mmDeleteClientScope.mock.funcDeleteClientScope = f
	return mmDeleteClientScope.mock
}

// When sets expectation for the GoCloak.DeleteClientScope which will trigger the result defined by the following
// Then helper
func (mmDeleteClientScope *mGoCloakMockDeleteClientScope) When(accessToken string, realm string, scopeID string) *GoCloakMockDeleteClientScopeExpectation {
	if mmDeleteClientScope.mock.funcDeleteClientScope != nil {
		mmDeleteClientScope.mock.t.Fatalf("GoCloakMock.DeleteClientScope mock is already set by Set")
	}

	expectation := &GoCloakMockDeleteClientScopeExpectation{
		mock:   mmDeleteClientScope.mock,
		params: &GoCloakMockDeleteClientScopeParams{accessToken, realm, scopeID},
	}
	mmDeleteClientScope.expectations = append(mmDeleteClientScope.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.DeleteClientScope return parameters for the expectation previously defined by the When method
func (e *GoCloakMockDeleteClientScopeExpectation) Then(err error) *GoCloakMock {
	e.results = &GoCloakMockDeleteClientScopeResults{err}
	return e.mock
}

// DeleteClientScope implements gocloak.GoCloak
func (mmDeleteClientScope *GoCloakMock) DeleteClientScope(accessToken string, realm string, scopeID string) (err error) {
	mm_atomic.AddUint64(&mmDeleteClientScope.beforeDeleteClientScopeCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteClientScope.afterDeleteClientScopeCounter, 1)

	if mmDeleteClientScope.inspectFuncDeleteClientScope != nil {
		mmDeleteClientScope.inspectFuncDeleteClientScope(accessToken, realm, scopeID)
	}

	mm_params := &GoCloakMockDeleteClientScopeParams{accessToken, realm, scopeID}

	// Record call args
	mmDeleteClientScope.DeleteClientScopeMock.mutex.Lock()
	mmDeleteClientScope.DeleteClientScopeMock.callArgs = append(mmDeleteClientScope.DeleteClientScopeMock.callArgs, mm_params)
	mmDeleteClientScope.DeleteClientScopeMock.mutex.Unlock()

	for _, e := range mmDeleteClientScope.DeleteClientScopeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteClientScope.DeleteClientScopeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteClientScope.DeleteClientScopeMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteClientScope.DeleteClientScopeMock.defaultExpectation.params
		mm_got := GoCloakMockDeleteClientScopeParams{accessToken, realm, scopeID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteClientScope.t.Errorf("GoCloakMock.DeleteClientScope got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteClientScope.DeleteClientScopeMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteClientScope.t.Fatal("No results are set for the GoCloakMock.DeleteClientScope")
		}
		return (*mm_results).err
	}
	if mmDeleteClientScope.funcDeleteClientScope != nil {
		return mmDeleteClientScope.funcDeleteClientScope(accessToken, realm, scopeID)
	}
	mmDeleteClientScope.t.Fatalf("Unexpected call to GoCloakMock.DeleteClientScope. %v %v %v", accessToken, realm, scopeID)
	return
}

// DeleteClientScopeAfterCounter returns a count of finished GoCloakMock.DeleteClientScope invocations
func (mmDeleteClientScope *GoCloakMock) DeleteClientScopeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteClientScope.afterDeleteClientScopeCounter)
}

// DeleteClientScopeBeforeCounter returns a count of GoCloakMock.DeleteClientScope invocations
func (mmDeleteClientScope *GoCloakMock) DeleteClientScopeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteClientScope.beforeDeleteClientScopeCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.DeleteClientScope.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteClientScope *mGoCloakMockDeleteClientScope) Calls() []*GoCloakMockDeleteClientScopeParams {
	mmDeleteClientScope.mutex.RLock()

	argCopy := make([]*GoCloakMockDeleteClientScopeParams, len(mmDeleteClientScope.callArgs))
	copy(argCopy, mmDeleteClientScope.callArgs)

	mmDeleteClientScope.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteClientScopeDone returns true if the count of the DeleteClientScope invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockDeleteClientScopeDone() bool {
	for _, e := range m.DeleteClientScopeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteClientScopeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteClientScopeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteClientScope != nil && mm_atomic.LoadUint64(&m.afterDeleteClientScopeCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteClientScopeInspect logs each unmet expectation
func (m *GoCloakMock) MinimockDeleteClientScopeInspect() {
	for _, e := range m.DeleteClientScopeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.DeleteClientScope with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteClientScopeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteClientScopeCounter) < 1 {
		if m.DeleteClientScopeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.DeleteClientScope")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.DeleteClientScope with params: %#v", *m.DeleteClientScopeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteClientScope != nil && mm_atomic.LoadUint64(&m.afterDeleteClientScopeCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.DeleteClientScope")
	}
}

type mGoCloakMockDeleteComponent struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockDeleteComponentExpectation
	expectations       []*GoCloakMockDeleteComponentExpectation

	callArgs []*GoCloakMockDeleteComponentParams
	mutex    sync.RWMutex
}

// GoCloakMockDeleteComponentExpectation specifies expectation struct of the GoCloak.DeleteComponent
type GoCloakMockDeleteComponentExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockDeleteComponentParams
	results *GoCloakMockDeleteComponentResults
	Counter uint64
}

// GoCloakMockDeleteComponentParams contains parameters of the GoCloak.DeleteComponent
type GoCloakMockDeleteComponentParams struct {
	accessToken string
	realm       string
	componentID string
}

// GoCloakMockDeleteComponentResults contains results of the GoCloak.DeleteComponent
type GoCloakMockDeleteComponentResults struct {
	err error
}

// Expect sets up expected params for GoCloak.DeleteComponent
func (mmDeleteComponent *mGoCloakMockDeleteComponent) Expect(accessToken string, realm string, componentID string) *mGoCloakMockDeleteComponent {
	if mmDeleteComponent.mock.funcDeleteComponent != nil {
		mmDeleteComponent.mock.t.Fatalf("GoCloakMock.DeleteComponent mock is already set by Set")
	}

	if mmDeleteComponent.defaultExpectation == nil {
		mmDeleteComponent.defaultExpectation = &GoCloakMockDeleteComponentExpectation{}
	}

	mmDeleteComponent.defaultExpectation.params = &GoCloakMockDeleteComponentParams{accessToken, realm, componentID}
	for _, e := range mmDeleteComponent.expectations {
		if minimock.Equal(e.params, mmDeleteComponent.defaultExpectation.params) {
			mmDeleteComponent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteComponent.defaultExpectation.params)
		}
	}

	return mmDeleteComponent
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.DeleteComponent
func (mmDeleteComponent *mGoCloakMockDeleteComponent) Inspect(f func(accessToken string, realm string, componentID string)) *mGoCloakMockDeleteComponent {
	if mmDeleteComponent.mock.inspectFuncDeleteComponent != nil {
		mmDeleteComponent.mock.t.Fatalf("Inspect function is already set for GoCloakMock.DeleteComponent")
	}

	mmDeleteComponent.mock.inspectFuncDeleteComponent = f

	return mmDeleteComponent
}

// Return sets up results that will be returned by GoCloak.DeleteComponent
func (mmDeleteComponent *mGoCloakMockDeleteComponent) Return(err error) *GoCloakMock {
	if mmDeleteComponent.mock.funcDeleteComponent != nil {
		mmDeleteComponent.mock.t.Fatalf("GoCloakMock.DeleteComponent mock is already set by Set")
	}

	if mmDeleteComponent.defaultExpectation == nil {
		mmDeleteComponent.defaultExpectation = &GoCloakMockDeleteComponentExpectation{mock: mmDeleteComponent.mock}
	}
	mmDeleteComponent.defaultExpectation.results = &GoCloakMockDeleteComponentResults{err}
	return mmDeleteComponent.mock
}

//Set uses given function f to mock the GoCloak.DeleteComponent method
func (mmDeleteComponent *mGoCloakMockDeleteComponent) Set(f func(accessToken string, realm string, componentID string) (err error)) *GoCloakMock {
	if mmDeleteComponent.defaultExpectation != nil {
		mmDeleteComponent.mock.t.Fatalf("Default expectation is already set for the GoCloak.DeleteComponent method")
	}

	if len(mmDeleteComponent.expectations) > 0 {
		mmDeleteComponent.mock.t.Fatalf("Some expectations are already set for the GoCloak.DeleteComponent method")
	}

	mmDeleteComponent.mock.funcDeleteComponent = f
	return mmDeleteComponent.mock
}

// When sets expectation for the GoCloak.DeleteComponent which will trigger the result defined by the following
// Then helper
func (mmDeleteComponent *mGoCloakMockDeleteComponent) When(accessToken string, realm string, componentID string) *GoCloakMockDeleteComponentExpectation {
	if mmDeleteComponent.mock.funcDeleteComponent != nil {
		mmDeleteComponent.mock.t.Fatalf("GoCloakMock.DeleteComponent mock is already set by Set")
	}

	expectation := &GoCloakMockDeleteComponentExpectation{
		mock:   mmDeleteComponent.mock,
		params: &GoCloakMockDeleteComponentParams{accessToken, realm, componentID},
	}
	mmDeleteComponent.expectations = append(mmDeleteComponent.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.DeleteComponent return parameters for the expectation previously defined by the When method
func (e *GoCloakMockDeleteComponentExpectation) Then(err error) *GoCloakMock {
	e.results = &GoCloakMockDeleteComponentResults{err}
	return e.mock
}

// DeleteComponent implements gocloak.GoCloak
func (mmDeleteComponent *GoCloakMock) DeleteComponent(accessToken string, realm string, componentID string) (err error) {
	mm_atomic.AddUint64(&mmDeleteComponent.beforeDeleteComponentCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteComponent.afterDeleteComponentCounter, 1)

	if mmDeleteComponent.inspectFuncDeleteComponent != nil {
		mmDeleteComponent.inspectFuncDeleteComponent(accessToken, realm, componentID)
	}

	mm_params := &GoCloakMockDeleteComponentParams{accessToken, realm, componentID}

	// Record call args
	mmDeleteComponent.DeleteComponentMock.mutex.Lock()
	mmDeleteComponent.DeleteComponentMock.callArgs = append(mmDeleteComponent.DeleteComponentMock.callArgs, mm_params)
	mmDeleteComponent.DeleteComponentMock.mutex.Unlock()

	for _, e := range mmDeleteComponent.DeleteComponentMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteComponent.DeleteComponentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteComponent.DeleteComponentMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteComponent.DeleteComponentMock.defaultExpectation.params
		mm_got := GoCloakMockDeleteComponentParams{accessToken, realm, componentID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteComponent.t.Errorf("GoCloakMock.DeleteComponent got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteComponent.DeleteComponentMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteComponent.t.Fatal("No results are set for the GoCloakMock.DeleteComponent")
		}
		return (*mm_results).err
	}
	if mmDeleteComponent.funcDeleteComponent != nil {
		return mmDeleteComponent.funcDeleteComponent(accessToken, realm, componentID)
	}
	mmDeleteComponent.t.Fatalf("Unexpected call to GoCloakMock.DeleteComponent. %v %v %v", accessToken, realm, componentID)
	return
}

// DeleteComponentAfterCounter returns a count of finished GoCloakMock.DeleteComponent invocations
func (mmDeleteComponent *GoCloakMock) DeleteComponentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteComponent.afterDeleteComponentCounter)
}

// DeleteComponentBeforeCounter returns a count of GoCloakMock.DeleteComponent invocations
func (mmDeleteComponent *GoCloakMock) DeleteComponentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteComponent.beforeDeleteComponentCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.DeleteComponent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteComponent *mGoCloakMockDeleteComponent) Calls() []*GoCloakMockDeleteComponentParams {
	mmDeleteComponent.mutex.RLock()

	argCopy := make([]*GoCloakMockDeleteComponentParams, len(mmDeleteComponent.callArgs))
	copy(argCopy, mmDeleteComponent.callArgs)

	mmDeleteComponent.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteComponentDone returns true if the count of the DeleteComponent invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockDeleteComponentDone() bool {
	for _, e := range m.DeleteComponentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteComponentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteComponentCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteComponent != nil && mm_atomic.LoadUint64(&m.afterDeleteComponentCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteComponentInspect logs each unmet expectation
func (m *GoCloakMock) MinimockDeleteComponentInspect() {
	for _, e := range m.DeleteComponentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.DeleteComponent with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteComponentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteComponentCounter) < 1 {
		if m.DeleteComponentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.DeleteComponent")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.DeleteComponent with params: %#v", *m.DeleteComponentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteComponent != nil && mm_atomic.LoadUint64(&m.afterDeleteComponentCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.DeleteComponent")
	}
}

type mGoCloakMockDeleteGroup struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockDeleteGroupExpectation
	expectations       []*GoCloakMockDeleteGroupExpectation

	callArgs []*GoCloakMockDeleteGroupParams
	mutex    sync.RWMutex
}

// GoCloakMockDeleteGroupExpectation specifies expectation struct of the GoCloak.DeleteGroup
type GoCloakMockDeleteGroupExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockDeleteGroupParams
	results *GoCloakMockDeleteGroupResults
	Counter uint64
}

// GoCloakMockDeleteGroupParams contains parameters of the GoCloak.DeleteGroup
type GoCloakMockDeleteGroupParams struct {
	accessToken string
	realm       string
	groupID     string
}

// GoCloakMockDeleteGroupResults contains results of the GoCloak.DeleteGroup
type GoCloakMockDeleteGroupResults struct {
	err error
}

// Expect sets up expected params for GoCloak.DeleteGroup
func (mmDeleteGroup *mGoCloakMockDeleteGroup) Expect(accessToken string, realm string, groupID string) *mGoCloakMockDeleteGroup {
	if mmDeleteGroup.mock.funcDeleteGroup != nil {
		mmDeleteGroup.mock.t.Fatalf("GoCloakMock.DeleteGroup mock is already set by Set")
	}

	if mmDeleteGroup.defaultExpectation == nil {
		mmDeleteGroup.defaultExpectation = &GoCloakMockDeleteGroupExpectation{}
	}

	mmDeleteGroup.defaultExpectation.params = &GoCloakMockDeleteGroupParams{accessToken, realm, groupID}
	for _, e := range mmDeleteGroup.expectations {
		if minimock.Equal(e.params, mmDeleteGroup.defaultExpectation.params) {
			mmDeleteGroup.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteGroup.defaultExpectation.params)
		}
	}

	return mmDeleteGroup
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.DeleteGroup
func (mmDeleteGroup *mGoCloakMockDeleteGroup) Inspect(f func(accessToken string, realm string, groupID string)) *mGoCloakMockDeleteGroup {
	if mmDeleteGroup.mock.inspectFuncDeleteGroup != nil {
		mmDeleteGroup.mock.t.Fatalf("Inspect function is already set for GoCloakMock.DeleteGroup")
	}

	mmDeleteGroup.mock.inspectFuncDeleteGroup = f

	return mmDeleteGroup
}

// Return sets up results that will be returned by GoCloak.DeleteGroup
func (mmDeleteGroup *mGoCloakMockDeleteGroup) Return(err error) *GoCloakMock {
	if mmDeleteGroup.mock.funcDeleteGroup != nil {
		mmDeleteGroup.mock.t.Fatalf("GoCloakMock.DeleteGroup mock is already set by Set")
	}

	if mmDeleteGroup.defaultExpectation == nil {
		mmDeleteGroup.defaultExpectation = &GoCloakMockDeleteGroupExpectation{mock: mmDeleteGroup.mock}
	}
	mmDeleteGroup.defaultExpectation.results = &GoCloakMockDeleteGroupResults{err}
	return mmDeleteGroup.mock
}

//Set uses given function f to mock the GoCloak.DeleteGroup method
func (mmDeleteGroup *mGoCloakMockDeleteGroup) Set(f func(accessToken string, realm string, groupID string) (err error)) *GoCloakMock {
	if mmDeleteGroup.defaultExpectation != nil {
		mmDeleteGroup.mock.t.Fatalf("Default expectation is already set for the GoCloak.DeleteGroup method")
	}

	if len(mmDeleteGroup.expectations) > 0 {
		mmDeleteGroup.mock.t.Fatalf("Some expectations are already set for the GoCloak.DeleteGroup method")
	}

	mmDeleteGroup.mock.funcDeleteGroup = f
	return mmDeleteGroup.mock
}

// When sets expectation for the GoCloak.DeleteGroup which will trigger the result defined by the following
// Then helper
func (mmDeleteGroup *mGoCloakMockDeleteGroup) When(accessToken string, realm string, groupID string) *GoCloakMockDeleteGroupExpectation {
	if mmDeleteGroup.mock.funcDeleteGroup != nil {
		mmDeleteGroup.mock.t.Fatalf("GoCloakMock.DeleteGroup mock is already set by Set")
	}

	expectation := &GoCloakMockDeleteGroupExpectation{
		mock:   mmDeleteGroup.mock,
		params: &GoCloakMockDeleteGroupParams{accessToken, realm, groupID},
	}
	mmDeleteGroup.expectations = append(mmDeleteGroup.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.DeleteGroup return parameters for the expectation previously defined by the When method
func (e *GoCloakMockDeleteGroupExpectation) Then(err error) *GoCloakMock {
	e.results = &GoCloakMockDeleteGroupResults{err}
	return e.mock
}

// DeleteGroup implements gocloak.GoCloak
func (mmDeleteGroup *GoCloakMock) DeleteGroup(accessToken string, realm string, groupID string) (err error) {
	mm_atomic.AddUint64(&mmDeleteGroup.beforeDeleteGroupCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteGroup.afterDeleteGroupCounter, 1)

	if mmDeleteGroup.inspectFuncDeleteGroup != nil {
		mmDeleteGroup.inspectFuncDeleteGroup(accessToken, realm, groupID)
	}

	mm_params := &GoCloakMockDeleteGroupParams{accessToken, realm, groupID}

	// Record call args
	mmDeleteGroup.DeleteGroupMock.mutex.Lock()
	mmDeleteGroup.DeleteGroupMock.callArgs = append(mmDeleteGroup.DeleteGroupMock.callArgs, mm_params)
	mmDeleteGroup.DeleteGroupMock.mutex.Unlock()

	for _, e := range mmDeleteGroup.DeleteGroupMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteGroup.DeleteGroupMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteGroup.DeleteGroupMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteGroup.DeleteGroupMock.defaultExpectation.params
		mm_got := GoCloakMockDeleteGroupParams{accessToken, realm, groupID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteGroup.t.Errorf("GoCloakMock.DeleteGroup got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteGroup.DeleteGroupMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteGroup.t.Fatal("No results are set for the GoCloakMock.DeleteGroup")
		}
		return (*mm_results).err
	}
	if mmDeleteGroup.funcDeleteGroup != nil {
		return mmDeleteGroup.funcDeleteGroup(accessToken, realm, groupID)
	}
	mmDeleteGroup.t.Fatalf("Unexpected call to GoCloakMock.DeleteGroup. %v %v %v", accessToken, realm, groupID)
	return
}

// DeleteGroupAfterCounter returns a count of finished GoCloakMock.DeleteGroup invocations
func (mmDeleteGroup *GoCloakMock) DeleteGroupAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteGroup.afterDeleteGroupCounter)
}

// DeleteGroupBeforeCounter returns a count of GoCloakMock.DeleteGroup invocations
func (mmDeleteGroup *GoCloakMock) DeleteGroupBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteGroup.beforeDeleteGroupCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.DeleteGroup.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteGroup *mGoCloakMockDeleteGroup) Calls() []*GoCloakMockDeleteGroupParams {
	mmDeleteGroup.mutex.RLock()

	argCopy := make([]*GoCloakMockDeleteGroupParams, len(mmDeleteGroup.callArgs))
	copy(argCopy, mmDeleteGroup.callArgs)

	mmDeleteGroup.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteGroupDone returns true if the count of the DeleteGroup invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockDeleteGroupDone() bool {
	for _, e := range m.DeleteGroupMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteGroupMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteGroupCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteGroup != nil && mm_atomic.LoadUint64(&m.afterDeleteGroupCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteGroupInspect logs each unmet expectation
func (m *GoCloakMock) MinimockDeleteGroupInspect() {
	for _, e := range m.DeleteGroupMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.DeleteGroup with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteGroupMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteGroupCounter) < 1 {
		if m.DeleteGroupMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.DeleteGroup")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.DeleteGroup with params: %#v", *m.DeleteGroupMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteGroup != nil && mm_atomic.LoadUint64(&m.afterDeleteGroupCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.DeleteGroup")
	}
}

type mGoCloakMockDeleteRole struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockDeleteRoleExpectation
	expectations       []*GoCloakMockDeleteRoleExpectation

	callArgs []*GoCloakMockDeleteRoleParams
	mutex    sync.RWMutex
}

// GoCloakMockDeleteRoleExpectation specifies expectation struct of the GoCloak.DeleteRole
type GoCloakMockDeleteRoleExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockDeleteRoleParams
	results *GoCloakMockDeleteRoleResults
	Counter uint64
}

// GoCloakMockDeleteRoleParams contains parameters of the GoCloak.DeleteRole
type GoCloakMockDeleteRoleParams struct {
	accessToken string
	realm       string
	clientID    string
	roleName    string
}

// GoCloakMockDeleteRoleResults contains results of the GoCloak.DeleteRole
type GoCloakMockDeleteRoleResults struct {
	err error
}

// Expect sets up expected params for GoCloak.DeleteRole
func (mmDeleteRole *mGoCloakMockDeleteRole) Expect(accessToken string, realm string, clientID string, roleName string) *mGoCloakMockDeleteRole {
	if mmDeleteRole.mock.funcDeleteRole != nil {
		mmDeleteRole.mock.t.Fatalf("GoCloakMock.DeleteRole mock is already set by Set")
	}

	if mmDeleteRole.defaultExpectation == nil {
		mmDeleteRole.defaultExpectation = &GoCloakMockDeleteRoleExpectation{}
	}

	mmDeleteRole.defaultExpectation.params = &GoCloakMockDeleteRoleParams{accessToken, realm, clientID, roleName}
	for _, e := range mmDeleteRole.expectations {
		if minimock.Equal(e.params, mmDeleteRole.defaultExpectation.params) {
			mmDeleteRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteRole.defaultExpectation.params)
		}
	}

	return mmDeleteRole
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.DeleteRole
func (mmDeleteRole *mGoCloakMockDeleteRole) Inspect(f func(accessToken string, realm string, clientID string, roleName string)) *mGoCloakMockDeleteRole {
	if mmDeleteRole.mock.inspectFuncDeleteRole != nil {
		mmDeleteRole.mock.t.Fatalf("Inspect function is already set for GoCloakMock.DeleteRole")
	}

	mmDeleteRole.mock.inspectFuncDeleteRole = f

	return mmDeleteRole
}

// Return sets up results that will be returned by GoCloak.DeleteRole
func (mmDeleteRole *mGoCloakMockDeleteRole) Return(err error) *GoCloakMock {
	if mmDeleteRole.mock.funcDeleteRole != nil {
		mmDeleteRole.mock.t.Fatalf("GoCloakMock.DeleteRole mock is already set by Set")
	}

	if mmDeleteRole.defaultExpectation == nil {
		mmDeleteRole.defaultExpectation = &GoCloakMockDeleteRoleExpectation{mock: mmDeleteRole.mock}
	}
	mmDeleteRole.defaultExpectation.results = &GoCloakMockDeleteRoleResults{err}
	return mmDeleteRole.mock
}

//Set uses given function f to mock the GoCloak.DeleteRole method
func (mmDeleteRole *mGoCloakMockDeleteRole) Set(f func(accessToken string, realm string, clientID string, roleName string) (err error)) *GoCloakMock {
	if mmDeleteRole.defaultExpectation != nil {
		mmDeleteRole.mock.t.Fatalf("Default expectation is already set for the GoCloak.DeleteRole method")
	}

	if len(mmDeleteRole.expectations) > 0 {
		mmDeleteRole.mock.t.Fatalf("Some expectations are already set for the GoCloak.DeleteRole method")
	}

	mmDeleteRole.mock.funcDeleteRole = f
	return mmDeleteRole.mock
}

// When sets expectation for the GoCloak.DeleteRole which will trigger the result defined by the following
// Then helper
func (mmDeleteRole *mGoCloakMockDeleteRole) When(accessToken string, realm string, clientID string, roleName string) *GoCloakMockDeleteRoleExpectation {
	if mmDeleteRole.mock.funcDeleteRole != nil {
		mmDeleteRole.mock.t.Fatalf("GoCloakMock.DeleteRole mock is already set by Set")
	}

	expectation := &GoCloakMockDeleteRoleExpectation{
		mock:   mmDeleteRole.mock,
		params: &GoCloakMockDeleteRoleParams{accessToken, realm, clientID, roleName},
	}
	mmDeleteRole.expectations = append(mmDeleteRole.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.DeleteRole return parameters for the expectation previously defined by the When method
func (e *GoCloakMockDeleteRoleExpectation) Then(err error) *GoCloakMock {
	e.results = &GoCloakMockDeleteRoleResults{err}
	return e.mock
}

// DeleteRole implements gocloak.GoCloak
func (mmDeleteRole *GoCloakMock) DeleteRole(accessToken string, realm string, clientID string, roleName string) (err error) {
	mm_atomic.AddUint64(&mmDeleteRole.beforeDeleteRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteRole.afterDeleteRoleCounter, 1)

	if mmDeleteRole.inspectFuncDeleteRole != nil {
		mmDeleteRole.inspectFuncDeleteRole(accessToken, realm, clientID, roleName)
	}

	mm_params := &GoCloakMockDeleteRoleParams{accessToken, realm, clientID, roleName}

	// Record call args
	mmDeleteRole.DeleteRoleMock.mutex.Lock()
	mmDeleteRole.DeleteRoleMock.callArgs = append(mmDeleteRole.DeleteRoleMock.callArgs, mm_params)
	mmDeleteRole.DeleteRoleMock.mutex.Unlock()

	for _, e := range mmDeleteRole.DeleteRoleMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteRole.DeleteRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteRole.DeleteRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteRole.DeleteRoleMock.defaultExpectation.params
		mm_got := GoCloakMockDeleteRoleParams{accessToken, realm, clientID, roleName}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteRole.t.Errorf("GoCloakMock.DeleteRole got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteRole.DeleteRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteRole.t.Fatal("No results are set for the GoCloakMock.DeleteRole")
		}
		return (*mm_results).err
	}
	if mmDeleteRole.funcDeleteRole != nil {
		return mmDeleteRole.funcDeleteRole(accessToken, realm, clientID, roleName)
	}
	mmDeleteRole.t.Fatalf("Unexpected call to GoCloakMock.DeleteRole. %v %v %v %v", accessToken, realm, clientID, roleName)
	return
}

// DeleteRoleAfterCounter returns a count of finished GoCloakMock.DeleteRole invocations
func (mmDeleteRole *GoCloakMock) DeleteRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRole.afterDeleteRoleCounter)
}

// DeleteRoleBeforeCounter returns a count of GoCloakMock.DeleteRole invocations
func (mmDeleteRole *GoCloakMock) DeleteRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRole.beforeDeleteRoleCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.DeleteRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteRole *mGoCloakMockDeleteRole) Calls() []*GoCloakMockDeleteRoleParams {
	mmDeleteRole.mutex.RLock()

	argCopy := make([]*GoCloakMockDeleteRoleParams, len(mmDeleteRole.callArgs))
	copy(argCopy, mmDeleteRole.callArgs)

	mmDeleteRole.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteRoleDone returns true if the count of the DeleteRole invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockDeleteRoleDone() bool {
	for _, e := range m.DeleteRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteRoleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteRoleCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteRole != nil && mm_atomic.LoadUint64(&m.afterDeleteRoleCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteRoleInspect logs each unmet expectation
func (m *GoCloakMock) MinimockDeleteRoleInspect() {
	for _, e := range m.DeleteRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.DeleteRole with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteRoleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteRoleCounter) < 1 {
		if m.DeleteRoleMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.DeleteRole")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.DeleteRole with params: %#v", *m.DeleteRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteRole != nil && mm_atomic.LoadUint64(&m.afterDeleteRoleCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.DeleteRole")
	}
}

type mGoCloakMockDeleteUser struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockDeleteUserExpectation
	expectations       []*GoCloakMockDeleteUserExpectation

	callArgs []*GoCloakMockDeleteUserParams
	mutex    sync.RWMutex
}

// GoCloakMockDeleteUserExpectation specifies expectation struct of the GoCloak.DeleteUser
type GoCloakMockDeleteUserExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockDeleteUserParams
	results *GoCloakMockDeleteUserResults
	Counter uint64
}

// GoCloakMockDeleteUserParams contains parameters of the GoCloak.DeleteUser
type GoCloakMockDeleteUserParams struct {
	accessToken string
	realm       string
	userID      string
}

// GoCloakMockDeleteUserResults contains results of the GoCloak.DeleteUser
type GoCloakMockDeleteUserResults struct {
	err error
}

// Expect sets up expected params for GoCloak.DeleteUser
func (mmDeleteUser *mGoCloakMockDeleteUser) Expect(accessToken string, realm string, userID string) *mGoCloakMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("GoCloakMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &GoCloakMockDeleteUserExpectation{}
	}

	mmDeleteUser.defaultExpectation.params = &GoCloakMockDeleteUserParams{accessToken, realm, userID}
	for _, e := range mmDeleteUser.expectations {
		if minimock.Equal(e.params, mmDeleteUser.defaultExpectation.params) {
			mmDeleteUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUser.defaultExpectation.params)
		}
	}

	return mmDeleteUser
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.DeleteUser
func (mmDeleteUser *mGoCloakMockDeleteUser) Inspect(f func(accessToken string, realm string, userID string)) *mGoCloakMockDeleteUser {
	if mmDeleteUser.mock.inspectFuncDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("Inspect function is already set for GoCloakMock.DeleteUser")
	}

	mmDeleteUser.mock.inspectFuncDeleteUser = f

	return mmDeleteUser
}

// Return sets up results that will be returned by GoCloak.DeleteUser
func (mmDeleteUser *mGoCloakMockDeleteUser) Return(err error) *GoCloakMock {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("GoCloakMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &GoCloakMockDeleteUserExpectation{mock: mmDeleteUser.mock}
	}
	mmDeleteUser.defaultExpectation.results = &GoCloakMockDeleteUserResults{err}
	return mmDeleteUser.mock
}

//Set uses given function f to mock the GoCloak.DeleteUser method
func (mmDeleteUser *mGoCloakMockDeleteUser) Set(f func(accessToken string, realm string, userID string) (err error)) *GoCloakMock {
	if mmDeleteUser.defaultExpectation != nil {
		mmDeleteUser.mock.t.Fatalf("Default expectation is already set for the GoCloak.DeleteUser method")
	}

	if len(mmDeleteUser.expectations) > 0 {
		mmDeleteUser.mock.t.Fatalf("Some expectations are already set for the GoCloak.DeleteUser method")
	}

	mmDeleteUser.mock.funcDeleteUser = f
	return mmDeleteUser.mock
}

// When sets expectation for the GoCloak.DeleteUser which will trigger the result defined by the following
// Then helper
func (mmDeleteUser *mGoCloakMockDeleteUser) When(accessToken string, realm string, userID string) *GoCloakMockDeleteUserExpectation {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("GoCloakMock.DeleteUser mock is already set by Set")
	}

	expectation := &GoCloakMockDeleteUserExpectation{
		mock:   mmDeleteUser.mock,
		params: &GoCloakMockDeleteUserParams{accessToken, realm, userID},
	}
	mmDeleteUser.expectations = append(mmDeleteUser.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.DeleteUser return parameters for the expectation previously defined by the When method
func (e *GoCloakMockDeleteUserExpectation) Then(err error) *GoCloakMock {
	e.results = &GoCloakMockDeleteUserResults{err}
	return e.mock
}

// DeleteUser implements gocloak.GoCloak
func (mmDeleteUser *GoCloakMock) DeleteUser(accessToken string, realm string, userID string) (err error) {
	mm_atomic.AddUint64(&mmDeleteUser.beforeDeleteUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUser.afterDeleteUserCounter, 1)

	if mmDeleteUser.inspectFuncDeleteUser != nil {
		mmDeleteUser.inspectFuncDeleteUser(accessToken, realm, userID)
	}

	mm_params := &GoCloakMockDeleteUserParams{accessToken, realm, userID}

	// Record call args
	mmDeleteUser.DeleteUserMock.mutex.Lock()
	mmDeleteUser.DeleteUserMock.callArgs = append(mmDeleteUser.DeleteUserMock.callArgs, mm_params)
	mmDeleteUser.DeleteUserMock.mutex.Unlock()

	for _, e := range mmDeleteUser.DeleteUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteUser.DeleteUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUser.DeleteUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUser.DeleteUserMock.defaultExpectation.params
		mm_got := GoCloakMockDeleteUserParams{accessToken, realm, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUser.t.Errorf("GoCloakMock.DeleteUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUser.DeleteUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUser.t.Fatal("No results are set for the GoCloakMock.DeleteUser")
		}
		return (*mm_results).err
	}
	if mmDeleteUser.funcDeleteUser != nil {
		return mmDeleteUser.funcDeleteUser(accessToken, realm, userID)
	}
	mmDeleteUser.t.Fatalf("Unexpected call to GoCloakMock.DeleteUser. %v %v %v", accessToken, realm, userID)
	return
}

// DeleteUserAfterCounter returns a count of finished GoCloakMock.DeleteUser invocations
func (mmDeleteUser *GoCloakMock) DeleteUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.afterDeleteUserCounter)
}

// DeleteUserBeforeCounter returns a count of GoCloakMock.DeleteUser invocations
func (mmDeleteUser *GoCloakMock) DeleteUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.beforeDeleteUserCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.DeleteUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUser *mGoCloakMockDeleteUser) Calls() []*GoCloakMockDeleteUserParams {
	mmDeleteUser.mutex.RLock()

	argCopy := make([]*GoCloakMockDeleteUserParams, len(mmDeleteUser.callArgs))
	copy(argCopy, mmDeleteUser.callArgs)

	mmDeleteUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserDone returns true if the count of the DeleteUser invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockDeleteUserDone() bool {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && mm_atomic.LoadUint64(&m.afterDeleteUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteUserInspect logs each unmet expectation
func (m *GoCloakMock) MinimockDeleteUserInspect() {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.DeleteUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteUserCounter) < 1 {
		if m.DeleteUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.DeleteUser")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.DeleteUser with params: %#v", *m.DeleteUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && mm_atomic.LoadUint64(&m.afterDeleteUserCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.DeleteUser")
	}
}

type mGoCloakMockGetCerts struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockGetCertsExpectation
	expectations       []*GoCloakMockGetCertsExpectation

	callArgs []*GoCloakMockGetCertsParams
	mutex    sync.RWMutex
}

// GoCloakMockGetCertsExpectation specifies expectation struct of the GoCloak.GetCerts
type GoCloakMockGetCertsExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockGetCertsParams
	results *GoCloakMockGetCertsResults
	Counter uint64
}

// GoCloakMockGetCertsParams contains parameters of the GoCloak.GetCerts
type GoCloakMockGetCertsParams struct {
	realm string
}

// GoCloakMockGetCertsResults contains results of the GoCloak.GetCerts
type GoCloakMockGetCertsResults struct {
	cp1 *mm_gocloak.CertResponse
	err error
}

// Expect sets up expected params for GoCloak.GetCerts
func (mmGetCerts *mGoCloakMockGetCerts) Expect(realm string) *mGoCloakMockGetCerts {
	if mmGetCerts.mock.funcGetCerts != nil {
		mmGetCerts.mock.t.Fatalf("GoCloakMock.GetCerts mock is already set by Set")
	}

	if mmGetCerts.defaultExpectation == nil {
		mmGetCerts.defaultExpectation = &GoCloakMockGetCertsExpectation{}
	}

	mmGetCerts.defaultExpectation.params = &GoCloakMockGetCertsParams{realm}
	for _, e := range mmGetCerts.expectations {
		if minimock.Equal(e.params, mmGetCerts.defaultExpectation.params) {
			mmGetCerts.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCerts.defaultExpectation.params)
		}
	}

	return mmGetCerts
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.GetCerts
func (mmGetCerts *mGoCloakMockGetCerts) Inspect(f func(realm string)) *mGoCloakMockGetCerts {
	if mmGetCerts.mock.inspectFuncGetCerts != nil {
		mmGetCerts.mock.t.Fatalf("Inspect function is already set for GoCloakMock.GetCerts")
	}

	mmGetCerts.mock.inspectFuncGetCerts = f

	return mmGetCerts
}

// Return sets up results that will be returned by GoCloak.GetCerts
func (mmGetCerts *mGoCloakMockGetCerts) Return(cp1 *mm_gocloak.CertResponse, err error) *GoCloakMock {
	if mmGetCerts.mock.funcGetCerts != nil {
		mmGetCerts.mock.t.Fatalf("GoCloakMock.GetCerts mock is already set by Set")
	}

	if mmGetCerts.defaultExpectation == nil {
		mmGetCerts.defaultExpectation = &GoCloakMockGetCertsExpectation{mock: mmGetCerts.mock}
	}
	mmGetCerts.defaultExpectation.results = &GoCloakMockGetCertsResults{cp1, err}
	return mmGetCerts.mock
}

//Set uses given function f to mock the GoCloak.GetCerts method
func (mmGetCerts *mGoCloakMockGetCerts) Set(f func(realm string) (cp1 *mm_gocloak.CertResponse, err error)) *GoCloakMock {
	if mmGetCerts.defaultExpectation != nil {
		mmGetCerts.mock.t.Fatalf("Default expectation is already set for the GoCloak.GetCerts method")
	}

	if len(mmGetCerts.expectations) > 0 {
		mmGetCerts.mock.t.Fatalf("Some expectations are already set for the GoCloak.GetCerts method")
	}

	mmGetCerts.mock.funcGetCerts = f
	return mmGetCerts.mock
}

// When sets expectation for the GoCloak.GetCerts which will trigger the result defined by the following
// Then helper
func (mmGetCerts *mGoCloakMockGetCerts) When(realm string) *GoCloakMockGetCertsExpectation {
	if mmGetCerts.mock.funcGetCerts != nil {
		mmGetCerts.mock.t.Fatalf("GoCloakMock.GetCerts mock is already set by Set")
	}

	expectation := &GoCloakMockGetCertsExpectation{
		mock:   mmGetCerts.mock,
		params: &GoCloakMockGetCertsParams{realm},
	}
	mmGetCerts.expectations = append(mmGetCerts.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.GetCerts return parameters for the expectation previously defined by the When method
func (e *GoCloakMockGetCertsExpectation) Then(cp1 *mm_gocloak.CertResponse, err error) *GoCloakMock {
	e.results = &GoCloakMockGetCertsResults{cp1, err}
	return e.mock
}

// GetCerts implements gocloak.GoCloak
func (mmGetCerts *GoCloakMock) GetCerts(realm string) (cp1 *mm_gocloak.CertResponse, err error) {
	mm_atomic.AddUint64(&mmGetCerts.beforeGetCertsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCerts.afterGetCertsCounter, 1)

	if mmGetCerts.inspectFuncGetCerts != nil {
		mmGetCerts.inspectFuncGetCerts(realm)
	}

	mm_params := &GoCloakMockGetCertsParams{realm}

	// Record call args
	mmGetCerts.GetCertsMock.mutex.Lock()
	mmGetCerts.GetCertsMock.callArgs = append(mmGetCerts.GetCertsMock.callArgs, mm_params)
	mmGetCerts.GetCertsMock.mutex.Unlock()

	for _, e := range mmGetCerts.GetCertsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetCerts.GetCertsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCerts.GetCertsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCerts.GetCertsMock.defaultExpectation.params
		mm_got := GoCloakMockGetCertsParams{realm}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCerts.t.Errorf("GoCloakMock.GetCerts got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCerts.GetCertsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCerts.t.Fatal("No results are set for the GoCloakMock.GetCerts")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetCerts.funcGetCerts != nil {
		return mmGetCerts.funcGetCerts(realm)
	}
	mmGetCerts.t.Fatalf("Unexpected call to GoCloakMock.GetCerts. %v", realm)
	return
}

// GetCertsAfterCounter returns a count of finished GoCloakMock.GetCerts invocations
func (mmGetCerts *GoCloakMock) GetCertsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCerts.afterGetCertsCounter)
}

// GetCertsBeforeCounter returns a count of GoCloakMock.GetCerts invocations
func (mmGetCerts *GoCloakMock) GetCertsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCerts.beforeGetCertsCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.GetCerts.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCerts *mGoCloakMockGetCerts) Calls() []*GoCloakMockGetCertsParams {
	mmGetCerts.mutex.RLock()

	argCopy := make([]*GoCloakMockGetCertsParams, len(mmGetCerts.callArgs))
	copy(argCopy, mmGetCerts.callArgs)

	mmGetCerts.mutex.RUnlock()

	return argCopy
}

// MinimockGetCertsDone returns true if the count of the GetCerts invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockGetCertsDone() bool {
	for _, e := range m.GetCertsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCertsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCertsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCerts != nil && mm_atomic.LoadUint64(&m.afterGetCertsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCertsInspect logs each unmet expectation
func (m *GoCloakMock) MinimockGetCertsInspect() {
	for _, e := range m.GetCertsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.GetCerts with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCertsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCertsCounter) < 1 {
		if m.GetCertsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.GetCerts")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.GetCerts with params: %#v", *m.GetCertsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCerts != nil && mm_atomic.LoadUint64(&m.afterGetCertsCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.GetCerts")
	}
}

type mGoCloakMockGetClients struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockGetClientsExpectation
	expectations       []*GoCloakMockGetClientsExpectation

	callArgs []*GoCloakMockGetClientsParams
	mutex    sync.RWMutex
}

// GoCloakMockGetClientsExpectation specifies expectation struct of the GoCloak.GetClients
type GoCloakMockGetClientsExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockGetClientsParams
	results *GoCloakMockGetClientsResults
	Counter uint64
}

// GoCloakMockGetClientsParams contains parameters of the GoCloak.GetClients
type GoCloakMockGetClientsParams struct {
	accessToken string
	realm       string
}

// GoCloakMockGetClientsResults contains results of the GoCloak.GetClients
type GoCloakMockGetClientsResults struct {
	cap1 *[]mm_gocloak.Client
	err  error
}

// Expect sets up expected params for GoCloak.GetClients
func (mmGetClients *mGoCloakMockGetClients) Expect(accessToken string, realm string) *mGoCloakMockGetClients {
	if mmGetClients.mock.funcGetClients != nil {
		mmGetClients.mock.t.Fatalf("GoCloakMock.GetClients mock is already set by Set")
	}

	if mmGetClients.defaultExpectation == nil {
		mmGetClients.defaultExpectation = &GoCloakMockGetClientsExpectation{}
	}

	mmGetClients.defaultExpectation.params = &GoCloakMockGetClientsParams{accessToken, realm}
	for _, e := range mmGetClients.expectations {
		if minimock.Equal(e.params, mmGetClients.defaultExpectation.params) {
			mmGetClients.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetClients.defaultExpectation.params)
		}
	}

	return mmGetClients
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.GetClients
func (mmGetClients *mGoCloakMockGetClients) Inspect(f func(accessToken string, realm string)) *mGoCloakMockGetClients {
	if mmGetClients.mock.inspectFuncGetClients != nil {
		mmGetClients.mock.t.Fatalf("Inspect function is already set for GoCloakMock.GetClients")
	}

	mmGetClients.mock.inspectFuncGetClients = f

	return mmGetClients
}

// Return sets up results that will be returned by GoCloak.GetClients
func (mmGetClients *mGoCloakMockGetClients) Return(cap1 *[]mm_gocloak.Client, err error) *GoCloakMock {
	if mmGetClients.mock.funcGetClients != nil {
		mmGetClients.mock.t.Fatalf("GoCloakMock.GetClients mock is already set by Set")
	}

	if mmGetClients.defaultExpectation == nil {
		mmGetClients.defaultExpectation = &GoCloakMockGetClientsExpectation{mock: mmGetClients.mock}
	}
	mmGetClients.defaultExpectation.results = &GoCloakMockGetClientsResults{cap1, err}
	return mmGetClients.mock
}

//Set uses given function f to mock the GoCloak.GetClients method
func (mmGetClients *mGoCloakMockGetClients) Set(f func(accessToken string, realm string) (cap1 *[]mm_gocloak.Client, err error)) *GoCloakMock {
	if mmGetClients.defaultExpectation != nil {
		mmGetClients.mock.t.Fatalf("Default expectation is already set for the GoCloak.GetClients method")
	}

	if len(mmGetClients.expectations) > 0 {
		mmGetClients.mock.t.Fatalf("Some expectations are already set for the GoCloak.GetClients method")
	}

	mmGetClients.mock.funcGetClients = f
	return mmGetClients.mock
}

// When sets expectation for the GoCloak.GetClients which will trigger the result defined by the following
// Then helper
func (mmGetClients *mGoCloakMockGetClients) When(accessToken string, realm string) *GoCloakMockGetClientsExpectation {
	if mmGetClients.mock.funcGetClients != nil {
		mmGetClients.mock.t.Fatalf("GoCloakMock.GetClients mock is already set by Set")
	}

	expectation := &GoCloakMockGetClientsExpectation{
		mock:   mmGetClients.mock,
		params: &GoCloakMockGetClientsParams{accessToken, realm},
	}
	mmGetClients.expectations = append(mmGetClients.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.GetClients return parameters for the expectation previously defined by the When method
func (e *GoCloakMockGetClientsExpectation) Then(cap1 *[]mm_gocloak.Client, err error) *GoCloakMock {
	e.results = &GoCloakMockGetClientsResults{cap1, err}
	return e.mock
}

// GetClients implements gocloak.GoCloak
func (mmGetClients *GoCloakMock) GetClients(accessToken string, realm string) (cap1 *[]mm_gocloak.Client, err error) {
	mm_atomic.AddUint64(&mmGetClients.beforeGetClientsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetClients.afterGetClientsCounter, 1)

	if mmGetClients.inspectFuncGetClients != nil {
		mmGetClients.inspectFuncGetClients(accessToken, realm)
	}

	mm_params := &GoCloakMockGetClientsParams{accessToken, realm}

	// Record call args
	mmGetClients.GetClientsMock.mutex.Lock()
	mmGetClients.GetClientsMock.callArgs = append(mmGetClients.GetClientsMock.callArgs, mm_params)
	mmGetClients.GetClientsMock.mutex.Unlock()

	for _, e := range mmGetClients.GetClientsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cap1, e.results.err
		}
	}

	if mmGetClients.GetClientsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetClients.GetClientsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetClients.GetClientsMock.defaultExpectation.params
		mm_got := GoCloakMockGetClientsParams{accessToken, realm}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetClients.t.Errorf("GoCloakMock.GetClients got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetClients.GetClientsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetClients.t.Fatal("No results are set for the GoCloakMock.GetClients")
		}
		return (*mm_results).cap1, (*mm_results).err
	}
	if mmGetClients.funcGetClients != nil {
		return mmGetClients.funcGetClients(accessToken, realm)
	}
	mmGetClients.t.Fatalf("Unexpected call to GoCloakMock.GetClients. %v %v", accessToken, realm)
	return
}

// GetClientsAfterCounter returns a count of finished GoCloakMock.GetClients invocations
func (mmGetClients *GoCloakMock) GetClientsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetClients.afterGetClientsCounter)
}

// GetClientsBeforeCounter returns a count of GoCloakMock.GetClients invocations
func (mmGetClients *GoCloakMock) GetClientsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetClients.beforeGetClientsCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.GetClients.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetClients *mGoCloakMockGetClients) Calls() []*GoCloakMockGetClientsParams {
	mmGetClients.mutex.RLock()

	argCopy := make([]*GoCloakMockGetClientsParams, len(mmGetClients.callArgs))
	copy(argCopy, mmGetClients.callArgs)

	mmGetClients.mutex.RUnlock()

	return argCopy
}

// MinimockGetClientsDone returns true if the count of the GetClients invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockGetClientsDone() bool {
	for _, e := range m.GetClientsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetClientsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetClientsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetClients != nil && mm_atomic.LoadUint64(&m.afterGetClientsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetClientsInspect logs each unmet expectation
func (m *GoCloakMock) MinimockGetClientsInspect() {
	for _, e := range m.GetClientsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.GetClients with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetClientsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetClientsCounter) < 1 {
		if m.GetClientsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.GetClients")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.GetClients with params: %#v", *m.GetClientsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetClients != nil && mm_atomic.LoadUint64(&m.afterGetClientsCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.GetClients")
	}
}

type mGoCloakMockGetComponents struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockGetComponentsExpectation
	expectations       []*GoCloakMockGetComponentsExpectation

	callArgs []*GoCloakMockGetComponentsParams
	mutex    sync.RWMutex
}

// GoCloakMockGetComponentsExpectation specifies expectation struct of the GoCloak.GetComponents
type GoCloakMockGetComponentsExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockGetComponentsParams
	results *GoCloakMockGetComponentsResults
	Counter uint64
}

// GoCloakMockGetComponentsParams contains parameters of the GoCloak.GetComponents
type GoCloakMockGetComponentsParams struct {
	accessToken string
	realm       string
}

// GoCloakMockGetComponentsResults contains results of the GoCloak.GetComponents
type GoCloakMockGetComponentsResults struct {
	cap1 *[]mm_gocloak.Component
	err  error
}

// Expect sets up expected params for GoCloak.GetComponents
func (mmGetComponents *mGoCloakMockGetComponents) Expect(accessToken string, realm string) *mGoCloakMockGetComponents {
	if mmGetComponents.mock.funcGetComponents != nil {
		mmGetComponents.mock.t.Fatalf("GoCloakMock.GetComponents mock is already set by Set")
	}

	if mmGetComponents.defaultExpectation == nil {
		mmGetComponents.defaultExpectation = &GoCloakMockGetComponentsExpectation{}
	}

	mmGetComponents.defaultExpectation.params = &GoCloakMockGetComponentsParams{accessToken, realm}
	for _, e := range mmGetComponents.expectations {
		if minimock.Equal(e.params, mmGetComponents.defaultExpectation.params) {
			mmGetComponents.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetComponents.defaultExpectation.params)
		}
	}

	return mmGetComponents
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.GetComponents
func (mmGetComponents *mGoCloakMockGetComponents) Inspect(f func(accessToken string, realm string)) *mGoCloakMockGetComponents {
	if mmGetComponents.mock.inspectFuncGetComponents != nil {
		mmGetComponents.mock.t.Fatalf("Inspect function is already set for GoCloakMock.GetComponents")
	}

	mmGetComponents.mock.inspectFuncGetComponents = f

	return mmGetComponents
}

// Return sets up results that will be returned by GoCloak.GetComponents
func (mmGetComponents *mGoCloakMockGetComponents) Return(cap1 *[]mm_gocloak.Component, err error) *GoCloakMock {
	if mmGetComponents.mock.funcGetComponents != nil {
		mmGetComponents.mock.t.Fatalf("GoCloakMock.GetComponents mock is already set by Set")
	}

	if mmGetComponents.defaultExpectation == nil {
		mmGetComponents.defaultExpectation = &GoCloakMockGetComponentsExpectation{mock: mmGetComponents.mock}
	}
	mmGetComponents.defaultExpectation.results = &GoCloakMockGetComponentsResults{cap1, err}
	return mmGetComponents.mock
}

//Set uses given function f to mock the GoCloak.GetComponents method
func (mmGetComponents *mGoCloakMockGetComponents) Set(f func(accessToken string, realm string) (cap1 *[]mm_gocloak.Component, err error)) *GoCloakMock {
	if mmGetComponents.defaultExpectation != nil {
		mmGetComponents.mock.t.Fatalf("Default expectation is already set for the GoCloak.GetComponents method")
	}

	if len(mmGetComponents.expectations) > 0 {
		mmGetComponents.mock.t.Fatalf("Some expectations are already set for the GoCloak.GetComponents method")
	}

	mmGetComponents.mock.funcGetComponents = f
	return mmGetComponents.mock
}

// When sets expectation for the GoCloak.GetComponents which will trigger the result defined by the following
// Then helper
func (mmGetComponents *mGoCloakMockGetComponents) When(accessToken string, realm string) *GoCloakMockGetComponentsExpectation {
	if mmGetComponents.mock.funcGetComponents != nil {
		mmGetComponents.mock.t.Fatalf("GoCloakMock.GetComponents mock is already set by Set")
	}

	expectation := &GoCloakMockGetComponentsExpectation{
		mock:   mmGetComponents.mock,
		params: &GoCloakMockGetComponentsParams{accessToken, realm},
	}
	mmGetComponents.expectations = append(mmGetComponents.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.GetComponents return parameters for the expectation previously defined by the When method
func (e *GoCloakMockGetComponentsExpectation) Then(cap1 *[]mm_gocloak.Component, err error) *GoCloakMock {
	e.results = &GoCloakMockGetComponentsResults{cap1, err}
	return e.mock
}

// GetComponents implements gocloak.GoCloak
func (mmGetComponents *GoCloakMock) GetComponents(accessToken string, realm string) (cap1 *[]mm_gocloak.Component, err error) {
	mm_atomic.AddUint64(&mmGetComponents.beforeGetComponentsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetComponents.afterGetComponentsCounter, 1)

	if mmGetComponents.inspectFuncGetComponents != nil {
		mmGetComponents.inspectFuncGetComponents(accessToken, realm)
	}

	mm_params := &GoCloakMockGetComponentsParams{accessToken, realm}

	// Record call args
	mmGetComponents.GetComponentsMock.mutex.Lock()
	mmGetComponents.GetComponentsMock.callArgs = append(mmGetComponents.GetComponentsMock.callArgs, mm_params)
	mmGetComponents.GetComponentsMock.mutex.Unlock()

	for _, e := range mmGetComponents.GetComponentsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cap1, e.results.err
		}
	}

	if mmGetComponents.GetComponentsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetComponents.GetComponentsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetComponents.GetComponentsMock.defaultExpectation.params
		mm_got := GoCloakMockGetComponentsParams{accessToken, realm}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetComponents.t.Errorf("GoCloakMock.GetComponents got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetComponents.GetComponentsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetComponents.t.Fatal("No results are set for the GoCloakMock.GetComponents")
		}
		return (*mm_results).cap1, (*mm_results).err
	}
	if mmGetComponents.funcGetComponents != nil {
		return mmGetComponents.funcGetComponents(accessToken, realm)
	}
	mmGetComponents.t.Fatalf("Unexpected call to GoCloakMock.GetComponents. %v %v", accessToken, realm)
	return
}

// GetComponentsAfterCounter returns a count of finished GoCloakMock.GetComponents invocations
func (mmGetComponents *GoCloakMock) GetComponentsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetComponents.afterGetComponentsCounter)
}

// GetComponentsBeforeCounter returns a count of GoCloakMock.GetComponents invocations
func (mmGetComponents *GoCloakMock) GetComponentsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetComponents.beforeGetComponentsCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.GetComponents.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetComponents *mGoCloakMockGetComponents) Calls() []*GoCloakMockGetComponentsParams {
	mmGetComponents.mutex.RLock()

	argCopy := make([]*GoCloakMockGetComponentsParams, len(mmGetComponents.callArgs))
	copy(argCopy, mmGetComponents.callArgs)

	mmGetComponents.mutex.RUnlock()

	return argCopy
}

// MinimockGetComponentsDone returns true if the count of the GetComponents invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockGetComponentsDone() bool {
	for _, e := range m.GetComponentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetComponentsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetComponentsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetComponents != nil && mm_atomic.LoadUint64(&m.afterGetComponentsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetComponentsInspect logs each unmet expectation
func (m *GoCloakMock) MinimockGetComponentsInspect() {
	for _, e := range m.GetComponentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.GetComponents with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetComponentsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetComponentsCounter) < 1 {
		if m.GetComponentsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.GetComponents")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.GetComponents with params: %#v", *m.GetComponentsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetComponents != nil && mm_atomic.LoadUint64(&m.afterGetComponentsCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.GetComponents")
	}
}

type mGoCloakMockGetGroup struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockGetGroupExpectation
	expectations       []*GoCloakMockGetGroupExpectation

	callArgs []*GoCloakMockGetGroupParams
	mutex    sync.RWMutex
}

// GoCloakMockGetGroupExpectation specifies expectation struct of the GoCloak.GetGroup
type GoCloakMockGetGroupExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockGetGroupParams
	results *GoCloakMockGetGroupResults
	Counter uint64
}

// GoCloakMockGetGroupParams contains parameters of the GoCloak.GetGroup
type GoCloakMockGetGroupParams struct {
	accessToken string
	realm       string
	groupID     string
}

// GoCloakMockGetGroupResults contains results of the GoCloak.GetGroup
type GoCloakMockGetGroupResults struct {
	gp1 *mm_gocloak.Group
	err error
}

// Expect sets up expected params for GoCloak.GetGroup
func (mmGetGroup *mGoCloakMockGetGroup) Expect(accessToken string, realm string, groupID string) *mGoCloakMockGetGroup {
	if mmGetGroup.mock.funcGetGroup != nil {
		mmGetGroup.mock.t.Fatalf("GoCloakMock.GetGroup mock is already set by Set")
	}

	if mmGetGroup.defaultExpectation == nil {
		mmGetGroup.defaultExpectation = &GoCloakMockGetGroupExpectation{}
	}

	mmGetGroup.defaultExpectation.params = &GoCloakMockGetGroupParams{accessToken, realm, groupID}
	for _, e := range mmGetGroup.expectations {
		if minimock.Equal(e.params, mmGetGroup.defaultExpectation.params) {
			mmGetGroup.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetGroup.defaultExpectation.params)
		}
	}

	return mmGetGroup
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.GetGroup
func (mmGetGroup *mGoCloakMockGetGroup) Inspect(f func(accessToken string, realm string, groupID string)) *mGoCloakMockGetGroup {
	if mmGetGroup.mock.inspectFuncGetGroup != nil {
		mmGetGroup.mock.t.Fatalf("Inspect function is already set for GoCloakMock.GetGroup")
	}

	mmGetGroup.mock.inspectFuncGetGroup = f

	return mmGetGroup
}

// Return sets up results that will be returned by GoCloak.GetGroup
func (mmGetGroup *mGoCloakMockGetGroup) Return(gp1 *mm_gocloak.Group, err error) *GoCloakMock {
	if mmGetGroup.mock.funcGetGroup != nil {
		mmGetGroup.mock.t.Fatalf("GoCloakMock.GetGroup mock is already set by Set")
	}

	if mmGetGroup.defaultExpectation == nil {
		mmGetGroup.defaultExpectation = &GoCloakMockGetGroupExpectation{mock: mmGetGroup.mock}
	}
	mmGetGroup.defaultExpectation.results = &GoCloakMockGetGroupResults{gp1, err}
	return mmGetGroup.mock
}

//Set uses given function f to mock the GoCloak.GetGroup method
func (mmGetGroup *mGoCloakMockGetGroup) Set(f func(accessToken string, realm string, groupID string) (gp1 *mm_gocloak.Group, err error)) *GoCloakMock {
	if mmGetGroup.defaultExpectation != nil {
		mmGetGroup.mock.t.Fatalf("Default expectation is already set for the GoCloak.GetGroup method")
	}

	if len(mmGetGroup.expectations) > 0 {
		mmGetGroup.mock.t.Fatalf("Some expectations are already set for the GoCloak.GetGroup method")
	}

	mmGetGroup.mock.funcGetGroup = f
	return mmGetGroup.mock
}

// When sets expectation for the GoCloak.GetGroup which will trigger the result defined by the following
// Then helper
func (mmGetGroup *mGoCloakMockGetGroup) When(accessToken string, realm string, groupID string) *GoCloakMockGetGroupExpectation {
	if mmGetGroup.mock.funcGetGroup != nil {
		mmGetGroup.mock.t.Fatalf("GoCloakMock.GetGroup mock is already set by Set")
	}

	expectation := &GoCloakMockGetGroupExpectation{
		mock:   mmGetGroup.mock,
		params: &GoCloakMockGetGroupParams{accessToken, realm, groupID},
	}
	mmGetGroup.expectations = append(mmGetGroup.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.GetGroup return parameters for the expectation previously defined by the When method
func (e *GoCloakMockGetGroupExpectation) Then(gp1 *mm_gocloak.Group, err error) *GoCloakMock {
	e.results = &GoCloakMockGetGroupResults{gp1, err}
	return e.mock
}

// GetGroup implements gocloak.GoCloak
func (mmGetGroup *GoCloakMock) GetGroup(accessToken string, realm string, groupID string) (gp1 *mm_gocloak.Group, err error) {
	mm_atomic.AddUint64(&mmGetGroup.beforeGetGroupCounter, 1)
	defer mm_atomic.AddUint64(&mmGetGroup.afterGetGroupCounter, 1)

	if mmGetGroup.inspectFuncGetGroup != nil {
		mmGetGroup.inspectFuncGetGroup(accessToken, realm, groupID)
	}

	mm_params := &GoCloakMockGetGroupParams{accessToken, realm, groupID}

	// Record call args
	mmGetGroup.GetGroupMock.mutex.Lock()
	mmGetGroup.GetGroupMock.callArgs = append(mmGetGroup.GetGroupMock.callArgs, mm_params)
	mmGetGroup.GetGroupMock.mutex.Unlock()

	for _, e := range mmGetGroup.GetGroupMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetGroup.GetGroupMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetGroup.GetGroupMock.defaultExpectation.Counter, 1)
		mm_want := mmGetGroup.GetGroupMock.defaultExpectation.params
		mm_got := GoCloakMockGetGroupParams{accessToken, realm, groupID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetGroup.t.Errorf("GoCloakMock.GetGroup got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetGroup.GetGroupMock.defaultExpectation.results
		if mm_results == nil {
			mmGetGroup.t.Fatal("No results are set for the GoCloakMock.GetGroup")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetGroup.funcGetGroup != nil {
		return mmGetGroup.funcGetGroup(accessToken, realm, groupID)
	}
	mmGetGroup.t.Fatalf("Unexpected call to GoCloakMock.GetGroup. %v %v %v", accessToken, realm, groupID)
	return
}

// GetGroupAfterCounter returns a count of finished GoCloakMock.GetGroup invocations
func (mmGetGroup *GoCloakMock) GetGroupAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetGroup.afterGetGroupCounter)
}

// GetGroupBeforeCounter returns a count of GoCloakMock.GetGroup invocations
func (mmGetGroup *GoCloakMock) GetGroupBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetGroup.beforeGetGroupCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.GetGroup.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetGroup *mGoCloakMockGetGroup) Calls() []*GoCloakMockGetGroupParams {
	mmGetGroup.mutex.RLock()

	argCopy := make([]*GoCloakMockGetGroupParams, len(mmGetGroup.callArgs))
	copy(argCopy, mmGetGroup.callArgs)

	mmGetGroup.mutex.RUnlock()

	return argCopy
}

// MinimockGetGroupDone returns true if the count of the GetGroup invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockGetGroupDone() bool {
	for _, e := range m.GetGroupMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetGroupMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetGroupCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetGroup != nil && mm_atomic.LoadUint64(&m.afterGetGroupCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetGroupInspect logs each unmet expectation
func (m *GoCloakMock) MinimockGetGroupInspect() {
	for _, e := range m.GetGroupMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.GetGroup with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetGroupMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetGroupCounter) < 1 {
		if m.GetGroupMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.GetGroup")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.GetGroup with params: %#v", *m.GetGroupMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetGroup != nil && mm_atomic.LoadUint64(&m.afterGetGroupCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.GetGroup")
	}
}

type mGoCloakMockGetGroups struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockGetGroupsExpectation
	expectations       []*GoCloakMockGetGroupsExpectation

	callArgs []*GoCloakMockGetGroupsParams
	mutex    sync.RWMutex
}

// GoCloakMockGetGroupsExpectation specifies expectation struct of the GoCloak.GetGroups
type GoCloakMockGetGroupsExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockGetGroupsParams
	results *GoCloakMockGetGroupsResults
	Counter uint64
}

// GoCloakMockGetGroupsParams contains parameters of the GoCloak.GetGroups
type GoCloakMockGetGroupsParams struct {
	accessToken string
	realm       string
}

// GoCloakMockGetGroupsResults contains results of the GoCloak.GetGroups
type GoCloakMockGetGroupsResults struct {
	gap1 *[]mm_gocloak.Group
	err  error
}

// Expect sets up expected params for GoCloak.GetGroups
func (mmGetGroups *mGoCloakMockGetGroups) Expect(accessToken string, realm string) *mGoCloakMockGetGroups {
	if mmGetGroups.mock.funcGetGroups != nil {
		mmGetGroups.mock.t.Fatalf("GoCloakMock.GetGroups mock is already set by Set")
	}

	if mmGetGroups.defaultExpectation == nil {
		mmGetGroups.defaultExpectation = &GoCloakMockGetGroupsExpectation{}
	}

	mmGetGroups.defaultExpectation.params = &GoCloakMockGetGroupsParams{accessToken, realm}
	for _, e := range mmGetGroups.expectations {
		if minimock.Equal(e.params, mmGetGroups.defaultExpectation.params) {
			mmGetGroups.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetGroups.defaultExpectation.params)
		}
	}

	return mmGetGroups
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.GetGroups
func (mmGetGroups *mGoCloakMockGetGroups) Inspect(f func(accessToken string, realm string)) *mGoCloakMockGetGroups {
	if mmGetGroups.mock.inspectFuncGetGroups != nil {
		mmGetGroups.mock.t.Fatalf("Inspect function is already set for GoCloakMock.GetGroups")
	}

	mmGetGroups.mock.inspectFuncGetGroups = f

	return mmGetGroups
}

// Return sets up results that will be returned by GoCloak.GetGroups
func (mmGetGroups *mGoCloakMockGetGroups) Return(gap1 *[]mm_gocloak.Group, err error) *GoCloakMock {
	if mmGetGroups.mock.funcGetGroups != nil {
		mmGetGroups.mock.t.Fatalf("GoCloakMock.GetGroups mock is already set by Set")
	}

	if mmGetGroups.defaultExpectation == nil {
		mmGetGroups.defaultExpectation = &GoCloakMockGetGroupsExpectation{mock: mmGetGroups.mock}
	}
	mmGetGroups.defaultExpectation.results = &GoCloakMockGetGroupsResults{gap1, err}
	return mmGetGroups.mock
}

//Set uses given function f to mock the GoCloak.GetGroups method
func (mmGetGroups *mGoCloakMockGetGroups) Set(f func(accessToken string, realm string) (gap1 *[]mm_gocloak.Group, err error)) *GoCloakMock {
	if mmGetGroups.defaultExpectation != nil {
		mmGetGroups.mock.t.Fatalf("Default expectation is already set for the GoCloak.GetGroups method")
	}

	if len(mmGetGroups.expectations) > 0 {
		mmGetGroups.mock.t.Fatalf("Some expectations are already set for the GoCloak.GetGroups method")
	}

	mmGetGroups.mock.funcGetGroups = f
	return mmGetGroups.mock
}

// When sets expectation for the GoCloak.GetGroups which will trigger the result defined by the following
// Then helper
func (mmGetGroups *mGoCloakMockGetGroups) When(accessToken string, realm string) *GoCloakMockGetGroupsExpectation {
	if mmGetGroups.mock.funcGetGroups != nil {
		mmGetGroups.mock.t.Fatalf("GoCloakMock.GetGroups mock is already set by Set")
	}

	expectation := &GoCloakMockGetGroupsExpectation{
		mock:   mmGetGroups.mock,
		params: &GoCloakMockGetGroupsParams{accessToken, realm},
	}
	mmGetGroups.expectations = append(mmGetGroups.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.GetGroups return parameters for the expectation previously defined by the When method
func (e *GoCloakMockGetGroupsExpectation) Then(gap1 *[]mm_gocloak.Group, err error) *GoCloakMock {
	e.results = &GoCloakMockGetGroupsResults{gap1, err}
	return e.mock
}

// GetGroups implements gocloak.GoCloak
func (mmGetGroups *GoCloakMock) GetGroups(accessToken string, realm string) (gap1 *[]mm_gocloak.Group, err error) {
	mm_atomic.AddUint64(&mmGetGroups.beforeGetGroupsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetGroups.afterGetGroupsCounter, 1)

	if mmGetGroups.inspectFuncGetGroups != nil {
		mmGetGroups.inspectFuncGetGroups(accessToken, realm)
	}

	mm_params := &GoCloakMockGetGroupsParams{accessToken, realm}

	// Record call args
	mmGetGroups.GetGroupsMock.mutex.Lock()
	mmGetGroups.GetGroupsMock.callArgs = append(mmGetGroups.GetGroupsMock.callArgs, mm_params)
	mmGetGroups.GetGroupsMock.mutex.Unlock()

	for _, e := range mmGetGroups.GetGroupsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gap1, e.results.err
		}
	}

	if mmGetGroups.GetGroupsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetGroups.GetGroupsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetGroups.GetGroupsMock.defaultExpectation.params
		mm_got := GoCloakMockGetGroupsParams{accessToken, realm}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetGroups.t.Errorf("GoCloakMock.GetGroups got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetGroups.GetGroupsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetGroups.t.Fatal("No results are set for the GoCloakMock.GetGroups")
		}
		return (*mm_results).gap1, (*mm_results).err
	}
	if mmGetGroups.funcGetGroups != nil {
		return mmGetGroups.funcGetGroups(accessToken, realm)
	}
	mmGetGroups.t.Fatalf("Unexpected call to GoCloakMock.GetGroups. %v %v", accessToken, realm)
	return
}

// GetGroupsAfterCounter returns a count of finished GoCloakMock.GetGroups invocations
func (mmGetGroups *GoCloakMock) GetGroupsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetGroups.afterGetGroupsCounter)
}

// GetGroupsBeforeCounter returns a count of GoCloakMock.GetGroups invocations
func (mmGetGroups *GoCloakMock) GetGroupsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetGroups.beforeGetGroupsCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.GetGroups.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetGroups *mGoCloakMockGetGroups) Calls() []*GoCloakMockGetGroupsParams {
	mmGetGroups.mutex.RLock()

	argCopy := make([]*GoCloakMockGetGroupsParams, len(mmGetGroups.callArgs))
	copy(argCopy, mmGetGroups.callArgs)

	mmGetGroups.mutex.RUnlock()

	return argCopy
}

// MinimockGetGroupsDone returns true if the count of the GetGroups invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockGetGroupsDone() bool {
	for _, e := range m.GetGroupsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetGroupsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetGroupsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetGroups != nil && mm_atomic.LoadUint64(&m.afterGetGroupsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetGroupsInspect logs each unmet expectation
func (m *GoCloakMock) MinimockGetGroupsInspect() {
	for _, e := range m.GetGroupsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.GetGroups with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetGroupsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetGroupsCounter) < 1 {
		if m.GetGroupsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.GetGroups")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.GetGroups with params: %#v", *m.GetGroupsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetGroups != nil && mm_atomic.LoadUint64(&m.afterGetGroupsCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.GetGroups")
	}
}

type mGoCloakMockGetIssuer struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockGetIssuerExpectation
	expectations       []*GoCloakMockGetIssuerExpectation

	callArgs []*GoCloakMockGetIssuerParams
	mutex    sync.RWMutex
}

// GoCloakMockGetIssuerExpectation specifies expectation struct of the GoCloak.GetIssuer
type GoCloakMockGetIssuerExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockGetIssuerParams
	results *GoCloakMockGetIssuerResults
	Counter uint64
}

// GoCloakMockGetIssuerParams contains parameters of the GoCloak.GetIssuer
type GoCloakMockGetIssuerParams struct {
	realm string
}

// GoCloakMockGetIssuerResults contains results of the GoCloak.GetIssuer
type GoCloakMockGetIssuerResults struct {
	ip1 *mm_gocloak.IssuerResponse
	err error
}

// Expect sets up expected params for GoCloak.GetIssuer
func (mmGetIssuer *mGoCloakMockGetIssuer) Expect(realm string) *mGoCloakMockGetIssuer {
	if mmGetIssuer.mock.funcGetIssuer != nil {
		mmGetIssuer.mock.t.Fatalf("GoCloakMock.GetIssuer mock is already set by Set")
	}

	if mmGetIssuer.defaultExpectation == nil {
		mmGetIssuer.defaultExpectation = &GoCloakMockGetIssuerExpectation{}
	}

	mmGetIssuer.defaultExpectation.params = &GoCloakMockGetIssuerParams{realm}
	for _, e := range mmGetIssuer.expectations {
		if minimock.Equal(e.params, mmGetIssuer.defaultExpectation.params) {
			mmGetIssuer.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetIssuer.defaultExpectation.params)
		}
	}

	return mmGetIssuer
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.GetIssuer
func (mmGetIssuer *mGoCloakMockGetIssuer) Inspect(f func(realm string)) *mGoCloakMockGetIssuer {
	if mmGetIssuer.mock.inspectFuncGetIssuer != nil {
		mmGetIssuer.mock.t.Fatalf("Inspect function is already set for GoCloakMock.GetIssuer")
	}

	mmGetIssuer.mock.inspectFuncGetIssuer = f

	return mmGetIssuer
}

// Return sets up results that will be returned by GoCloak.GetIssuer
func (mmGetIssuer *mGoCloakMockGetIssuer) Return(ip1 *mm_gocloak.IssuerResponse, err error) *GoCloakMock {
	if mmGetIssuer.mock.funcGetIssuer != nil {
		mmGetIssuer.mock.t.Fatalf("GoCloakMock.GetIssuer mock is already set by Set")
	}

	if mmGetIssuer.defaultExpectation == nil {
		mmGetIssuer.defaultExpectation = &GoCloakMockGetIssuerExpectation{mock: mmGetIssuer.mock}
	}
	mmGetIssuer.defaultExpectation.results = &GoCloakMockGetIssuerResults{ip1, err}
	return mmGetIssuer.mock
}

//Set uses given function f to mock the GoCloak.GetIssuer method
func (mmGetIssuer *mGoCloakMockGetIssuer) Set(f func(realm string) (ip1 *mm_gocloak.IssuerResponse, err error)) *GoCloakMock {
	if mmGetIssuer.defaultExpectation != nil {
		mmGetIssuer.mock.t.Fatalf("Default expectation is already set for the GoCloak.GetIssuer method")
	}

	if len(mmGetIssuer.expectations) > 0 {
		mmGetIssuer.mock.t.Fatalf("Some expectations are already set for the GoCloak.GetIssuer method")
	}

	mmGetIssuer.mock.funcGetIssuer = f
	return mmGetIssuer.mock
}

// When sets expectation for the GoCloak.GetIssuer which will trigger the result defined by the following
// Then helper
func (mmGetIssuer *mGoCloakMockGetIssuer) When(realm string) *GoCloakMockGetIssuerExpectation {
	if mmGetIssuer.mock.funcGetIssuer != nil {
		mmGetIssuer.mock.t.Fatalf("GoCloakMock.GetIssuer mock is already set by Set")
	}

	expectation := &GoCloakMockGetIssuerExpectation{
		mock:   mmGetIssuer.mock,
		params: &GoCloakMockGetIssuerParams{realm},
	}
	mmGetIssuer.expectations = append(mmGetIssuer.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.GetIssuer return parameters for the expectation previously defined by the When method
func (e *GoCloakMockGetIssuerExpectation) Then(ip1 *mm_gocloak.IssuerResponse, err error) *GoCloakMock {
	e.results = &GoCloakMockGetIssuerResults{ip1, err}
	return e.mock
}

// GetIssuer implements gocloak.GoCloak
func (mmGetIssuer *GoCloakMock) GetIssuer(realm string) (ip1 *mm_gocloak.IssuerResponse, err error) {
	mm_atomic.AddUint64(&mmGetIssuer.beforeGetIssuerCounter, 1)
	defer mm_atomic.AddUint64(&mmGetIssuer.afterGetIssuerCounter, 1)

	if mmGetIssuer.inspectFuncGetIssuer != nil {
		mmGetIssuer.inspectFuncGetIssuer(realm)
	}

	mm_params := &GoCloakMockGetIssuerParams{realm}

	// Record call args
	mmGetIssuer.GetIssuerMock.mutex.Lock()
	mmGetIssuer.GetIssuerMock.callArgs = append(mmGetIssuer.GetIssuerMock.callArgs, mm_params)
	mmGetIssuer.GetIssuerMock.mutex.Unlock()

	for _, e := range mmGetIssuer.GetIssuerMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ip1, e.results.err
		}
	}

	if mmGetIssuer.GetIssuerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetIssuer.GetIssuerMock.defaultExpectation.Counter, 1)
		mm_want := mmGetIssuer.GetIssuerMock.defaultExpectation.params
		mm_got := GoCloakMockGetIssuerParams{realm}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetIssuer.t.Errorf("GoCloakMock.GetIssuer got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetIssuer.GetIssuerMock.defaultExpectation.results
		if mm_results == nil {
			mmGetIssuer.t.Fatal("No results are set for the GoCloakMock.GetIssuer")
		}
		return (*mm_results).ip1, (*mm_results).err
	}
	if mmGetIssuer.funcGetIssuer != nil {
		return mmGetIssuer.funcGetIssuer(realm)
	}
	mmGetIssuer.t.Fatalf("Unexpected call to GoCloakMock.GetIssuer. %v", realm)
	return
}

// GetIssuerAfterCounter returns a count of finished GoCloakMock.GetIssuer invocations
func (mmGetIssuer *GoCloakMock) GetIssuerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetIssuer.afterGetIssuerCounter)
}

// GetIssuerBeforeCounter returns a count of GoCloakMock.GetIssuer invocations
func (mmGetIssuer *GoCloakMock) GetIssuerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetIssuer.beforeGetIssuerCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.GetIssuer.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetIssuer *mGoCloakMockGetIssuer) Calls() []*GoCloakMockGetIssuerParams {
	mmGetIssuer.mutex.RLock()

	argCopy := make([]*GoCloakMockGetIssuerParams, len(mmGetIssuer.callArgs))
	copy(argCopy, mmGetIssuer.callArgs)

	mmGetIssuer.mutex.RUnlock()

	return argCopy
}

// MinimockGetIssuerDone returns true if the count of the GetIssuer invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockGetIssuerDone() bool {
	for _, e := range m.GetIssuerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetIssuerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetIssuerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetIssuer != nil && mm_atomic.LoadUint64(&m.afterGetIssuerCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetIssuerInspect logs each unmet expectation
func (m *GoCloakMock) MinimockGetIssuerInspect() {
	for _, e := range m.GetIssuerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.GetIssuer with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetIssuerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetIssuerCounter) < 1 {
		if m.GetIssuerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.GetIssuer")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.GetIssuer with params: %#v", *m.GetIssuerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetIssuer != nil && mm_atomic.LoadUint64(&m.afterGetIssuerCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.GetIssuer")
	}
}

type mGoCloakMockGetKeyStoreConfig struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockGetKeyStoreConfigExpectation
	expectations       []*GoCloakMockGetKeyStoreConfigExpectation

	callArgs []*GoCloakMockGetKeyStoreConfigParams
	mutex    sync.RWMutex
}

// GoCloakMockGetKeyStoreConfigExpectation specifies expectation struct of the GoCloak.GetKeyStoreConfig
type GoCloakMockGetKeyStoreConfigExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockGetKeyStoreConfigParams
	results *GoCloakMockGetKeyStoreConfigResults
	Counter uint64
}

// GoCloakMockGetKeyStoreConfigParams contains parameters of the GoCloak.GetKeyStoreConfig
type GoCloakMockGetKeyStoreConfigParams struct {
	accessToken string
	realm       string
}

// GoCloakMockGetKeyStoreConfigResults contains results of the GoCloak.GetKeyStoreConfig
type GoCloakMockGetKeyStoreConfigResults struct {
	kp1 *mm_gocloak.KeyStoreConfig
	err error
}

// Expect sets up expected params for GoCloak.GetKeyStoreConfig
func (mmGetKeyStoreConfig *mGoCloakMockGetKeyStoreConfig) Expect(accessToken string, realm string) *mGoCloakMockGetKeyStoreConfig {
	if mmGetKeyStoreConfig.mock.funcGetKeyStoreConfig != nil {
		mmGetKeyStoreConfig.mock.t.Fatalf("GoCloakMock.GetKeyStoreConfig mock is already set by Set")
	}

	if mmGetKeyStoreConfig.defaultExpectation == nil {
		mmGetKeyStoreConfig.defaultExpectation = &GoCloakMockGetKeyStoreConfigExpectation{}
	}

	mmGetKeyStoreConfig.defaultExpectation.params = &GoCloakMockGetKeyStoreConfigParams{accessToken, realm}
	for _, e := range mmGetKeyStoreConfig.expectations {
		if minimock.Equal(e.params, mmGetKeyStoreConfig.defaultExpectation.params) {
			mmGetKeyStoreConfig.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKeyStoreConfig.defaultExpectation.params)
		}
	}

	return mmGetKeyStoreConfig
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.GetKeyStoreConfig
func (mmGetKeyStoreConfig *mGoCloakMockGetKeyStoreConfig) Inspect(f func(accessToken string, realm string)) *mGoCloakMockGetKeyStoreConfig {
	if mmGetKeyStoreConfig.mock.inspectFuncGetKeyStoreConfig != nil {
		mmGetKeyStoreConfig.mock.t.Fatalf("Inspect function is already set for GoCloakMock.GetKeyStoreConfig")
	}

	mmGetKeyStoreConfig.mock.inspectFuncGetKeyStoreConfig = f

	return mmGetKeyStoreConfig
}

// Return sets up results that will be returned by GoCloak.GetKeyStoreConfig
func (mmGetKeyStoreConfig *mGoCloakMockGetKeyStoreConfig) Return(kp1 *mm_gocloak.KeyStoreConfig, err error) *GoCloakMock {
	if mmGetKeyStoreConfig.mock.funcGetKeyStoreConfig != nil {
		mmGetKeyStoreConfig.mock.t.Fatalf("GoCloakMock.GetKeyStoreConfig mock is already set by Set")
	}

	if mmGetKeyStoreConfig.defaultExpectation == nil {
		mmGetKeyStoreConfig.defaultExpectation = &GoCloakMockGetKeyStoreConfigExpectation{mock: mmGetKeyStoreConfig.mock}
	}
	mmGetKeyStoreConfig.defaultExpectation.results = &GoCloakMockGetKeyStoreConfigResults{kp1, err}
	return mmGetKeyStoreConfig.mock
}

//Set uses given function f to mock the GoCloak.GetKeyStoreConfig method
func (mmGetKeyStoreConfig *mGoCloakMockGetKeyStoreConfig) Set(f func(accessToken string, realm string) (kp1 *mm_gocloak.KeyStoreConfig, err error)) *GoCloakMock {
	if mmGetKeyStoreConfig.defaultExpectation != nil {
		mmGetKeyStoreConfig.mock.t.Fatalf("Default expectation is already set for the GoCloak.GetKeyStoreConfig method")
	}

	if len(mmGetKeyStoreConfig.expectations) > 0 {
		mmGetKeyStoreConfig.mock.t.Fatalf("Some expectations are already set for the GoCloak.GetKeyStoreConfig method")
	}

	mmGetKeyStoreConfig.mock.funcGetKeyStoreConfig = f
	return mmGetKeyStoreConfig.mock
}

// When sets expectation for the GoCloak.GetKeyStoreConfig which will trigger the result defined by the following
// Then helper
func (mmGetKeyStoreConfig *mGoCloakMockGetKeyStoreConfig) When(accessToken string, realm string) *GoCloakMockGetKeyStoreConfigExpectation {
	if mmGetKeyStoreConfig.mock.funcGetKeyStoreConfig != nil {
		mmGetKeyStoreConfig.mock.t.Fatalf("GoCloakMock.GetKeyStoreConfig mock is already set by Set")
	}

	expectation := &GoCloakMockGetKeyStoreConfigExpectation{
		mock:   mmGetKeyStoreConfig.mock,
		params: &GoCloakMockGetKeyStoreConfigParams{accessToken, realm},
	}
	mmGetKeyStoreConfig.expectations = append(mmGetKeyStoreConfig.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.GetKeyStoreConfig return parameters for the expectation previously defined by the When method
func (e *GoCloakMockGetKeyStoreConfigExpectation) Then(kp1 *mm_gocloak.KeyStoreConfig, err error) *GoCloakMock {
	e.results = &GoCloakMockGetKeyStoreConfigResults{kp1, err}
	return e.mock
}

// GetKeyStoreConfig implements gocloak.GoCloak
func (mmGetKeyStoreConfig *GoCloakMock) GetKeyStoreConfig(accessToken string, realm string) (kp1 *mm_gocloak.KeyStoreConfig, err error) {
	mm_atomic.AddUint64(&mmGetKeyStoreConfig.beforeGetKeyStoreConfigCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKeyStoreConfig.afterGetKeyStoreConfigCounter, 1)

	if mmGetKeyStoreConfig.inspectFuncGetKeyStoreConfig != nil {
		mmGetKeyStoreConfig.inspectFuncGetKeyStoreConfig(accessToken, realm)
	}

	mm_params := &GoCloakMockGetKeyStoreConfigParams{accessToken, realm}

	// Record call args
	mmGetKeyStoreConfig.GetKeyStoreConfigMock.mutex.Lock()
	mmGetKeyStoreConfig.GetKeyStoreConfigMock.callArgs = append(mmGetKeyStoreConfig.GetKeyStoreConfigMock.callArgs, mm_params)
	mmGetKeyStoreConfig.GetKeyStoreConfigMock.mutex.Unlock()

	for _, e := range mmGetKeyStoreConfig.GetKeyStoreConfigMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.kp1, e.results.err
		}
	}

	if mmGetKeyStoreConfig.GetKeyStoreConfigMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKeyStoreConfig.GetKeyStoreConfigMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKeyStoreConfig.GetKeyStoreConfigMock.defaultExpectation.params
		mm_got := GoCloakMockGetKeyStoreConfigParams{accessToken, realm}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKeyStoreConfig.t.Errorf("GoCloakMock.GetKeyStoreConfig got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKeyStoreConfig.GetKeyStoreConfigMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKeyStoreConfig.t.Fatal("No results are set for the GoCloakMock.GetKeyStoreConfig")
		}
		return (*mm_results).kp1, (*mm_results).err
	}
	if mmGetKeyStoreConfig.funcGetKeyStoreConfig != nil {
		return mmGetKeyStoreConfig.funcGetKeyStoreConfig(accessToken, realm)
	}
	mmGetKeyStoreConfig.t.Fatalf("Unexpected call to GoCloakMock.GetKeyStoreConfig. %v %v", accessToken, realm)
	return
}

// GetKeyStoreConfigAfterCounter returns a count of finished GoCloakMock.GetKeyStoreConfig invocations
func (mmGetKeyStoreConfig *GoCloakMock) GetKeyStoreConfigAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKeyStoreConfig.afterGetKeyStoreConfigCounter)
}

// GetKeyStoreConfigBeforeCounter returns a count of GoCloakMock.GetKeyStoreConfig invocations
func (mmGetKeyStoreConfig *GoCloakMock) GetKeyStoreConfigBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKeyStoreConfig.beforeGetKeyStoreConfigCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.GetKeyStoreConfig.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKeyStoreConfig *mGoCloakMockGetKeyStoreConfig) Calls() []*GoCloakMockGetKeyStoreConfigParams {
	mmGetKeyStoreConfig.mutex.RLock()

	argCopy := make([]*GoCloakMockGetKeyStoreConfigParams, len(mmGetKeyStoreConfig.callArgs))
	copy(argCopy, mmGetKeyStoreConfig.callArgs)

	mmGetKeyStoreConfig.mutex.RUnlock()

	return argCopy
}

// MinimockGetKeyStoreConfigDone returns true if the count of the GetKeyStoreConfig invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockGetKeyStoreConfigDone() bool {
	for _, e := range m.GetKeyStoreConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetKeyStoreConfigMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetKeyStoreConfigCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKeyStoreConfig != nil && mm_atomic.LoadUint64(&m.afterGetKeyStoreConfigCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetKeyStoreConfigInspect logs each unmet expectation
func (m *GoCloakMock) MinimockGetKeyStoreConfigInspect() {
	for _, e := range m.GetKeyStoreConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.GetKeyStoreConfig with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetKeyStoreConfigMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetKeyStoreConfigCounter) < 1 {
		if m.GetKeyStoreConfigMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.GetKeyStoreConfig")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.GetKeyStoreConfig with params: %#v", *m.GetKeyStoreConfigMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKeyStoreConfig != nil && mm_atomic.LoadUint64(&m.afterGetKeyStoreConfigCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.GetKeyStoreConfig")
	}
}

type mGoCloakMockGetRealmRolesByGroupID struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockGetRealmRolesByGroupIDExpectation
	expectations       []*GoCloakMockGetRealmRolesByGroupIDExpectation

	callArgs []*GoCloakMockGetRealmRolesByGroupIDParams
	mutex    sync.RWMutex
}

// GoCloakMockGetRealmRolesByGroupIDExpectation specifies expectation struct of the GoCloak.GetRealmRolesByGroupID
type GoCloakMockGetRealmRolesByGroupIDExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockGetRealmRolesByGroupIDParams
	results *GoCloakMockGetRealmRolesByGroupIDResults
	Counter uint64
}

// GoCloakMockGetRealmRolesByGroupIDParams contains parameters of the GoCloak.GetRealmRolesByGroupID
type GoCloakMockGetRealmRolesByGroupIDParams struct {
	accessToken string
	realm       string
	groupID     string
}

// GoCloakMockGetRealmRolesByGroupIDResults contains results of the GoCloak.GetRealmRolesByGroupID
type GoCloakMockGetRealmRolesByGroupIDResults struct {
	rap1 *[]mm_gocloak.Role
	err  error
}

// Expect sets up expected params for GoCloak.GetRealmRolesByGroupID
func (mmGetRealmRolesByGroupID *mGoCloakMockGetRealmRolesByGroupID) Expect(accessToken string, realm string, groupID string) *mGoCloakMockGetRealmRolesByGroupID {
	if mmGetRealmRolesByGroupID.mock.funcGetRealmRolesByGroupID != nil {
		mmGetRealmRolesByGroupID.mock.t.Fatalf("GoCloakMock.GetRealmRolesByGroupID mock is already set by Set")
	}

	if mmGetRealmRolesByGroupID.defaultExpectation == nil {
		mmGetRealmRolesByGroupID.defaultExpectation = &GoCloakMockGetRealmRolesByGroupIDExpectation{}
	}

	mmGetRealmRolesByGroupID.defaultExpectation.params = &GoCloakMockGetRealmRolesByGroupIDParams{accessToken, realm, groupID}
	for _, e := range mmGetRealmRolesByGroupID.expectations {
		if minimock.Equal(e.params, mmGetRealmRolesByGroupID.defaultExpectation.params) {
			mmGetRealmRolesByGroupID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRealmRolesByGroupID.defaultExpectation.params)
		}
	}

	return mmGetRealmRolesByGroupID
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.GetRealmRolesByGroupID
func (mmGetRealmRolesByGroupID *mGoCloakMockGetRealmRolesByGroupID) Inspect(f func(accessToken string, realm string, groupID string)) *mGoCloakMockGetRealmRolesByGroupID {
	if mmGetRealmRolesByGroupID.mock.inspectFuncGetRealmRolesByGroupID != nil {
		mmGetRealmRolesByGroupID.mock.t.Fatalf("Inspect function is already set for GoCloakMock.GetRealmRolesByGroupID")
	}

	mmGetRealmRolesByGroupID.mock.inspectFuncGetRealmRolesByGroupID = f

	return mmGetRealmRolesByGroupID
}

// Return sets up results that will be returned by GoCloak.GetRealmRolesByGroupID
func (mmGetRealmRolesByGroupID *mGoCloakMockGetRealmRolesByGroupID) Return(rap1 *[]mm_gocloak.Role, err error) *GoCloakMock {
	if mmGetRealmRolesByGroupID.mock.funcGetRealmRolesByGroupID != nil {
		mmGetRealmRolesByGroupID.mock.t.Fatalf("GoCloakMock.GetRealmRolesByGroupID mock is already set by Set")
	}

	if mmGetRealmRolesByGroupID.defaultExpectation == nil {
		mmGetRealmRolesByGroupID.defaultExpectation = &GoCloakMockGetRealmRolesByGroupIDExpectation{mock: mmGetRealmRolesByGroupID.mock}
	}
	mmGetRealmRolesByGroupID.defaultExpectation.results = &GoCloakMockGetRealmRolesByGroupIDResults{rap1, err}
	return mmGetRealmRolesByGroupID.mock
}

//Set uses given function f to mock the GoCloak.GetRealmRolesByGroupID method
func (mmGetRealmRolesByGroupID *mGoCloakMockGetRealmRolesByGroupID) Set(f func(accessToken string, realm string, groupID string) (rap1 *[]mm_gocloak.Role, err error)) *GoCloakMock {
	if mmGetRealmRolesByGroupID.defaultExpectation != nil {
		mmGetRealmRolesByGroupID.mock.t.Fatalf("Default expectation is already set for the GoCloak.GetRealmRolesByGroupID method")
	}

	if len(mmGetRealmRolesByGroupID.expectations) > 0 {
		mmGetRealmRolesByGroupID.mock.t.Fatalf("Some expectations are already set for the GoCloak.GetRealmRolesByGroupID method")
	}

	mmGetRealmRolesByGroupID.mock.funcGetRealmRolesByGroupID = f
	return mmGetRealmRolesByGroupID.mock
}

// When sets expectation for the GoCloak.GetRealmRolesByGroupID which will trigger the result defined by the following
// Then helper
func (mmGetRealmRolesByGroupID *mGoCloakMockGetRealmRolesByGroupID) When(accessToken string, realm string, groupID string) *GoCloakMockGetRealmRolesByGroupIDExpectation {
	if mmGetRealmRolesByGroupID.mock.funcGetRealmRolesByGroupID != nil {
		mmGetRealmRolesByGroupID.mock.t.Fatalf("GoCloakMock.GetRealmRolesByGroupID mock is already set by Set")
	}

	expectation := &GoCloakMockGetRealmRolesByGroupIDExpectation{
		mock:   mmGetRealmRolesByGroupID.mock,
		params: &GoCloakMockGetRealmRolesByGroupIDParams{accessToken, realm, groupID},
	}
	mmGetRealmRolesByGroupID.expectations = append(mmGetRealmRolesByGroupID.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.GetRealmRolesByGroupID return parameters for the expectation previously defined by the When method
func (e *GoCloakMockGetRealmRolesByGroupIDExpectation) Then(rap1 *[]mm_gocloak.Role, err error) *GoCloakMock {
	e.results = &GoCloakMockGetRealmRolesByGroupIDResults{rap1, err}
	return e.mock
}

// GetRealmRolesByGroupID implements gocloak.GoCloak
func (mmGetRealmRolesByGroupID *GoCloakMock) GetRealmRolesByGroupID(accessToken string, realm string, groupID string) (rap1 *[]mm_gocloak.Role, err error) {
	mm_atomic.AddUint64(&mmGetRealmRolesByGroupID.beforeGetRealmRolesByGroupIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRealmRolesByGroupID.afterGetRealmRolesByGroupIDCounter, 1)

	if mmGetRealmRolesByGroupID.inspectFuncGetRealmRolesByGroupID != nil {
		mmGetRealmRolesByGroupID.inspectFuncGetRealmRolesByGroupID(accessToken, realm, groupID)
	}

	mm_params := &GoCloakMockGetRealmRolesByGroupIDParams{accessToken, realm, groupID}

	// Record call args
	mmGetRealmRolesByGroupID.GetRealmRolesByGroupIDMock.mutex.Lock()
	mmGetRealmRolesByGroupID.GetRealmRolesByGroupIDMock.callArgs = append(mmGetRealmRolesByGroupID.GetRealmRolesByGroupIDMock.callArgs, mm_params)
	mmGetRealmRolesByGroupID.GetRealmRolesByGroupIDMock.mutex.Unlock()

	for _, e := range mmGetRealmRolesByGroupID.GetRealmRolesByGroupIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rap1, e.results.err
		}
	}

	if mmGetRealmRolesByGroupID.GetRealmRolesByGroupIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRealmRolesByGroupID.GetRealmRolesByGroupIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRealmRolesByGroupID.GetRealmRolesByGroupIDMock.defaultExpectation.params
		mm_got := GoCloakMockGetRealmRolesByGroupIDParams{accessToken, realm, groupID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRealmRolesByGroupID.t.Errorf("GoCloakMock.GetRealmRolesByGroupID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRealmRolesByGroupID.GetRealmRolesByGroupIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRealmRolesByGroupID.t.Fatal("No results are set for the GoCloakMock.GetRealmRolesByGroupID")
		}
		return (*mm_results).rap1, (*mm_results).err
	}
	if mmGetRealmRolesByGroupID.funcGetRealmRolesByGroupID != nil {
		return mmGetRealmRolesByGroupID.funcGetRealmRolesByGroupID(accessToken, realm, groupID)
	}
	mmGetRealmRolesByGroupID.t.Fatalf("Unexpected call to GoCloakMock.GetRealmRolesByGroupID. %v %v %v", accessToken, realm, groupID)
	return
}

// GetRealmRolesByGroupIDAfterCounter returns a count of finished GoCloakMock.GetRealmRolesByGroupID invocations
func (mmGetRealmRolesByGroupID *GoCloakMock) GetRealmRolesByGroupIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRealmRolesByGroupID.afterGetRealmRolesByGroupIDCounter)
}

// GetRealmRolesByGroupIDBeforeCounter returns a count of GoCloakMock.GetRealmRolesByGroupID invocations
func (mmGetRealmRolesByGroupID *GoCloakMock) GetRealmRolesByGroupIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRealmRolesByGroupID.beforeGetRealmRolesByGroupIDCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.GetRealmRolesByGroupID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRealmRolesByGroupID *mGoCloakMockGetRealmRolesByGroupID) Calls() []*GoCloakMockGetRealmRolesByGroupIDParams {
	mmGetRealmRolesByGroupID.mutex.RLock()

	argCopy := make([]*GoCloakMockGetRealmRolesByGroupIDParams, len(mmGetRealmRolesByGroupID.callArgs))
	copy(argCopy, mmGetRealmRolesByGroupID.callArgs)

	mmGetRealmRolesByGroupID.mutex.RUnlock()

	return argCopy
}

// MinimockGetRealmRolesByGroupIDDone returns true if the count of the GetRealmRolesByGroupID invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockGetRealmRolesByGroupIDDone() bool {
	for _, e := range m.GetRealmRolesByGroupIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRealmRolesByGroupIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRealmRolesByGroupIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRealmRolesByGroupID != nil && mm_atomic.LoadUint64(&m.afterGetRealmRolesByGroupIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetRealmRolesByGroupIDInspect logs each unmet expectation
func (m *GoCloakMock) MinimockGetRealmRolesByGroupIDInspect() {
	for _, e := range m.GetRealmRolesByGroupIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.GetRealmRolesByGroupID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRealmRolesByGroupIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRealmRolesByGroupIDCounter) < 1 {
		if m.GetRealmRolesByGroupIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.GetRealmRolesByGroupID")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.GetRealmRolesByGroupID with params: %#v", *m.GetRealmRolesByGroupIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRealmRolesByGroupID != nil && mm_atomic.LoadUint64(&m.afterGetRealmRolesByGroupIDCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.GetRealmRolesByGroupID")
	}
}

type mGoCloakMockGetRealmRolesByUserID struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockGetRealmRolesByUserIDExpectation
	expectations       []*GoCloakMockGetRealmRolesByUserIDExpectation

	callArgs []*GoCloakMockGetRealmRolesByUserIDParams
	mutex    sync.RWMutex
}

// GoCloakMockGetRealmRolesByUserIDExpectation specifies expectation struct of the GoCloak.GetRealmRolesByUserID
type GoCloakMockGetRealmRolesByUserIDExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockGetRealmRolesByUserIDParams
	results *GoCloakMockGetRealmRolesByUserIDResults
	Counter uint64
}

// GoCloakMockGetRealmRolesByUserIDParams contains parameters of the GoCloak.GetRealmRolesByUserID
type GoCloakMockGetRealmRolesByUserIDParams struct {
	accessToken string
	realm       string
	userID      string
}

// GoCloakMockGetRealmRolesByUserIDResults contains results of the GoCloak.GetRealmRolesByUserID
type GoCloakMockGetRealmRolesByUserIDResults struct {
	rap1 *[]mm_gocloak.Role
	err  error
}

// Expect sets up expected params for GoCloak.GetRealmRolesByUserID
func (mmGetRealmRolesByUserID *mGoCloakMockGetRealmRolesByUserID) Expect(accessToken string, realm string, userID string) *mGoCloakMockGetRealmRolesByUserID {
	if mmGetRealmRolesByUserID.mock.funcGetRealmRolesByUserID != nil {
		mmGetRealmRolesByUserID.mock.t.Fatalf("GoCloakMock.GetRealmRolesByUserID mock is already set by Set")
	}

	if mmGetRealmRolesByUserID.defaultExpectation == nil {
		mmGetRealmRolesByUserID.defaultExpectation = &GoCloakMockGetRealmRolesByUserIDExpectation{}
	}

	mmGetRealmRolesByUserID.defaultExpectation.params = &GoCloakMockGetRealmRolesByUserIDParams{accessToken, realm, userID}
	for _, e := range mmGetRealmRolesByUserID.expectations {
		if minimock.Equal(e.params, mmGetRealmRolesByUserID.defaultExpectation.params) {
			mmGetRealmRolesByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRealmRolesByUserID.defaultExpectation.params)
		}
	}

	return mmGetRealmRolesByUserID
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.GetRealmRolesByUserID
func (mmGetRealmRolesByUserID *mGoCloakMockGetRealmRolesByUserID) Inspect(f func(accessToken string, realm string, userID string)) *mGoCloakMockGetRealmRolesByUserID {
	if mmGetRealmRolesByUserID.mock.inspectFuncGetRealmRolesByUserID != nil {
		mmGetRealmRolesByUserID.mock.t.Fatalf("Inspect function is already set for GoCloakMock.GetRealmRolesByUserID")
	}

	mmGetRealmRolesByUserID.mock.inspectFuncGetRealmRolesByUserID = f

	return mmGetRealmRolesByUserID
}

// Return sets up results that will be returned by GoCloak.GetRealmRolesByUserID
func (mmGetRealmRolesByUserID *mGoCloakMockGetRealmRolesByUserID) Return(rap1 *[]mm_gocloak.Role, err error) *GoCloakMock {
	if mmGetRealmRolesByUserID.mock.funcGetRealmRolesByUserID != nil {
		mmGetRealmRolesByUserID.mock.t.Fatalf("GoCloakMock.GetRealmRolesByUserID mock is already set by Set")
	}

	if mmGetRealmRolesByUserID.defaultExpectation == nil {
		mmGetRealmRolesByUserID.defaultExpectation = &GoCloakMockGetRealmRolesByUserIDExpectation{mock: mmGetRealmRolesByUserID.mock}
	}
	mmGetRealmRolesByUserID.defaultExpectation.results = &GoCloakMockGetRealmRolesByUserIDResults{rap1, err}
	return mmGetRealmRolesByUserID.mock
}

//Set uses given function f to mock the GoCloak.GetRealmRolesByUserID method
func (mmGetRealmRolesByUserID *mGoCloakMockGetRealmRolesByUserID) Set(f func(accessToken string, realm string, userID string) (rap1 *[]mm_gocloak.Role, err error)) *GoCloakMock {
	if mmGetRealmRolesByUserID.defaultExpectation != nil {
		mmGetRealmRolesByUserID.mock.t.Fatalf("Default expectation is already set for the GoCloak.GetRealmRolesByUserID method")
	}

	if len(mmGetRealmRolesByUserID.expectations) > 0 {
		mmGetRealmRolesByUserID.mock.t.Fatalf("Some expectations are already set for the GoCloak.GetRealmRolesByUserID method")
	}

	mmGetRealmRolesByUserID.mock.funcGetRealmRolesByUserID = f
	return mmGetRealmRolesByUserID.mock
}

// When sets expectation for the GoCloak.GetRealmRolesByUserID which will trigger the result defined by the following
// Then helper
func (mmGetRealmRolesByUserID *mGoCloakMockGetRealmRolesByUserID) When(accessToken string, realm string, userID string) *GoCloakMockGetRealmRolesByUserIDExpectation {
	if mmGetRealmRolesByUserID.mock.funcGetRealmRolesByUserID != nil {
		mmGetRealmRolesByUserID.mock.t.Fatalf("GoCloakMock.GetRealmRolesByUserID mock is already set by Set")
	}

	expectation := &GoCloakMockGetRealmRolesByUserIDExpectation{
		mock:   mmGetRealmRolesByUserID.mock,
		params: &GoCloakMockGetRealmRolesByUserIDParams{accessToken, realm, userID},
	}
	mmGetRealmRolesByUserID.expectations = append(mmGetRealmRolesByUserID.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.GetRealmRolesByUserID return parameters for the expectation previously defined by the When method
func (e *GoCloakMockGetRealmRolesByUserIDExpectation) Then(rap1 *[]mm_gocloak.Role, err error) *GoCloakMock {
	e.results = &GoCloakMockGetRealmRolesByUserIDResults{rap1, err}
	return e.mock
}

// GetRealmRolesByUserID implements gocloak.GoCloak
func (mmGetRealmRolesByUserID *GoCloakMock) GetRealmRolesByUserID(accessToken string, realm string, userID string) (rap1 *[]mm_gocloak.Role, err error) {
	mm_atomic.AddUint64(&mmGetRealmRolesByUserID.beforeGetRealmRolesByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRealmRolesByUserID.afterGetRealmRolesByUserIDCounter, 1)

	if mmGetRealmRolesByUserID.inspectFuncGetRealmRolesByUserID != nil {
		mmGetRealmRolesByUserID.inspectFuncGetRealmRolesByUserID(accessToken, realm, userID)
	}

	mm_params := &GoCloakMockGetRealmRolesByUserIDParams{accessToken, realm, userID}

	// Record call args
	mmGetRealmRolesByUserID.GetRealmRolesByUserIDMock.mutex.Lock()
	mmGetRealmRolesByUserID.GetRealmRolesByUserIDMock.callArgs = append(mmGetRealmRolesByUserID.GetRealmRolesByUserIDMock.callArgs, mm_params)
	mmGetRealmRolesByUserID.GetRealmRolesByUserIDMock.mutex.Unlock()

	for _, e := range mmGetRealmRolesByUserID.GetRealmRolesByUserIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rap1, e.results.err
		}
	}

	if mmGetRealmRolesByUserID.GetRealmRolesByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRealmRolesByUserID.GetRealmRolesByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRealmRolesByUserID.GetRealmRolesByUserIDMock.defaultExpectation.params
		mm_got := GoCloakMockGetRealmRolesByUserIDParams{accessToken, realm, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRealmRolesByUserID.t.Errorf("GoCloakMock.GetRealmRolesByUserID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRealmRolesByUserID.GetRealmRolesByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRealmRolesByUserID.t.Fatal("No results are set for the GoCloakMock.GetRealmRolesByUserID")
		}
		return (*mm_results).rap1, (*mm_results).err
	}
	if mmGetRealmRolesByUserID.funcGetRealmRolesByUserID != nil {
		return mmGetRealmRolesByUserID.funcGetRealmRolesByUserID(accessToken, realm, userID)
	}
	mmGetRealmRolesByUserID.t.Fatalf("Unexpected call to GoCloakMock.GetRealmRolesByUserID. %v %v %v", accessToken, realm, userID)
	return
}

// GetRealmRolesByUserIDAfterCounter returns a count of finished GoCloakMock.GetRealmRolesByUserID invocations
func (mmGetRealmRolesByUserID *GoCloakMock) GetRealmRolesByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRealmRolesByUserID.afterGetRealmRolesByUserIDCounter)
}

// GetRealmRolesByUserIDBeforeCounter returns a count of GoCloakMock.GetRealmRolesByUserID invocations
func (mmGetRealmRolesByUserID *GoCloakMock) GetRealmRolesByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRealmRolesByUserID.beforeGetRealmRolesByUserIDCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.GetRealmRolesByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRealmRolesByUserID *mGoCloakMockGetRealmRolesByUserID) Calls() []*GoCloakMockGetRealmRolesByUserIDParams {
	mmGetRealmRolesByUserID.mutex.RLock()

	argCopy := make([]*GoCloakMockGetRealmRolesByUserIDParams, len(mmGetRealmRolesByUserID.callArgs))
	copy(argCopy, mmGetRealmRolesByUserID.callArgs)

	mmGetRealmRolesByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockGetRealmRolesByUserIDDone returns true if the count of the GetRealmRolesByUserID invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockGetRealmRolesByUserIDDone() bool {
	for _, e := range m.GetRealmRolesByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRealmRolesByUserIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRealmRolesByUserIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRealmRolesByUserID != nil && mm_atomic.LoadUint64(&m.afterGetRealmRolesByUserIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetRealmRolesByUserIDInspect logs each unmet expectation
func (m *GoCloakMock) MinimockGetRealmRolesByUserIDInspect() {
	for _, e := range m.GetRealmRolesByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.GetRealmRolesByUserID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRealmRolesByUserIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRealmRolesByUserIDCounter) < 1 {
		if m.GetRealmRolesByUserIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.GetRealmRolesByUserID")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.GetRealmRolesByUserID with params: %#v", *m.GetRealmRolesByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRealmRolesByUserID != nil && mm_atomic.LoadUint64(&m.afterGetRealmRolesByUserIDCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.GetRealmRolesByUserID")
	}
}

type mGoCloakMockGetRoleMappingByGroupID struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockGetRoleMappingByGroupIDExpectation
	expectations       []*GoCloakMockGetRoleMappingByGroupIDExpectation

	callArgs []*GoCloakMockGetRoleMappingByGroupIDParams
	mutex    sync.RWMutex
}

// GoCloakMockGetRoleMappingByGroupIDExpectation specifies expectation struct of the GoCloak.GetRoleMappingByGroupID
type GoCloakMockGetRoleMappingByGroupIDExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockGetRoleMappingByGroupIDParams
	results *GoCloakMockGetRoleMappingByGroupIDResults
	Counter uint64
}

// GoCloakMockGetRoleMappingByGroupIDParams contains parameters of the GoCloak.GetRoleMappingByGroupID
type GoCloakMockGetRoleMappingByGroupIDParams struct {
	accessToken string
	realm       string
	groupID     string
}

// GoCloakMockGetRoleMappingByGroupIDResults contains results of the GoCloak.GetRoleMappingByGroupID
type GoCloakMockGetRoleMappingByGroupIDResults struct {
	rap1 *[]mm_gocloak.RoleMapping
	err  error
}

// Expect sets up expected params for GoCloak.GetRoleMappingByGroupID
func (mmGetRoleMappingByGroupID *mGoCloakMockGetRoleMappingByGroupID) Expect(accessToken string, realm string, groupID string) *mGoCloakMockGetRoleMappingByGroupID {
	if mmGetRoleMappingByGroupID.mock.funcGetRoleMappingByGroupID != nil {
		mmGetRoleMappingByGroupID.mock.t.Fatalf("GoCloakMock.GetRoleMappingByGroupID mock is already set by Set")
	}

	if mmGetRoleMappingByGroupID.defaultExpectation == nil {
		mmGetRoleMappingByGroupID.defaultExpectation = &GoCloakMockGetRoleMappingByGroupIDExpectation{}
	}

	mmGetRoleMappingByGroupID.defaultExpectation.params = &GoCloakMockGetRoleMappingByGroupIDParams{accessToken, realm, groupID}
	for _, e := range mmGetRoleMappingByGroupID.expectations {
		if minimock.Equal(e.params, mmGetRoleMappingByGroupID.defaultExpectation.params) {
			mmGetRoleMappingByGroupID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRoleMappingByGroupID.defaultExpectation.params)
		}
	}

	return mmGetRoleMappingByGroupID
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.GetRoleMappingByGroupID
func (mmGetRoleMappingByGroupID *mGoCloakMockGetRoleMappingByGroupID) Inspect(f func(accessToken string, realm string, groupID string)) *mGoCloakMockGetRoleMappingByGroupID {
	if mmGetRoleMappingByGroupID.mock.inspectFuncGetRoleMappingByGroupID != nil {
		mmGetRoleMappingByGroupID.mock.t.Fatalf("Inspect function is already set for GoCloakMock.GetRoleMappingByGroupID")
	}

	mmGetRoleMappingByGroupID.mock.inspectFuncGetRoleMappingByGroupID = f

	return mmGetRoleMappingByGroupID
}

// Return sets up results that will be returned by GoCloak.GetRoleMappingByGroupID
func (mmGetRoleMappingByGroupID *mGoCloakMockGetRoleMappingByGroupID) Return(rap1 *[]mm_gocloak.RoleMapping, err error) *GoCloakMock {
	if mmGetRoleMappingByGroupID.mock.funcGetRoleMappingByGroupID != nil {
		mmGetRoleMappingByGroupID.mock.t.Fatalf("GoCloakMock.GetRoleMappingByGroupID mock is already set by Set")
	}

	if mmGetRoleMappingByGroupID.defaultExpectation == nil {
		mmGetRoleMappingByGroupID.defaultExpectation = &GoCloakMockGetRoleMappingByGroupIDExpectation{mock: mmGetRoleMappingByGroupID.mock}
	}
	mmGetRoleMappingByGroupID.defaultExpectation.results = &GoCloakMockGetRoleMappingByGroupIDResults{rap1, err}
	return mmGetRoleMappingByGroupID.mock
}

//Set uses given function f to mock the GoCloak.GetRoleMappingByGroupID method
func (mmGetRoleMappingByGroupID *mGoCloakMockGetRoleMappingByGroupID) Set(f func(accessToken string, realm string, groupID string) (rap1 *[]mm_gocloak.RoleMapping, err error)) *GoCloakMock {
	if mmGetRoleMappingByGroupID.defaultExpectation != nil {
		mmGetRoleMappingByGroupID.mock.t.Fatalf("Default expectation is already set for the GoCloak.GetRoleMappingByGroupID method")
	}

	if len(mmGetRoleMappingByGroupID.expectations) > 0 {
		mmGetRoleMappingByGroupID.mock.t.Fatalf("Some expectations are already set for the GoCloak.GetRoleMappingByGroupID method")
	}

	mmGetRoleMappingByGroupID.mock.funcGetRoleMappingByGroupID = f
	return mmGetRoleMappingByGroupID.mock
}

// When sets expectation for the GoCloak.GetRoleMappingByGroupID which will trigger the result defined by the following
// Then helper
func (mmGetRoleMappingByGroupID *mGoCloakMockGetRoleMappingByGroupID) When(accessToken string, realm string, groupID string) *GoCloakMockGetRoleMappingByGroupIDExpectation {
	if mmGetRoleMappingByGroupID.mock.funcGetRoleMappingByGroupID != nil {
		mmGetRoleMappingByGroupID.mock.t.Fatalf("GoCloakMock.GetRoleMappingByGroupID mock is already set by Set")
	}

	expectation := &GoCloakMockGetRoleMappingByGroupIDExpectation{
		mock:   mmGetRoleMappingByGroupID.mock,
		params: &GoCloakMockGetRoleMappingByGroupIDParams{accessToken, realm, groupID},
	}
	mmGetRoleMappingByGroupID.expectations = append(mmGetRoleMappingByGroupID.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.GetRoleMappingByGroupID return parameters for the expectation previously defined by the When method
func (e *GoCloakMockGetRoleMappingByGroupIDExpectation) Then(rap1 *[]mm_gocloak.RoleMapping, err error) *GoCloakMock {
	e.results = &GoCloakMockGetRoleMappingByGroupIDResults{rap1, err}
	return e.mock
}

// GetRoleMappingByGroupID implements gocloak.GoCloak
func (mmGetRoleMappingByGroupID *GoCloakMock) GetRoleMappingByGroupID(accessToken string, realm string, groupID string) (rap1 *[]mm_gocloak.RoleMapping, err error) {
	mm_atomic.AddUint64(&mmGetRoleMappingByGroupID.beforeGetRoleMappingByGroupIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRoleMappingByGroupID.afterGetRoleMappingByGroupIDCounter, 1)

	if mmGetRoleMappingByGroupID.inspectFuncGetRoleMappingByGroupID != nil {
		mmGetRoleMappingByGroupID.inspectFuncGetRoleMappingByGroupID(accessToken, realm, groupID)
	}

	mm_params := &GoCloakMockGetRoleMappingByGroupIDParams{accessToken, realm, groupID}

	// Record call args
	mmGetRoleMappingByGroupID.GetRoleMappingByGroupIDMock.mutex.Lock()
	mmGetRoleMappingByGroupID.GetRoleMappingByGroupIDMock.callArgs = append(mmGetRoleMappingByGroupID.GetRoleMappingByGroupIDMock.callArgs, mm_params)
	mmGetRoleMappingByGroupID.GetRoleMappingByGroupIDMock.mutex.Unlock()

	for _, e := range mmGetRoleMappingByGroupID.GetRoleMappingByGroupIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rap1, e.results.err
		}
	}

	if mmGetRoleMappingByGroupID.GetRoleMappingByGroupIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRoleMappingByGroupID.GetRoleMappingByGroupIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRoleMappingByGroupID.GetRoleMappingByGroupIDMock.defaultExpectation.params
		mm_got := GoCloakMockGetRoleMappingByGroupIDParams{accessToken, realm, groupID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRoleMappingByGroupID.t.Errorf("GoCloakMock.GetRoleMappingByGroupID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRoleMappingByGroupID.GetRoleMappingByGroupIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRoleMappingByGroupID.t.Fatal("No results are set for the GoCloakMock.GetRoleMappingByGroupID")
		}
		return (*mm_results).rap1, (*mm_results).err
	}
	if mmGetRoleMappingByGroupID.funcGetRoleMappingByGroupID != nil {
		return mmGetRoleMappingByGroupID.funcGetRoleMappingByGroupID(accessToken, realm, groupID)
	}
	mmGetRoleMappingByGroupID.t.Fatalf("Unexpected call to GoCloakMock.GetRoleMappingByGroupID. %v %v %v", accessToken, realm, groupID)
	return
}

// GetRoleMappingByGroupIDAfterCounter returns a count of finished GoCloakMock.GetRoleMappingByGroupID invocations
func (mmGetRoleMappingByGroupID *GoCloakMock) GetRoleMappingByGroupIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRoleMappingByGroupID.afterGetRoleMappingByGroupIDCounter)
}

// GetRoleMappingByGroupIDBeforeCounter returns a count of GoCloakMock.GetRoleMappingByGroupID invocations
func (mmGetRoleMappingByGroupID *GoCloakMock) GetRoleMappingByGroupIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRoleMappingByGroupID.beforeGetRoleMappingByGroupIDCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.GetRoleMappingByGroupID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRoleMappingByGroupID *mGoCloakMockGetRoleMappingByGroupID) Calls() []*GoCloakMockGetRoleMappingByGroupIDParams {
	mmGetRoleMappingByGroupID.mutex.RLock()

	argCopy := make([]*GoCloakMockGetRoleMappingByGroupIDParams, len(mmGetRoleMappingByGroupID.callArgs))
	copy(argCopy, mmGetRoleMappingByGroupID.callArgs)

	mmGetRoleMappingByGroupID.mutex.RUnlock()

	return argCopy
}

// MinimockGetRoleMappingByGroupIDDone returns true if the count of the GetRoleMappingByGroupID invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockGetRoleMappingByGroupIDDone() bool {
	for _, e := range m.GetRoleMappingByGroupIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRoleMappingByGroupIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRoleMappingByGroupIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRoleMappingByGroupID != nil && mm_atomic.LoadUint64(&m.afterGetRoleMappingByGroupIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetRoleMappingByGroupIDInspect logs each unmet expectation
func (m *GoCloakMock) MinimockGetRoleMappingByGroupIDInspect() {
	for _, e := range m.GetRoleMappingByGroupIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.GetRoleMappingByGroupID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRoleMappingByGroupIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRoleMappingByGroupIDCounter) < 1 {
		if m.GetRoleMappingByGroupIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.GetRoleMappingByGroupID")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.GetRoleMappingByGroupID with params: %#v", *m.GetRoleMappingByGroupIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRoleMappingByGroupID != nil && mm_atomic.LoadUint64(&m.afterGetRoleMappingByGroupIDCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.GetRoleMappingByGroupID")
	}
}

type mGoCloakMockGetRoleMappingByUserID struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockGetRoleMappingByUserIDExpectation
	expectations       []*GoCloakMockGetRoleMappingByUserIDExpectation

	callArgs []*GoCloakMockGetRoleMappingByUserIDParams
	mutex    sync.RWMutex
}

// GoCloakMockGetRoleMappingByUserIDExpectation specifies expectation struct of the GoCloak.GetRoleMappingByUserID
type GoCloakMockGetRoleMappingByUserIDExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockGetRoleMappingByUserIDParams
	results *GoCloakMockGetRoleMappingByUserIDResults
	Counter uint64
}

// GoCloakMockGetRoleMappingByUserIDParams contains parameters of the GoCloak.GetRoleMappingByUserID
type GoCloakMockGetRoleMappingByUserIDParams struct {
	accessToken string
	realm       string
	userID      string
}

// GoCloakMockGetRoleMappingByUserIDResults contains results of the GoCloak.GetRoleMappingByUserID
type GoCloakMockGetRoleMappingByUserIDResults struct {
	rap1 *[]mm_gocloak.RoleMapping
	err  error
}

// Expect sets up expected params for GoCloak.GetRoleMappingByUserID
func (mmGetRoleMappingByUserID *mGoCloakMockGetRoleMappingByUserID) Expect(accessToken string, realm string, userID string) *mGoCloakMockGetRoleMappingByUserID {
	if mmGetRoleMappingByUserID.mock.funcGetRoleMappingByUserID != nil {
		mmGetRoleMappingByUserID.mock.t.Fatalf("GoCloakMock.GetRoleMappingByUserID mock is already set by Set")
	}

	if mmGetRoleMappingByUserID.defaultExpectation == nil {
		mmGetRoleMappingByUserID.defaultExpectation = &GoCloakMockGetRoleMappingByUserIDExpectation{}
	}

	mmGetRoleMappingByUserID.defaultExpectation.params = &GoCloakMockGetRoleMappingByUserIDParams{accessToken, realm, userID}
	for _, e := range mmGetRoleMappingByUserID.expectations {
		if minimock.Equal(e.params, mmGetRoleMappingByUserID.defaultExpectation.params) {
			mmGetRoleMappingByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRoleMappingByUserID.defaultExpectation.params)
		}
	}

	return mmGetRoleMappingByUserID
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.GetRoleMappingByUserID
func (mmGetRoleMappingByUserID *mGoCloakMockGetRoleMappingByUserID) Inspect(f func(accessToken string, realm string, userID string)) *mGoCloakMockGetRoleMappingByUserID {
	if mmGetRoleMappingByUserID.mock.inspectFuncGetRoleMappingByUserID != nil {
		mmGetRoleMappingByUserID.mock.t.Fatalf("Inspect function is already set for GoCloakMock.GetRoleMappingByUserID")
	}

	mmGetRoleMappingByUserID.mock.inspectFuncGetRoleMappingByUserID = f

	return mmGetRoleMappingByUserID
}

// Return sets up results that will be returned by GoCloak.GetRoleMappingByUserID
func (mmGetRoleMappingByUserID *mGoCloakMockGetRoleMappingByUserID) Return(rap1 *[]mm_gocloak.RoleMapping, err error) *GoCloakMock {
	if mmGetRoleMappingByUserID.mock.funcGetRoleMappingByUserID != nil {
		mmGetRoleMappingByUserID.mock.t.Fatalf("GoCloakMock.GetRoleMappingByUserID mock is already set by Set")
	}

	if mmGetRoleMappingByUserID.defaultExpectation == nil {
		mmGetRoleMappingByUserID.defaultExpectation = &GoCloakMockGetRoleMappingByUserIDExpectation{mock: mmGetRoleMappingByUserID.mock}
	}
	mmGetRoleMappingByUserID.defaultExpectation.results = &GoCloakMockGetRoleMappingByUserIDResults{rap1, err}
	return mmGetRoleMappingByUserID.mock
}

//Set uses given function f to mock the GoCloak.GetRoleMappingByUserID method
func (mmGetRoleMappingByUserID *mGoCloakMockGetRoleMappingByUserID) Set(f func(accessToken string, realm string, userID string) (rap1 *[]mm_gocloak.RoleMapping, err error)) *GoCloakMock {
	if mmGetRoleMappingByUserID.defaultExpectation != nil {
		mmGetRoleMappingByUserID.mock.t.Fatalf("Default expectation is already set for the GoCloak.GetRoleMappingByUserID method")
	}

	if len(mmGetRoleMappingByUserID.expectations) > 0 {
		mmGetRoleMappingByUserID.mock.t.Fatalf("Some expectations are already set for the GoCloak.GetRoleMappingByUserID method")
	}

	mmGetRoleMappingByUserID.mock.funcGetRoleMappingByUserID = f
	return mmGetRoleMappingByUserID.mock
}

// When sets expectation for the GoCloak.GetRoleMappingByUserID which will trigger the result defined by the following
// Then helper
func (mmGetRoleMappingByUserID *mGoCloakMockGetRoleMappingByUserID) When(accessToken string, realm string, userID string) *GoCloakMockGetRoleMappingByUserIDExpectation {
	if mmGetRoleMappingByUserID.mock.funcGetRoleMappingByUserID != nil {
		mmGetRoleMappingByUserID.mock.t.Fatalf("GoCloakMock.GetRoleMappingByUserID mock is already set by Set")
	}

	expectation := &GoCloakMockGetRoleMappingByUserIDExpectation{
		mock:   mmGetRoleMappingByUserID.mock,
		params: &GoCloakMockGetRoleMappingByUserIDParams{accessToken, realm, userID},
	}
	mmGetRoleMappingByUserID.expectations = append(mmGetRoleMappingByUserID.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.GetRoleMappingByUserID return parameters for the expectation previously defined by the When method
func (e *GoCloakMockGetRoleMappingByUserIDExpectation) Then(rap1 *[]mm_gocloak.RoleMapping, err error) *GoCloakMock {
	e.results = &GoCloakMockGetRoleMappingByUserIDResults{rap1, err}
	return e.mock
}

// GetRoleMappingByUserID implements gocloak.GoCloak
func (mmGetRoleMappingByUserID *GoCloakMock) GetRoleMappingByUserID(accessToken string, realm string, userID string) (rap1 *[]mm_gocloak.RoleMapping, err error) {
	mm_atomic.AddUint64(&mmGetRoleMappingByUserID.beforeGetRoleMappingByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRoleMappingByUserID.afterGetRoleMappingByUserIDCounter, 1)

	if mmGetRoleMappingByUserID.inspectFuncGetRoleMappingByUserID != nil {
		mmGetRoleMappingByUserID.inspectFuncGetRoleMappingByUserID(accessToken, realm, userID)
	}

	mm_params := &GoCloakMockGetRoleMappingByUserIDParams{accessToken, realm, userID}

	// Record call args
	mmGetRoleMappingByUserID.GetRoleMappingByUserIDMock.mutex.Lock()
	mmGetRoleMappingByUserID.GetRoleMappingByUserIDMock.callArgs = append(mmGetRoleMappingByUserID.GetRoleMappingByUserIDMock.callArgs, mm_params)
	mmGetRoleMappingByUserID.GetRoleMappingByUserIDMock.mutex.Unlock()

	for _, e := range mmGetRoleMappingByUserID.GetRoleMappingByUserIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rap1, e.results.err
		}
	}

	if mmGetRoleMappingByUserID.GetRoleMappingByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRoleMappingByUserID.GetRoleMappingByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRoleMappingByUserID.GetRoleMappingByUserIDMock.defaultExpectation.params
		mm_got := GoCloakMockGetRoleMappingByUserIDParams{accessToken, realm, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRoleMappingByUserID.t.Errorf("GoCloakMock.GetRoleMappingByUserID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRoleMappingByUserID.GetRoleMappingByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRoleMappingByUserID.t.Fatal("No results are set for the GoCloakMock.GetRoleMappingByUserID")
		}
		return (*mm_results).rap1, (*mm_results).err
	}
	if mmGetRoleMappingByUserID.funcGetRoleMappingByUserID != nil {
		return mmGetRoleMappingByUserID.funcGetRoleMappingByUserID(accessToken, realm, userID)
	}
	mmGetRoleMappingByUserID.t.Fatalf("Unexpected call to GoCloakMock.GetRoleMappingByUserID. %v %v %v", accessToken, realm, userID)
	return
}

// GetRoleMappingByUserIDAfterCounter returns a count of finished GoCloakMock.GetRoleMappingByUserID invocations
func (mmGetRoleMappingByUserID *GoCloakMock) GetRoleMappingByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRoleMappingByUserID.afterGetRoleMappingByUserIDCounter)
}

// GetRoleMappingByUserIDBeforeCounter returns a count of GoCloakMock.GetRoleMappingByUserID invocations
func (mmGetRoleMappingByUserID *GoCloakMock) GetRoleMappingByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRoleMappingByUserID.beforeGetRoleMappingByUserIDCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.GetRoleMappingByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRoleMappingByUserID *mGoCloakMockGetRoleMappingByUserID) Calls() []*GoCloakMockGetRoleMappingByUserIDParams {
	mmGetRoleMappingByUserID.mutex.RLock()

	argCopy := make([]*GoCloakMockGetRoleMappingByUserIDParams, len(mmGetRoleMappingByUserID.callArgs))
	copy(argCopy, mmGetRoleMappingByUserID.callArgs)

	mmGetRoleMappingByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockGetRoleMappingByUserIDDone returns true if the count of the GetRoleMappingByUserID invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockGetRoleMappingByUserIDDone() bool {
	for _, e := range m.GetRoleMappingByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRoleMappingByUserIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRoleMappingByUserIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRoleMappingByUserID != nil && mm_atomic.LoadUint64(&m.afterGetRoleMappingByUserIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetRoleMappingByUserIDInspect logs each unmet expectation
func (m *GoCloakMock) MinimockGetRoleMappingByUserIDInspect() {
	for _, e := range m.GetRoleMappingByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.GetRoleMappingByUserID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRoleMappingByUserIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRoleMappingByUserIDCounter) < 1 {
		if m.GetRoleMappingByUserIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.GetRoleMappingByUserID")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.GetRoleMappingByUserID with params: %#v", *m.GetRoleMappingByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRoleMappingByUserID != nil && mm_atomic.LoadUint64(&m.afterGetRoleMappingByUserIDCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.GetRoleMappingByUserID")
	}
}

type mGoCloakMockGetRoles struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockGetRolesExpectation
	expectations       []*GoCloakMockGetRolesExpectation

	callArgs []*GoCloakMockGetRolesParams
	mutex    sync.RWMutex
}

// GoCloakMockGetRolesExpectation specifies expectation struct of the GoCloak.GetRoles
type GoCloakMockGetRolesExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockGetRolesParams
	results *GoCloakMockGetRolesResults
	Counter uint64
}

// GoCloakMockGetRolesParams contains parameters of the GoCloak.GetRoles
type GoCloakMockGetRolesParams struct {
	accessToken string
	realm       string
}

// GoCloakMockGetRolesResults contains results of the GoCloak.GetRoles
type GoCloakMockGetRolesResults struct {
	rap1 *[]mm_gocloak.Role
	err  error
}

// Expect sets up expected params for GoCloak.GetRoles
func (mmGetRoles *mGoCloakMockGetRoles) Expect(accessToken string, realm string) *mGoCloakMockGetRoles {
	if mmGetRoles.mock.funcGetRoles != nil {
		mmGetRoles.mock.t.Fatalf("GoCloakMock.GetRoles mock is already set by Set")
	}

	if mmGetRoles.defaultExpectation == nil {
		mmGetRoles.defaultExpectation = &GoCloakMockGetRolesExpectation{}
	}

	mmGetRoles.defaultExpectation.params = &GoCloakMockGetRolesParams{accessToken, realm}
	for _, e := range mmGetRoles.expectations {
		if minimock.Equal(e.params, mmGetRoles.defaultExpectation.params) {
			mmGetRoles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRoles.defaultExpectation.params)
		}
	}

	return mmGetRoles
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.GetRoles
func (mmGetRoles *mGoCloakMockGetRoles) Inspect(f func(accessToken string, realm string)) *mGoCloakMockGetRoles {
	if mmGetRoles.mock.inspectFuncGetRoles != nil {
		mmGetRoles.mock.t.Fatalf("Inspect function is already set for GoCloakMock.GetRoles")
	}

	mmGetRoles.mock.inspectFuncGetRoles = f

	return mmGetRoles
}

// Return sets up results that will be returned by GoCloak.GetRoles
func (mmGetRoles *mGoCloakMockGetRoles) Return(rap1 *[]mm_gocloak.Role, err error) *GoCloakMock {
	if mmGetRoles.mock.funcGetRoles != nil {
		mmGetRoles.mock.t.Fatalf("GoCloakMock.GetRoles mock is already set by Set")
	}

	if mmGetRoles.defaultExpectation == nil {
		mmGetRoles.defaultExpectation = &GoCloakMockGetRolesExpectation{mock: mmGetRoles.mock}
	}
	mmGetRoles.defaultExpectation.results = &GoCloakMockGetRolesResults{rap1, err}
	return mmGetRoles.mock
}

//Set uses given function f to mock the GoCloak.GetRoles method
func (mmGetRoles *mGoCloakMockGetRoles) Set(f func(accessToken string, realm string) (rap1 *[]mm_gocloak.Role, err error)) *GoCloakMock {
	if mmGetRoles.defaultExpectation != nil {
		mmGetRoles.mock.t.Fatalf("Default expectation is already set for the GoCloak.GetRoles method")
	}

	if len(mmGetRoles.expectations) > 0 {
		mmGetRoles.mock.t.Fatalf("Some expectations are already set for the GoCloak.GetRoles method")
	}

	mmGetRoles.mock.funcGetRoles = f
	return mmGetRoles.mock
}

// When sets expectation for the GoCloak.GetRoles which will trigger the result defined by the following
// Then helper
func (mmGetRoles *mGoCloakMockGetRoles) When(accessToken string, realm string) *GoCloakMockGetRolesExpectation {
	if mmGetRoles.mock.funcGetRoles != nil {
		mmGetRoles.mock.t.Fatalf("GoCloakMock.GetRoles mock is already set by Set")
	}

	expectation := &GoCloakMockGetRolesExpectation{
		mock:   mmGetRoles.mock,
		params: &GoCloakMockGetRolesParams{accessToken, realm},
	}
	mmGetRoles.expectations = append(mmGetRoles.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.GetRoles return parameters for the expectation previously defined by the When method
func (e *GoCloakMockGetRolesExpectation) Then(rap1 *[]mm_gocloak.Role, err error) *GoCloakMock {
	e.results = &GoCloakMockGetRolesResults{rap1, err}
	return e.mock
}

// GetRoles implements gocloak.GoCloak
func (mmGetRoles *GoCloakMock) GetRoles(accessToken string, realm string) (rap1 *[]mm_gocloak.Role, err error) {
	mm_atomic.AddUint64(&mmGetRoles.beforeGetRolesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRoles.afterGetRolesCounter, 1)

	if mmGetRoles.inspectFuncGetRoles != nil {
		mmGetRoles.inspectFuncGetRoles(accessToken, realm)
	}

	mm_params := &GoCloakMockGetRolesParams{accessToken, realm}

	// Record call args
	mmGetRoles.GetRolesMock.mutex.Lock()
	mmGetRoles.GetRolesMock.callArgs = append(mmGetRoles.GetRolesMock.callArgs, mm_params)
	mmGetRoles.GetRolesMock.mutex.Unlock()

	for _, e := range mmGetRoles.GetRolesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rap1, e.results.err
		}
	}

	if mmGetRoles.GetRolesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRoles.GetRolesMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRoles.GetRolesMock.defaultExpectation.params
		mm_got := GoCloakMockGetRolesParams{accessToken, realm}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRoles.t.Errorf("GoCloakMock.GetRoles got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRoles.GetRolesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRoles.t.Fatal("No results are set for the GoCloakMock.GetRoles")
		}
		return (*mm_results).rap1, (*mm_results).err
	}
	if mmGetRoles.funcGetRoles != nil {
		return mmGetRoles.funcGetRoles(accessToken, realm)
	}
	mmGetRoles.t.Fatalf("Unexpected call to GoCloakMock.GetRoles. %v %v", accessToken, realm)
	return
}

// GetRolesAfterCounter returns a count of finished GoCloakMock.GetRoles invocations
func (mmGetRoles *GoCloakMock) GetRolesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRoles.afterGetRolesCounter)
}

// GetRolesBeforeCounter returns a count of GoCloakMock.GetRoles invocations
func (mmGetRoles *GoCloakMock) GetRolesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRoles.beforeGetRolesCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.GetRoles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRoles *mGoCloakMockGetRoles) Calls() []*GoCloakMockGetRolesParams {
	mmGetRoles.mutex.RLock()

	argCopy := make([]*GoCloakMockGetRolesParams, len(mmGetRoles.callArgs))
	copy(argCopy, mmGetRoles.callArgs)

	mmGetRoles.mutex.RUnlock()

	return argCopy
}

// MinimockGetRolesDone returns true if the count of the GetRoles invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockGetRolesDone() bool {
	for _, e := range m.GetRolesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRolesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRolesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRoles != nil && mm_atomic.LoadUint64(&m.afterGetRolesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetRolesInspect logs each unmet expectation
func (m *GoCloakMock) MinimockGetRolesInspect() {
	for _, e := range m.GetRolesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.GetRoles with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRolesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRolesCounter) < 1 {
		if m.GetRolesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.GetRoles")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.GetRoles with params: %#v", *m.GetRolesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRoles != nil && mm_atomic.LoadUint64(&m.afterGetRolesCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.GetRoles")
	}
}

type mGoCloakMockGetRolesByClientID struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockGetRolesByClientIDExpectation
	expectations       []*GoCloakMockGetRolesByClientIDExpectation

	callArgs []*GoCloakMockGetRolesByClientIDParams
	mutex    sync.RWMutex
}

// GoCloakMockGetRolesByClientIDExpectation specifies expectation struct of the GoCloak.GetRolesByClientID
type GoCloakMockGetRolesByClientIDExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockGetRolesByClientIDParams
	results *GoCloakMockGetRolesByClientIDResults
	Counter uint64
}

// GoCloakMockGetRolesByClientIDParams contains parameters of the GoCloak.GetRolesByClientID
type GoCloakMockGetRolesByClientIDParams struct {
	accessToken string
	realm       string
	clientID    string
}

// GoCloakMockGetRolesByClientIDResults contains results of the GoCloak.GetRolesByClientID
type GoCloakMockGetRolesByClientIDResults struct {
	rap1 *[]mm_gocloak.Role
	err  error
}

// Expect sets up expected params for GoCloak.GetRolesByClientID
func (mmGetRolesByClientID *mGoCloakMockGetRolesByClientID) Expect(accessToken string, realm string, clientID string) *mGoCloakMockGetRolesByClientID {
	if mmGetRolesByClientID.mock.funcGetRolesByClientID != nil {
		mmGetRolesByClientID.mock.t.Fatalf("GoCloakMock.GetRolesByClientID mock is already set by Set")
	}

	if mmGetRolesByClientID.defaultExpectation == nil {
		mmGetRolesByClientID.defaultExpectation = &GoCloakMockGetRolesByClientIDExpectation{}
	}

	mmGetRolesByClientID.defaultExpectation.params = &GoCloakMockGetRolesByClientIDParams{accessToken, realm, clientID}
	for _, e := range mmGetRolesByClientID.expectations {
		if minimock.Equal(e.params, mmGetRolesByClientID.defaultExpectation.params) {
			mmGetRolesByClientID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRolesByClientID.defaultExpectation.params)
		}
	}

	return mmGetRolesByClientID
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.GetRolesByClientID
func (mmGetRolesByClientID *mGoCloakMockGetRolesByClientID) Inspect(f func(accessToken string, realm string, clientID string)) *mGoCloakMockGetRolesByClientID {
	if mmGetRolesByClientID.mock.inspectFuncGetRolesByClientID != nil {
		mmGetRolesByClientID.mock.t.Fatalf("Inspect function is already set for GoCloakMock.GetRolesByClientID")
	}

	mmGetRolesByClientID.mock.inspectFuncGetRolesByClientID = f

	return mmGetRolesByClientID
}

// Return sets up results that will be returned by GoCloak.GetRolesByClientID
func (mmGetRolesByClientID *mGoCloakMockGetRolesByClientID) Return(rap1 *[]mm_gocloak.Role, err error) *GoCloakMock {
	if mmGetRolesByClientID.mock.funcGetRolesByClientID != nil {
		mmGetRolesByClientID.mock.t.Fatalf("GoCloakMock.GetRolesByClientID mock is already set by Set")
	}

	if mmGetRolesByClientID.defaultExpectation == nil {
		mmGetRolesByClientID.defaultExpectation = &GoCloakMockGetRolesByClientIDExpectation{mock: mmGetRolesByClientID.mock}
	}
	mmGetRolesByClientID.defaultExpectation.results = &GoCloakMockGetRolesByClientIDResults{rap1, err}
	return mmGetRolesByClientID.mock
}

//Set uses given function f to mock the GoCloak.GetRolesByClientID method
func (mmGetRolesByClientID *mGoCloakMockGetRolesByClientID) Set(f func(accessToken string, realm string, clientID string) (rap1 *[]mm_gocloak.Role, err error)) *GoCloakMock {
	if mmGetRolesByClientID.defaultExpectation != nil {
		mmGetRolesByClientID.mock.t.Fatalf("Default expectation is already set for the GoCloak.GetRolesByClientID method")
	}

	if len(mmGetRolesByClientID.expectations) > 0 {
		mmGetRolesByClientID.mock.t.Fatalf("Some expectations are already set for the GoCloak.GetRolesByClientID method")
	}

	mmGetRolesByClientID.mock.funcGetRolesByClientID = f
	return mmGetRolesByClientID.mock
}

// When sets expectation for the GoCloak.GetRolesByClientID which will trigger the result defined by the following
// Then helper
func (mmGetRolesByClientID *mGoCloakMockGetRolesByClientID) When(accessToken string, realm string, clientID string) *GoCloakMockGetRolesByClientIDExpectation {
	if mmGetRolesByClientID.mock.funcGetRolesByClientID != nil {
		mmGetRolesByClientID.mock.t.Fatalf("GoCloakMock.GetRolesByClientID mock is already set by Set")
	}

	expectation := &GoCloakMockGetRolesByClientIDExpectation{
		mock:   mmGetRolesByClientID.mock,
		params: &GoCloakMockGetRolesByClientIDParams{accessToken, realm, clientID},
	}
	mmGetRolesByClientID.expectations = append(mmGetRolesByClientID.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.GetRolesByClientID return parameters for the expectation previously defined by the When method
func (e *GoCloakMockGetRolesByClientIDExpectation) Then(rap1 *[]mm_gocloak.Role, err error) *GoCloakMock {
	e.results = &GoCloakMockGetRolesByClientIDResults{rap1, err}
	return e.mock
}

// GetRolesByClientID implements gocloak.GoCloak
func (mmGetRolesByClientID *GoCloakMock) GetRolesByClientID(accessToken string, realm string, clientID string) (rap1 *[]mm_gocloak.Role, err error) {
	mm_atomic.AddUint64(&mmGetRolesByClientID.beforeGetRolesByClientIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRolesByClientID.afterGetRolesByClientIDCounter, 1)

	if mmGetRolesByClientID.inspectFuncGetRolesByClientID != nil {
		mmGetRolesByClientID.inspectFuncGetRolesByClientID(accessToken, realm, clientID)
	}

	mm_params := &GoCloakMockGetRolesByClientIDParams{accessToken, realm, clientID}

	// Record call args
	mmGetRolesByClientID.GetRolesByClientIDMock.mutex.Lock()
	mmGetRolesByClientID.GetRolesByClientIDMock.callArgs = append(mmGetRolesByClientID.GetRolesByClientIDMock.callArgs, mm_params)
	mmGetRolesByClientID.GetRolesByClientIDMock.mutex.Unlock()

	for _, e := range mmGetRolesByClientID.GetRolesByClientIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rap1, e.results.err
		}
	}

	if mmGetRolesByClientID.GetRolesByClientIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRolesByClientID.GetRolesByClientIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRolesByClientID.GetRolesByClientIDMock.defaultExpectation.params
		mm_got := GoCloakMockGetRolesByClientIDParams{accessToken, realm, clientID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRolesByClientID.t.Errorf("GoCloakMock.GetRolesByClientID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRolesByClientID.GetRolesByClientIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRolesByClientID.t.Fatal("No results are set for the GoCloakMock.GetRolesByClientID")
		}
		return (*mm_results).rap1, (*mm_results).err
	}
	if mmGetRolesByClientID.funcGetRolesByClientID != nil {
		return mmGetRolesByClientID.funcGetRolesByClientID(accessToken, realm, clientID)
	}
	mmGetRolesByClientID.t.Fatalf("Unexpected call to GoCloakMock.GetRolesByClientID. %v %v %v", accessToken, realm, clientID)
	return
}

// GetRolesByClientIDAfterCounter returns a count of finished GoCloakMock.GetRolesByClientID invocations
func (mmGetRolesByClientID *GoCloakMock) GetRolesByClientIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRolesByClientID.afterGetRolesByClientIDCounter)
}

// GetRolesByClientIDBeforeCounter returns a count of GoCloakMock.GetRolesByClientID invocations
func (mmGetRolesByClientID *GoCloakMock) GetRolesByClientIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRolesByClientID.beforeGetRolesByClientIDCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.GetRolesByClientID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRolesByClientID *mGoCloakMockGetRolesByClientID) Calls() []*GoCloakMockGetRolesByClientIDParams {
	mmGetRolesByClientID.mutex.RLock()

	argCopy := make([]*GoCloakMockGetRolesByClientIDParams, len(mmGetRolesByClientID.callArgs))
	copy(argCopy, mmGetRolesByClientID.callArgs)

	mmGetRolesByClientID.mutex.RUnlock()

	return argCopy
}

// MinimockGetRolesByClientIDDone returns true if the count of the GetRolesByClientID invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockGetRolesByClientIDDone() bool {
	for _, e := range m.GetRolesByClientIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRolesByClientIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRolesByClientIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRolesByClientID != nil && mm_atomic.LoadUint64(&m.afterGetRolesByClientIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetRolesByClientIDInspect logs each unmet expectation
func (m *GoCloakMock) MinimockGetRolesByClientIDInspect() {
	for _, e := range m.GetRolesByClientIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.GetRolesByClientID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRolesByClientIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRolesByClientIDCounter) < 1 {
		if m.GetRolesByClientIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.GetRolesByClientID")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.GetRolesByClientID with params: %#v", *m.GetRolesByClientIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRolesByClientID != nil && mm_atomic.LoadUint64(&m.afterGetRolesByClientIDCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.GetRolesByClientID")
	}
}

type mGoCloakMockGetUserByID struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockGetUserByIDExpectation
	expectations       []*GoCloakMockGetUserByIDExpectation

	callArgs []*GoCloakMockGetUserByIDParams
	mutex    sync.RWMutex
}

// GoCloakMockGetUserByIDExpectation specifies expectation struct of the GoCloak.GetUserByID
type GoCloakMockGetUserByIDExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockGetUserByIDParams
	results *GoCloakMockGetUserByIDResults
	Counter uint64
}

// GoCloakMockGetUserByIDParams contains parameters of the GoCloak.GetUserByID
type GoCloakMockGetUserByIDParams struct {
	accessToken string
	realm       string
	userID      string
}

// GoCloakMockGetUserByIDResults contains results of the GoCloak.GetUserByID
type GoCloakMockGetUserByIDResults struct {
	up1 *mm_gocloak.User
	err error
}

// Expect sets up expected params for GoCloak.GetUserByID
func (mmGetUserByID *mGoCloakMockGetUserByID) Expect(accessToken string, realm string, userID string) *mGoCloakMockGetUserByID {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("GoCloakMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &GoCloakMockGetUserByIDExpectation{}
	}

	mmGetUserByID.defaultExpectation.params = &GoCloakMockGetUserByIDParams{accessToken, realm, userID}
	for _, e := range mmGetUserByID.expectations {
		if minimock.Equal(e.params, mmGetUserByID.defaultExpectation.params) {
			mmGetUserByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserByID.defaultExpectation.params)
		}
	}

	return mmGetUserByID
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.GetUserByID
func (mmGetUserByID *mGoCloakMockGetUserByID) Inspect(f func(accessToken string, realm string, userID string)) *mGoCloakMockGetUserByID {
	if mmGetUserByID.mock.inspectFuncGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("Inspect function is already set for GoCloakMock.GetUserByID")
	}

	mmGetUserByID.mock.inspectFuncGetUserByID = f

	return mmGetUserByID
}

// Return sets up results that will be returned by GoCloak.GetUserByID
func (mmGetUserByID *mGoCloakMockGetUserByID) Return(up1 *mm_gocloak.User, err error) *GoCloakMock {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("GoCloakMock.GetUserByID mock is already set by Set")
	}

	if mmGetUserByID.defaultExpectation == nil {
		mmGetUserByID.defaultExpectation = &GoCloakMockGetUserByIDExpectation{mock: mmGetUserByID.mock}
	}
	mmGetUserByID.defaultExpectation.results = &GoCloakMockGetUserByIDResults{up1, err}
	return mmGetUserByID.mock
}

//Set uses given function f to mock the GoCloak.GetUserByID method
func (mmGetUserByID *mGoCloakMockGetUserByID) Set(f func(accessToken string, realm string, userID string) (up1 *mm_gocloak.User, err error)) *GoCloakMock {
	if mmGetUserByID.defaultExpectation != nil {
		mmGetUserByID.mock.t.Fatalf("Default expectation is already set for the GoCloak.GetUserByID method")
	}

	if len(mmGetUserByID.expectations) > 0 {
		mmGetUserByID.mock.t.Fatalf("Some expectations are already set for the GoCloak.GetUserByID method")
	}

	mmGetUserByID.mock.funcGetUserByID = f
	return mmGetUserByID.mock
}

// When sets expectation for the GoCloak.GetUserByID which will trigger the result defined by the following
// Then helper
func (mmGetUserByID *mGoCloakMockGetUserByID) When(accessToken string, realm string, userID string) *GoCloakMockGetUserByIDExpectation {
	if mmGetUserByID.mock.funcGetUserByID != nil {
		mmGetUserByID.mock.t.Fatalf("GoCloakMock.GetUserByID mock is already set by Set")
	}

	expectation := &GoCloakMockGetUserByIDExpectation{
		mock:   mmGetUserByID.mock,
		params: &GoCloakMockGetUserByIDParams{accessToken, realm, userID},
	}
	mmGetUserByID.expectations = append(mmGetUserByID.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.GetUserByID return parameters for the expectation previously defined by the When method
func (e *GoCloakMockGetUserByIDExpectation) Then(up1 *mm_gocloak.User, err error) *GoCloakMock {
	e.results = &GoCloakMockGetUserByIDResults{up1, err}
	return e.mock
}

// GetUserByID implements gocloak.GoCloak
func (mmGetUserByID *GoCloakMock) GetUserByID(accessToken string, realm string, userID string) (up1 *mm_gocloak.User, err error) {
	mm_atomic.AddUint64(&mmGetUserByID.beforeGetUserByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserByID.afterGetUserByIDCounter, 1)

	if mmGetUserByID.inspectFuncGetUserByID != nil {
		mmGetUserByID.inspectFuncGetUserByID(accessToken, realm, userID)
	}

	mm_params := &GoCloakMockGetUserByIDParams{accessToken, realm, userID}

	// Record call args
	mmGetUserByID.GetUserByIDMock.mutex.Lock()
	mmGetUserByID.GetUserByIDMock.callArgs = append(mmGetUserByID.GetUserByIDMock.callArgs, mm_params)
	mmGetUserByID.GetUserByIDMock.mutex.Unlock()

	for _, e := range mmGetUserByID.GetUserByIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUserByID.GetUserByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserByID.GetUserByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserByID.GetUserByIDMock.defaultExpectation.params
		mm_got := GoCloakMockGetUserByIDParams{accessToken, realm, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserByID.t.Errorf("GoCloakMock.GetUserByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserByID.GetUserByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserByID.t.Fatal("No results are set for the GoCloakMock.GetUserByID")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUserByID.funcGetUserByID != nil {
		return mmGetUserByID.funcGetUserByID(accessToken, realm, userID)
	}
	mmGetUserByID.t.Fatalf("Unexpected call to GoCloakMock.GetUserByID. %v %v %v", accessToken, realm, userID)
	return
}

// GetUserByIDAfterCounter returns a count of finished GoCloakMock.GetUserByID invocations
func (mmGetUserByID *GoCloakMock) GetUserByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByID.afterGetUserByIDCounter)
}

// GetUserByIDBeforeCounter returns a count of GoCloakMock.GetUserByID invocations
func (mmGetUserByID *GoCloakMock) GetUserByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByID.beforeGetUserByIDCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.GetUserByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserByID *mGoCloakMockGetUserByID) Calls() []*GoCloakMockGetUserByIDParams {
	mmGetUserByID.mutex.RLock()

	argCopy := make([]*GoCloakMockGetUserByIDParams, len(mmGetUserByID.callArgs))
	copy(argCopy, mmGetUserByID.callArgs)

	mmGetUserByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserByIDDone returns true if the count of the GetUserByID invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockGetUserByIDDone() bool {
	for _, e := range m.GetUserByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserByIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByID != nil && mm_atomic.LoadUint64(&m.afterGetUserByIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetUserByIDInspect logs each unmet expectation
func (m *GoCloakMock) MinimockGetUserByIDInspect() {
	for _, e := range m.GetUserByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.GetUserByID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserByIDCounter) < 1 {
		if m.GetUserByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.GetUserByID")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.GetUserByID with params: %#v", *m.GetUserByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByID != nil && mm_atomic.LoadUint64(&m.afterGetUserByIDCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.GetUserByID")
	}
}

type mGoCloakMockGetUserCount struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockGetUserCountExpectation
	expectations       []*GoCloakMockGetUserCountExpectation

	callArgs []*GoCloakMockGetUserCountParams
	mutex    sync.RWMutex
}

// GoCloakMockGetUserCountExpectation specifies expectation struct of the GoCloak.GetUserCount
type GoCloakMockGetUserCountExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockGetUserCountParams
	results *GoCloakMockGetUserCountResults
	Counter uint64
}

// GoCloakMockGetUserCountParams contains parameters of the GoCloak.GetUserCount
type GoCloakMockGetUserCountParams struct {
	accessToken string
	realm       string
}

// GoCloakMockGetUserCountResults contains results of the GoCloak.GetUserCount
type GoCloakMockGetUserCountResults struct {
	i1  int
	err error
}

// Expect sets up expected params for GoCloak.GetUserCount
func (mmGetUserCount *mGoCloakMockGetUserCount) Expect(accessToken string, realm string) *mGoCloakMockGetUserCount {
	if mmGetUserCount.mock.funcGetUserCount != nil {
		mmGetUserCount.mock.t.Fatalf("GoCloakMock.GetUserCount mock is already set by Set")
	}

	if mmGetUserCount.defaultExpectation == nil {
		mmGetUserCount.defaultExpectation = &GoCloakMockGetUserCountExpectation{}
	}

	mmGetUserCount.defaultExpectation.params = &GoCloakMockGetUserCountParams{accessToken, realm}
	for _, e := range mmGetUserCount.expectations {
		if minimock.Equal(e.params, mmGetUserCount.defaultExpectation.params) {
			mmGetUserCount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserCount.defaultExpectation.params)
		}
	}

	return mmGetUserCount
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.GetUserCount
func (mmGetUserCount *mGoCloakMockGetUserCount) Inspect(f func(accessToken string, realm string)) *mGoCloakMockGetUserCount {
	if mmGetUserCount.mock.inspectFuncGetUserCount != nil {
		mmGetUserCount.mock.t.Fatalf("Inspect function is already set for GoCloakMock.GetUserCount")
	}

	mmGetUserCount.mock.inspectFuncGetUserCount = f

	return mmGetUserCount
}

// Return sets up results that will be returned by GoCloak.GetUserCount
func (mmGetUserCount *mGoCloakMockGetUserCount) Return(i1 int, err error) *GoCloakMock {
	if mmGetUserCount.mock.funcGetUserCount != nil {
		mmGetUserCount.mock.t.Fatalf("GoCloakMock.GetUserCount mock is already set by Set")
	}

	if mmGetUserCount.defaultExpectation == nil {
		mmGetUserCount.defaultExpectation = &GoCloakMockGetUserCountExpectation{mock: mmGetUserCount.mock}
	}
	mmGetUserCount.defaultExpectation.results = &GoCloakMockGetUserCountResults{i1, err}
	return mmGetUserCount.mock
}

//Set uses given function f to mock the GoCloak.GetUserCount method
func (mmGetUserCount *mGoCloakMockGetUserCount) Set(f func(accessToken string, realm string) (i1 int, err error)) *GoCloakMock {
	if mmGetUserCount.defaultExpectation != nil {
		mmGetUserCount.mock.t.Fatalf("Default expectation is already set for the GoCloak.GetUserCount method")
	}

	if len(mmGetUserCount.expectations) > 0 {
		mmGetUserCount.mock.t.Fatalf("Some expectations are already set for the GoCloak.GetUserCount method")
	}

	mmGetUserCount.mock.funcGetUserCount = f
	return mmGetUserCount.mock
}

// When sets expectation for the GoCloak.GetUserCount which will trigger the result defined by the following
// Then helper
func (mmGetUserCount *mGoCloakMockGetUserCount) When(accessToken string, realm string) *GoCloakMockGetUserCountExpectation {
	if mmGetUserCount.mock.funcGetUserCount != nil {
		mmGetUserCount.mock.t.Fatalf("GoCloakMock.GetUserCount mock is already set by Set")
	}

	expectation := &GoCloakMockGetUserCountExpectation{
		mock:   mmGetUserCount.mock,
		params: &GoCloakMockGetUserCountParams{accessToken, realm},
	}
	mmGetUserCount.expectations = append(mmGetUserCount.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.GetUserCount return parameters for the expectation previously defined by the When method
func (e *GoCloakMockGetUserCountExpectation) Then(i1 int, err error) *GoCloakMock {
	e.results = &GoCloakMockGetUserCountResults{i1, err}
	return e.mock
}

// GetUserCount implements gocloak.GoCloak
func (mmGetUserCount *GoCloakMock) GetUserCount(accessToken string, realm string) (i1 int, err error) {
	mm_atomic.AddUint64(&mmGetUserCount.beforeGetUserCountCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserCount.afterGetUserCountCounter, 1)

	if mmGetUserCount.inspectFuncGetUserCount != nil {
		mmGetUserCount.inspectFuncGetUserCount(accessToken, realm)
	}

	mm_params := &GoCloakMockGetUserCountParams{accessToken, realm}

	// Record call args
	mmGetUserCount.GetUserCountMock.mutex.Lock()
	mmGetUserCount.GetUserCountMock.callArgs = append(mmGetUserCount.GetUserCountMock.callArgs, mm_params)
	mmGetUserCount.GetUserCountMock.mutex.Unlock()

	for _, e := range mmGetUserCount.GetUserCountMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetUserCount.GetUserCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserCount.GetUserCountMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserCount.GetUserCountMock.defaultExpectation.params
		mm_got := GoCloakMockGetUserCountParams{accessToken, realm}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserCount.t.Errorf("GoCloakMock.GetUserCount got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserCount.GetUserCountMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserCount.t.Fatal("No results are set for the GoCloakMock.GetUserCount")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetUserCount.funcGetUserCount != nil {
		return mmGetUserCount.funcGetUserCount(accessToken, realm)
	}
	mmGetUserCount.t.Fatalf("Unexpected call to GoCloakMock.GetUserCount. %v %v", accessToken, realm)
	return
}

// GetUserCountAfterCounter returns a count of finished GoCloakMock.GetUserCount invocations
func (mmGetUserCount *GoCloakMock) GetUserCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserCount.afterGetUserCountCounter)
}

// GetUserCountBeforeCounter returns a count of GoCloakMock.GetUserCount invocations
func (mmGetUserCount *GoCloakMock) GetUserCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserCount.beforeGetUserCountCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.GetUserCount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserCount *mGoCloakMockGetUserCount) Calls() []*GoCloakMockGetUserCountParams {
	mmGetUserCount.mutex.RLock()

	argCopy := make([]*GoCloakMockGetUserCountParams, len(mmGetUserCount.callArgs))
	copy(argCopy, mmGetUserCount.callArgs)

	mmGetUserCount.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserCountDone returns true if the count of the GetUserCount invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockGetUserCountDone() bool {
	for _, e := range m.GetUserCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserCountCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserCount != nil && mm_atomic.LoadUint64(&m.afterGetUserCountCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetUserCountInspect logs each unmet expectation
func (m *GoCloakMock) MinimockGetUserCountInspect() {
	for _, e := range m.GetUserCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.GetUserCount with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserCountCounter) < 1 {
		if m.GetUserCountMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.GetUserCount")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.GetUserCount with params: %#v", *m.GetUserCountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserCount != nil && mm_atomic.LoadUint64(&m.afterGetUserCountCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.GetUserCount")
	}
}

type mGoCloakMockGetUserGroups struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockGetUserGroupsExpectation
	expectations       []*GoCloakMockGetUserGroupsExpectation

	callArgs []*GoCloakMockGetUserGroupsParams
	mutex    sync.RWMutex
}

// GoCloakMockGetUserGroupsExpectation specifies expectation struct of the GoCloak.GetUserGroups
type GoCloakMockGetUserGroupsExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockGetUserGroupsParams
	results *GoCloakMockGetUserGroupsResults
	Counter uint64
}

// GoCloakMockGetUserGroupsParams contains parameters of the GoCloak.GetUserGroups
type GoCloakMockGetUserGroupsParams struct {
	accessToken string
	realm       string
	userID      string
}

// GoCloakMockGetUserGroupsResults contains results of the GoCloak.GetUserGroups
type GoCloakMockGetUserGroupsResults struct {
	uap1 *[]mm_gocloak.UserGroup
	err  error
}

// Expect sets up expected params for GoCloak.GetUserGroups
func (mmGetUserGroups *mGoCloakMockGetUserGroups) Expect(accessToken string, realm string, userID string) *mGoCloakMockGetUserGroups {
	if mmGetUserGroups.mock.funcGetUserGroups != nil {
		mmGetUserGroups.mock.t.Fatalf("GoCloakMock.GetUserGroups mock is already set by Set")
	}

	if mmGetUserGroups.defaultExpectation == nil {
		mmGetUserGroups.defaultExpectation = &GoCloakMockGetUserGroupsExpectation{}
	}

	mmGetUserGroups.defaultExpectation.params = &GoCloakMockGetUserGroupsParams{accessToken, realm, userID}
	for _, e := range mmGetUserGroups.expectations {
		if minimock.Equal(e.params, mmGetUserGroups.defaultExpectation.params) {
			mmGetUserGroups.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserGroups.defaultExpectation.params)
		}
	}

	return mmGetUserGroups
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.GetUserGroups
func (mmGetUserGroups *mGoCloakMockGetUserGroups) Inspect(f func(accessToken string, realm string, userID string)) *mGoCloakMockGetUserGroups {
	if mmGetUserGroups.mock.inspectFuncGetUserGroups != nil {
		mmGetUserGroups.mock.t.Fatalf("Inspect function is already set for GoCloakMock.GetUserGroups")
	}

	mmGetUserGroups.mock.inspectFuncGetUserGroups = f

	return mmGetUserGroups
}

// Return sets up results that will be returned by GoCloak.GetUserGroups
func (mmGetUserGroups *mGoCloakMockGetUserGroups) Return(uap1 *[]mm_gocloak.UserGroup, err error) *GoCloakMock {
	if mmGetUserGroups.mock.funcGetUserGroups != nil {
		mmGetUserGroups.mock.t.Fatalf("GoCloakMock.GetUserGroups mock is already set by Set")
	}

	if mmGetUserGroups.defaultExpectation == nil {
		mmGetUserGroups.defaultExpectation = &GoCloakMockGetUserGroupsExpectation{mock: mmGetUserGroups.mock}
	}
	mmGetUserGroups.defaultExpectation.results = &GoCloakMockGetUserGroupsResults{uap1, err}
	return mmGetUserGroups.mock
}

//Set uses given function f to mock the GoCloak.GetUserGroups method
func (mmGetUserGroups *mGoCloakMockGetUserGroups) Set(f func(accessToken string, realm string, userID string) (uap1 *[]mm_gocloak.UserGroup, err error)) *GoCloakMock {
	if mmGetUserGroups.defaultExpectation != nil {
		mmGetUserGroups.mock.t.Fatalf("Default expectation is already set for the GoCloak.GetUserGroups method")
	}

	if len(mmGetUserGroups.expectations) > 0 {
		mmGetUserGroups.mock.t.Fatalf("Some expectations are already set for the GoCloak.GetUserGroups method")
	}

	mmGetUserGroups.mock.funcGetUserGroups = f
	return mmGetUserGroups.mock
}

// When sets expectation for the GoCloak.GetUserGroups which will trigger the result defined by the following
// Then helper
func (mmGetUserGroups *mGoCloakMockGetUserGroups) When(accessToken string, realm string, userID string) *GoCloakMockGetUserGroupsExpectation {
	if mmGetUserGroups.mock.funcGetUserGroups != nil {
		mmGetUserGroups.mock.t.Fatalf("GoCloakMock.GetUserGroups mock is already set by Set")
	}

	expectation := &GoCloakMockGetUserGroupsExpectation{
		mock:   mmGetUserGroups.mock,
		params: &GoCloakMockGetUserGroupsParams{accessToken, realm, userID},
	}
	mmGetUserGroups.expectations = append(mmGetUserGroups.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.GetUserGroups return parameters for the expectation previously defined by the When method
func (e *GoCloakMockGetUserGroupsExpectation) Then(uap1 *[]mm_gocloak.UserGroup, err error) *GoCloakMock {
	e.results = &GoCloakMockGetUserGroupsResults{uap1, err}
	return e.mock
}

// GetUserGroups implements gocloak.GoCloak
func (mmGetUserGroups *GoCloakMock) GetUserGroups(accessToken string, realm string, userID string) (uap1 *[]mm_gocloak.UserGroup, err error) {
	mm_atomic.AddUint64(&mmGetUserGroups.beforeGetUserGroupsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserGroups.afterGetUserGroupsCounter, 1)

	if mmGetUserGroups.inspectFuncGetUserGroups != nil {
		mmGetUserGroups.inspectFuncGetUserGroups(accessToken, realm, userID)
	}

	mm_params := &GoCloakMockGetUserGroupsParams{accessToken, realm, userID}

	// Record call args
	mmGetUserGroups.GetUserGroupsMock.mutex.Lock()
	mmGetUserGroups.GetUserGroupsMock.callArgs = append(mmGetUserGroups.GetUserGroupsMock.callArgs, mm_params)
	mmGetUserGroups.GetUserGroupsMock.mutex.Unlock()

	for _, e := range mmGetUserGroups.GetUserGroupsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.uap1, e.results.err
		}
	}

	if mmGetUserGroups.GetUserGroupsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserGroups.GetUserGroupsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserGroups.GetUserGroupsMock.defaultExpectation.params
		mm_got := GoCloakMockGetUserGroupsParams{accessToken, realm, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserGroups.t.Errorf("GoCloakMock.GetUserGroups got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserGroups.GetUserGroupsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserGroups.t.Fatal("No results are set for the GoCloakMock.GetUserGroups")
		}
		return (*mm_results).uap1, (*mm_results).err
	}
	if mmGetUserGroups.funcGetUserGroups != nil {
		return mmGetUserGroups.funcGetUserGroups(accessToken, realm, userID)
	}
	mmGetUserGroups.t.Fatalf("Unexpected call to GoCloakMock.GetUserGroups. %v %v %v", accessToken, realm, userID)
	return
}

// GetUserGroupsAfterCounter returns a count of finished GoCloakMock.GetUserGroups invocations
func (mmGetUserGroups *GoCloakMock) GetUserGroupsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserGroups.afterGetUserGroupsCounter)
}

// GetUserGroupsBeforeCounter returns a count of GoCloakMock.GetUserGroups invocations
func (mmGetUserGroups *GoCloakMock) GetUserGroupsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserGroups.beforeGetUserGroupsCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.GetUserGroups.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserGroups *mGoCloakMockGetUserGroups) Calls() []*GoCloakMockGetUserGroupsParams {
	mmGetUserGroups.mutex.RLock()

	argCopy := make([]*GoCloakMockGetUserGroupsParams, len(mmGetUserGroups.callArgs))
	copy(argCopy, mmGetUserGroups.callArgs)

	mmGetUserGroups.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserGroupsDone returns true if the count of the GetUserGroups invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockGetUserGroupsDone() bool {
	for _, e := range m.GetUserGroupsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserGroupsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserGroupsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserGroups != nil && mm_atomic.LoadUint64(&m.afterGetUserGroupsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetUserGroupsInspect logs each unmet expectation
func (m *GoCloakMock) MinimockGetUserGroupsInspect() {
	for _, e := range m.GetUserGroupsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.GetUserGroups with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserGroupsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserGroupsCounter) < 1 {
		if m.GetUserGroupsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.GetUserGroups")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.GetUserGroups with params: %#v", *m.GetUserGroupsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserGroups != nil && mm_atomic.LoadUint64(&m.afterGetUserGroupsCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.GetUserGroups")
	}
}

type mGoCloakMockGetUsers struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockGetUsersExpectation
	expectations       []*GoCloakMockGetUsersExpectation

	callArgs []*GoCloakMockGetUsersParams
	mutex    sync.RWMutex
}

// GoCloakMockGetUsersExpectation specifies expectation struct of the GoCloak.GetUsers
type GoCloakMockGetUsersExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockGetUsersParams
	results *GoCloakMockGetUsersResults
	Counter uint64
}

// GoCloakMockGetUsersParams contains parameters of the GoCloak.GetUsers
type GoCloakMockGetUsersParams struct {
	accessToken string
	realm       string
}

// GoCloakMockGetUsersResults contains results of the GoCloak.GetUsers
type GoCloakMockGetUsersResults struct {
	uap1 *[]mm_gocloak.User
	err  error
}

// Expect sets up expected params for GoCloak.GetUsers
func (mmGetUsers *mGoCloakMockGetUsers) Expect(accessToken string, realm string) *mGoCloakMockGetUsers {
	if mmGetUsers.mock.funcGetUsers != nil {
		mmGetUsers.mock.t.Fatalf("GoCloakMock.GetUsers mock is already set by Set")
	}

	if mmGetUsers.defaultExpectation == nil {
		mmGetUsers.defaultExpectation = &GoCloakMockGetUsersExpectation{}
	}

	mmGetUsers.defaultExpectation.params = &GoCloakMockGetUsersParams{accessToken, realm}
	for _, e := range mmGetUsers.expectations {
		if minimock.Equal(e.params, mmGetUsers.defaultExpectation.params) {
			mmGetUsers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUsers.defaultExpectation.params)
		}
	}

	return mmGetUsers
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.GetUsers
func (mmGetUsers *mGoCloakMockGetUsers) Inspect(f func(accessToken string, realm string)) *mGoCloakMockGetUsers {
	if mmGetUsers.mock.inspectFuncGetUsers != nil {
		mmGetUsers.mock.t.Fatalf("Inspect function is already set for GoCloakMock.GetUsers")
	}

	mmGetUsers.mock.inspectFuncGetUsers = f

	return mmGetUsers
}

// Return sets up results that will be returned by GoCloak.GetUsers
func (mmGetUsers *mGoCloakMockGetUsers) Return(uap1 *[]mm_gocloak.User, err error) *GoCloakMock {
	if mmGetUsers.mock.funcGetUsers != nil {
		mmGetUsers.mock.t.Fatalf("GoCloakMock.GetUsers mock is already set by Set")
	}

	if mmGetUsers.defaultExpectation == nil {
		mmGetUsers.defaultExpectation = &GoCloakMockGetUsersExpectation{mock: mmGetUsers.mock}
	}
	mmGetUsers.defaultExpectation.results = &GoCloakMockGetUsersResults{uap1, err}
	return mmGetUsers.mock
}

//Set uses given function f to mock the GoCloak.GetUsers method
func (mmGetUsers *mGoCloakMockGetUsers) Set(f func(accessToken string, realm string) (uap1 *[]mm_gocloak.User, err error)) *GoCloakMock {
	if mmGetUsers.defaultExpectation != nil {
		mmGetUsers.mock.t.Fatalf("Default expectation is already set for the GoCloak.GetUsers method")
	}

	if len(mmGetUsers.expectations) > 0 {
		mmGetUsers.mock.t.Fatalf("Some expectations are already set for the GoCloak.GetUsers method")
	}

	mmGetUsers.mock.funcGetUsers = f
	return mmGetUsers.mock
}

// When sets expectation for the GoCloak.GetUsers which will trigger the result defined by the following
// Then helper
func (mmGetUsers *mGoCloakMockGetUsers) When(accessToken string, realm string) *GoCloakMockGetUsersExpectation {
	if mmGetUsers.mock.funcGetUsers != nil {
		mmGetUsers.mock.t.Fatalf("GoCloakMock.GetUsers mock is already set by Set")
	}

	expectation := &GoCloakMockGetUsersExpectation{
		mock:   mmGetUsers.mock,
		params: &GoCloakMockGetUsersParams{accessToken, realm},
	}
	mmGetUsers.expectations = append(mmGetUsers.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.GetUsers return parameters for the expectation previously defined by the When method
func (e *GoCloakMockGetUsersExpectation) Then(uap1 *[]mm_gocloak.User, err error) *GoCloakMock {
	e.results = &GoCloakMockGetUsersResults{uap1, err}
	return e.mock
}

// GetUsers implements gocloak.GoCloak
func (mmGetUsers *GoCloakMock) GetUsers(accessToken string, realm string) (uap1 *[]mm_gocloak.User, err error) {
	mm_atomic.AddUint64(&mmGetUsers.beforeGetUsersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUsers.afterGetUsersCounter, 1)

	if mmGetUsers.inspectFuncGetUsers != nil {
		mmGetUsers.inspectFuncGetUsers(accessToken, realm)
	}

	mm_params := &GoCloakMockGetUsersParams{accessToken, realm}

	// Record call args
	mmGetUsers.GetUsersMock.mutex.Lock()
	mmGetUsers.GetUsersMock.callArgs = append(mmGetUsers.GetUsersMock.callArgs, mm_params)
	mmGetUsers.GetUsersMock.mutex.Unlock()

	for _, e := range mmGetUsers.GetUsersMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.uap1, e.results.err
		}
	}

	if mmGetUsers.GetUsersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUsers.GetUsersMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUsers.GetUsersMock.defaultExpectation.params
		mm_got := GoCloakMockGetUsersParams{accessToken, realm}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUsers.t.Errorf("GoCloakMock.GetUsers got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUsers.GetUsersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUsers.t.Fatal("No results are set for the GoCloakMock.GetUsers")
		}
		return (*mm_results).uap1, (*mm_results).err
	}
	if mmGetUsers.funcGetUsers != nil {
		return mmGetUsers.funcGetUsers(accessToken, realm)
	}
	mmGetUsers.t.Fatalf("Unexpected call to GoCloakMock.GetUsers. %v %v", accessToken, realm)
	return
}

// GetUsersAfterCounter returns a count of finished GoCloakMock.GetUsers invocations
func (mmGetUsers *GoCloakMock) GetUsersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUsers.afterGetUsersCounter)
}

// GetUsersBeforeCounter returns a count of GoCloakMock.GetUsers invocations
func (mmGetUsers *GoCloakMock) GetUsersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUsers.beforeGetUsersCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.GetUsers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUsers *mGoCloakMockGetUsers) Calls() []*GoCloakMockGetUsersParams {
	mmGetUsers.mutex.RLock()

	argCopy := make([]*GoCloakMockGetUsersParams, len(mmGetUsers.callArgs))
	copy(argCopy, mmGetUsers.callArgs)

	mmGetUsers.mutex.RUnlock()

	return argCopy
}

// MinimockGetUsersDone returns true if the count of the GetUsers invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockGetUsersDone() bool {
	for _, e := range m.GetUsersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUsersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUsersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUsers != nil && mm_atomic.LoadUint64(&m.afterGetUsersCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetUsersInspect logs each unmet expectation
func (m *GoCloakMock) MinimockGetUsersInspect() {
	for _, e := range m.GetUsersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.GetUsers with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUsersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUsersCounter) < 1 {
		if m.GetUsersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.GetUsers")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.GetUsers with params: %#v", *m.GetUsersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUsers != nil && mm_atomic.LoadUint64(&m.afterGetUsersCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.GetUsers")
	}
}

type mGoCloakMockGetUsersByRoleName struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockGetUsersByRoleNameExpectation
	expectations       []*GoCloakMockGetUsersByRoleNameExpectation

	callArgs []*GoCloakMockGetUsersByRoleNameParams
	mutex    sync.RWMutex
}

// GoCloakMockGetUsersByRoleNameExpectation specifies expectation struct of the GoCloak.GetUsersByRoleName
type GoCloakMockGetUsersByRoleNameExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockGetUsersByRoleNameParams
	results *GoCloakMockGetUsersByRoleNameResults
	Counter uint64
}

// GoCloakMockGetUsersByRoleNameParams contains parameters of the GoCloak.GetUsersByRoleName
type GoCloakMockGetUsersByRoleNameParams struct {
	token    string
	realm    string
	roleName string
}

// GoCloakMockGetUsersByRoleNameResults contains results of the GoCloak.GetUsersByRoleName
type GoCloakMockGetUsersByRoleNameResults struct {
	uap1 *[]mm_gocloak.User
	err  error
}

// Expect sets up expected params for GoCloak.GetUsersByRoleName
func (mmGetUsersByRoleName *mGoCloakMockGetUsersByRoleName) Expect(token string, realm string, roleName string) *mGoCloakMockGetUsersByRoleName {
	if mmGetUsersByRoleName.mock.funcGetUsersByRoleName != nil {
		mmGetUsersByRoleName.mock.t.Fatalf("GoCloakMock.GetUsersByRoleName mock is already set by Set")
	}

	if mmGetUsersByRoleName.defaultExpectation == nil {
		mmGetUsersByRoleName.defaultExpectation = &GoCloakMockGetUsersByRoleNameExpectation{}
	}

	mmGetUsersByRoleName.defaultExpectation.params = &GoCloakMockGetUsersByRoleNameParams{token, realm, roleName}
	for _, e := range mmGetUsersByRoleName.expectations {
		if minimock.Equal(e.params, mmGetUsersByRoleName.defaultExpectation.params) {
			mmGetUsersByRoleName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUsersByRoleName.defaultExpectation.params)
		}
	}

	return mmGetUsersByRoleName
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.GetUsersByRoleName
func (mmGetUsersByRoleName *mGoCloakMockGetUsersByRoleName) Inspect(f func(token string, realm string, roleName string)) *mGoCloakMockGetUsersByRoleName {
	if mmGetUsersByRoleName.mock.inspectFuncGetUsersByRoleName != nil {
		mmGetUsersByRoleName.mock.t.Fatalf("Inspect function is already set for GoCloakMock.GetUsersByRoleName")
	}

	mmGetUsersByRoleName.mock.inspectFuncGetUsersByRoleName = f

	return mmGetUsersByRoleName
}

// Return sets up results that will be returned by GoCloak.GetUsersByRoleName
func (mmGetUsersByRoleName *mGoCloakMockGetUsersByRoleName) Return(uap1 *[]mm_gocloak.User, err error) *GoCloakMock {
	if mmGetUsersByRoleName.mock.funcGetUsersByRoleName != nil {
		mmGetUsersByRoleName.mock.t.Fatalf("GoCloakMock.GetUsersByRoleName mock is already set by Set")
	}

	if mmGetUsersByRoleName.defaultExpectation == nil {
		mmGetUsersByRoleName.defaultExpectation = &GoCloakMockGetUsersByRoleNameExpectation{mock: mmGetUsersByRoleName.mock}
	}
	mmGetUsersByRoleName.defaultExpectation.results = &GoCloakMockGetUsersByRoleNameResults{uap1, err}
	return mmGetUsersByRoleName.mock
}

//Set uses given function f to mock the GoCloak.GetUsersByRoleName method
func (mmGetUsersByRoleName *mGoCloakMockGetUsersByRoleName) Set(f func(token string, realm string, roleName string) (uap1 *[]mm_gocloak.User, err error)) *GoCloakMock {
	if mmGetUsersByRoleName.defaultExpectation != nil {
		mmGetUsersByRoleName.mock.t.Fatalf("Default expectation is already set for the GoCloak.GetUsersByRoleName method")
	}

	if len(mmGetUsersByRoleName.expectations) > 0 {
		mmGetUsersByRoleName.mock.t.Fatalf("Some expectations are already set for the GoCloak.GetUsersByRoleName method")
	}

	mmGetUsersByRoleName.mock.funcGetUsersByRoleName = f
	return mmGetUsersByRoleName.mock
}

// When sets expectation for the GoCloak.GetUsersByRoleName which will trigger the result defined by the following
// Then helper
func (mmGetUsersByRoleName *mGoCloakMockGetUsersByRoleName) When(token string, realm string, roleName string) *GoCloakMockGetUsersByRoleNameExpectation {
	if mmGetUsersByRoleName.mock.funcGetUsersByRoleName != nil {
		mmGetUsersByRoleName.mock.t.Fatalf("GoCloakMock.GetUsersByRoleName mock is already set by Set")
	}

	expectation := &GoCloakMockGetUsersByRoleNameExpectation{
		mock:   mmGetUsersByRoleName.mock,
		params: &GoCloakMockGetUsersByRoleNameParams{token, realm, roleName},
	}
	mmGetUsersByRoleName.expectations = append(mmGetUsersByRoleName.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.GetUsersByRoleName return parameters for the expectation previously defined by the When method
func (e *GoCloakMockGetUsersByRoleNameExpectation) Then(uap1 *[]mm_gocloak.User, err error) *GoCloakMock {
	e.results = &GoCloakMockGetUsersByRoleNameResults{uap1, err}
	return e.mock
}

// GetUsersByRoleName implements gocloak.GoCloak
func (mmGetUsersByRoleName *GoCloakMock) GetUsersByRoleName(token string, realm string, roleName string) (uap1 *[]mm_gocloak.User, err error) {
	mm_atomic.AddUint64(&mmGetUsersByRoleName.beforeGetUsersByRoleNameCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUsersByRoleName.afterGetUsersByRoleNameCounter, 1)

	if mmGetUsersByRoleName.inspectFuncGetUsersByRoleName != nil {
		mmGetUsersByRoleName.inspectFuncGetUsersByRoleName(token, realm, roleName)
	}

	mm_params := &GoCloakMockGetUsersByRoleNameParams{token, realm, roleName}

	// Record call args
	mmGetUsersByRoleName.GetUsersByRoleNameMock.mutex.Lock()
	mmGetUsersByRoleName.GetUsersByRoleNameMock.callArgs = append(mmGetUsersByRoleName.GetUsersByRoleNameMock.callArgs, mm_params)
	mmGetUsersByRoleName.GetUsersByRoleNameMock.mutex.Unlock()

	for _, e := range mmGetUsersByRoleName.GetUsersByRoleNameMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.uap1, e.results.err
		}
	}

	if mmGetUsersByRoleName.GetUsersByRoleNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUsersByRoleName.GetUsersByRoleNameMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUsersByRoleName.GetUsersByRoleNameMock.defaultExpectation.params
		mm_got := GoCloakMockGetUsersByRoleNameParams{token, realm, roleName}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUsersByRoleName.t.Errorf("GoCloakMock.GetUsersByRoleName got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUsersByRoleName.GetUsersByRoleNameMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUsersByRoleName.t.Fatal("No results are set for the GoCloakMock.GetUsersByRoleName")
		}
		return (*mm_results).uap1, (*mm_results).err
	}
	if mmGetUsersByRoleName.funcGetUsersByRoleName != nil {
		return mmGetUsersByRoleName.funcGetUsersByRoleName(token, realm, roleName)
	}
	mmGetUsersByRoleName.t.Fatalf("Unexpected call to GoCloakMock.GetUsersByRoleName. %v %v %v", token, realm, roleName)
	return
}

// GetUsersByRoleNameAfterCounter returns a count of finished GoCloakMock.GetUsersByRoleName invocations
func (mmGetUsersByRoleName *GoCloakMock) GetUsersByRoleNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUsersByRoleName.afterGetUsersByRoleNameCounter)
}

// GetUsersByRoleNameBeforeCounter returns a count of GoCloakMock.GetUsersByRoleName invocations
func (mmGetUsersByRoleName *GoCloakMock) GetUsersByRoleNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUsersByRoleName.beforeGetUsersByRoleNameCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.GetUsersByRoleName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUsersByRoleName *mGoCloakMockGetUsersByRoleName) Calls() []*GoCloakMockGetUsersByRoleNameParams {
	mmGetUsersByRoleName.mutex.RLock()

	argCopy := make([]*GoCloakMockGetUsersByRoleNameParams, len(mmGetUsersByRoleName.callArgs))
	copy(argCopy, mmGetUsersByRoleName.callArgs)

	mmGetUsersByRoleName.mutex.RUnlock()

	return argCopy
}

// MinimockGetUsersByRoleNameDone returns true if the count of the GetUsersByRoleName invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockGetUsersByRoleNameDone() bool {
	for _, e := range m.GetUsersByRoleNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUsersByRoleNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUsersByRoleNameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUsersByRoleName != nil && mm_atomic.LoadUint64(&m.afterGetUsersByRoleNameCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetUsersByRoleNameInspect logs each unmet expectation
func (m *GoCloakMock) MinimockGetUsersByRoleNameInspect() {
	for _, e := range m.GetUsersByRoleNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.GetUsersByRoleName with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUsersByRoleNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUsersByRoleNameCounter) < 1 {
		if m.GetUsersByRoleNameMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.GetUsersByRoleName")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.GetUsersByRoleName with params: %#v", *m.GetUsersByRoleNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUsersByRoleName != nil && mm_atomic.LoadUint64(&m.afterGetUsersByRoleNameCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.GetUsersByRoleName")
	}
}

type mGoCloakMockLogin struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockLoginExpectation
	expectations       []*GoCloakMockLoginExpectation

	callArgs []*GoCloakMockLoginParams
	mutex    sync.RWMutex
}

// GoCloakMockLoginExpectation specifies expectation struct of the GoCloak.Login
type GoCloakMockLoginExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockLoginParams
	results *GoCloakMockLoginResults
	Counter uint64
}

// GoCloakMockLoginParams contains parameters of the GoCloak.Login
type GoCloakMockLoginParams struct {
	clientID     string
	clientSecret string
	realm        string
	username     string
	password     string
}

// GoCloakMockLoginResults contains results of the GoCloak.Login
type GoCloakMockLoginResults struct {
	jp1 *mm_gocloak.JWT
	err error
}

// Expect sets up expected params for GoCloak.Login
func (mmLogin *mGoCloakMockLogin) Expect(clientID string, clientSecret string, realm string, username string, password string) *mGoCloakMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("GoCloakMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &GoCloakMockLoginExpectation{}
	}

	mmLogin.defaultExpectation.params = &GoCloakMockLoginParams{clientID, clientSecret, realm, username, password}
	for _, e := range mmLogin.expectations {
		if minimock.Equal(e.params, mmLogin.defaultExpectation.params) {
			mmLogin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLogin.defaultExpectation.params)
		}
	}

	return mmLogin
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.Login
func (mmLogin *mGoCloakMockLogin) Inspect(f func(clientID string, clientSecret string, realm string, username string, password string)) *mGoCloakMockLogin {
	if mmLogin.mock.inspectFuncLogin != nil {
		mmLogin.mock.t.Fatalf("Inspect function is already set for GoCloakMock.Login")
	}

	mmLogin.mock.inspectFuncLogin = f

	return mmLogin
}

// Return sets up results that will be returned by GoCloak.Login
func (mmLogin *mGoCloakMockLogin) Return(jp1 *mm_gocloak.JWT, err error) *GoCloakMock {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("GoCloakMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &GoCloakMockLoginExpectation{mock: mmLogin.mock}
	}
	mmLogin.defaultExpectation.results = &GoCloakMockLoginResults{jp1, err}
	return mmLogin.mock
}

//Set uses given function f to mock the GoCloak.Login method
func (mmLogin *mGoCloakMockLogin) Set(f func(clientID string, clientSecret string, realm string, username string, password string) (jp1 *mm_gocloak.JWT, err error)) *GoCloakMock {
	if mmLogin.defaultExpectation != nil {
		mmLogin.mock.t.Fatalf("Default expectation is already set for the GoCloak.Login method")
	}

	if len(mmLogin.expectations) > 0 {
		mmLogin.mock.t.Fatalf("Some expectations are already set for the GoCloak.Login method")
	}

	mmLogin.mock.funcLogin = f
	return mmLogin.mock
}

// When sets expectation for the GoCloak.Login which will trigger the result defined by the following
// Then helper
func (mmLogin *mGoCloakMockLogin) When(clientID string, clientSecret string, realm string, username string, password string) *GoCloakMockLoginExpectation {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("GoCloakMock.Login mock is already set by Set")
	}

	expectation := &GoCloakMockLoginExpectation{
		mock:   mmLogin.mock,
		params: &GoCloakMockLoginParams{clientID, clientSecret, realm, username, password},
	}
	mmLogin.expectations = append(mmLogin.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.Login return parameters for the expectation previously defined by the When method
func (e *GoCloakMockLoginExpectation) Then(jp1 *mm_gocloak.JWT, err error) *GoCloakMock {
	e.results = &GoCloakMockLoginResults{jp1, err}
	return e.mock
}

// Login implements gocloak.GoCloak
func (mmLogin *GoCloakMock) Login(clientID string, clientSecret string, realm string, username string, password string) (jp1 *mm_gocloak.JWT, err error) {
	mm_atomic.AddUint64(&mmLogin.beforeLoginCounter, 1)
	defer mm_atomic.AddUint64(&mmLogin.afterLoginCounter, 1)

	if mmLogin.inspectFuncLogin != nil {
		mmLogin.inspectFuncLogin(clientID, clientSecret, realm, username, password)
	}

	mm_params := &GoCloakMockLoginParams{clientID, clientSecret, realm, username, password}

	// Record call args
	mmLogin.LoginMock.mutex.Lock()
	mmLogin.LoginMock.callArgs = append(mmLogin.LoginMock.callArgs, mm_params)
	mmLogin.LoginMock.mutex.Unlock()

	for _, e := range mmLogin.LoginMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.jp1, e.results.err
		}
	}

	if mmLogin.LoginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLogin.LoginMock.defaultExpectation.Counter, 1)
		mm_want := mmLogin.LoginMock.defaultExpectation.params
		mm_got := GoCloakMockLoginParams{clientID, clientSecret, realm, username, password}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLogin.t.Errorf("GoCloakMock.Login got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLogin.LoginMock.defaultExpectation.results
		if mm_results == nil {
			mmLogin.t.Fatal("No results are set for the GoCloakMock.Login")
		}
		return (*mm_results).jp1, (*mm_results).err
	}
	if mmLogin.funcLogin != nil {
		return mmLogin.funcLogin(clientID, clientSecret, realm, username, password)
	}
	mmLogin.t.Fatalf("Unexpected call to GoCloakMock.Login. %v %v %v %v %v", clientID, clientSecret, realm, username, password)
	return
}

// LoginAfterCounter returns a count of finished GoCloakMock.Login invocations
func (mmLogin *GoCloakMock) LoginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.afterLoginCounter)
}

// LoginBeforeCounter returns a count of GoCloakMock.Login invocations
func (mmLogin *GoCloakMock) LoginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.beforeLoginCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.Login.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLogin *mGoCloakMockLogin) Calls() []*GoCloakMockLoginParams {
	mmLogin.mutex.RLock()

	argCopy := make([]*GoCloakMockLoginParams, len(mmLogin.callArgs))
	copy(argCopy, mmLogin.callArgs)

	mmLogin.mutex.RUnlock()

	return argCopy
}

// MinimockLoginDone returns true if the count of the Login invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockLoginDone() bool {
	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LoginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLoginCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogin != nil && mm_atomic.LoadUint64(&m.afterLoginCounter) < 1 {
		return false
	}
	return true
}

// MinimockLoginInspect logs each unmet expectation
func (m *GoCloakMock) MinimockLoginInspect() {
	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.Login with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LoginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLoginCounter) < 1 {
		if m.LoginMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.Login")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.Login with params: %#v", *m.LoginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogin != nil && mm_atomic.LoadUint64(&m.afterLoginCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.Login")
	}
}

type mGoCloakMockLoginAdmin struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockLoginAdminExpectation
	expectations       []*GoCloakMockLoginAdminExpectation

	callArgs []*GoCloakMockLoginAdminParams
	mutex    sync.RWMutex
}

// GoCloakMockLoginAdminExpectation specifies expectation struct of the GoCloak.LoginAdmin
type GoCloakMockLoginAdminExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockLoginAdminParams
	results *GoCloakMockLoginAdminResults
	Counter uint64
}

// GoCloakMockLoginAdminParams contains parameters of the GoCloak.LoginAdmin
type GoCloakMockLoginAdminParams struct {
	username string
	password string
	realm    string
}

// GoCloakMockLoginAdminResults contains results of the GoCloak.LoginAdmin
type GoCloakMockLoginAdminResults struct {
	jp1 *mm_gocloak.JWT
	err error
}

// Expect sets up expected params for GoCloak.LoginAdmin
func (mmLoginAdmin *mGoCloakMockLoginAdmin) Expect(username string, password string, realm string) *mGoCloakMockLoginAdmin {
	if mmLoginAdmin.mock.funcLoginAdmin != nil {
		mmLoginAdmin.mock.t.Fatalf("GoCloakMock.LoginAdmin mock is already set by Set")
	}

	if mmLoginAdmin.defaultExpectation == nil {
		mmLoginAdmin.defaultExpectation = &GoCloakMockLoginAdminExpectation{}
	}

	mmLoginAdmin.defaultExpectation.params = &GoCloakMockLoginAdminParams{username, password, realm}
	for _, e := range mmLoginAdmin.expectations {
		if minimock.Equal(e.params, mmLoginAdmin.defaultExpectation.params) {
			mmLoginAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLoginAdmin.defaultExpectation.params)
		}
	}

	return mmLoginAdmin
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.LoginAdmin
func (mmLoginAdmin *mGoCloakMockLoginAdmin) Inspect(f func(username string, password string, realm string)) *mGoCloakMockLoginAdmin {
	if mmLoginAdmin.mock.inspectFuncLoginAdmin != nil {
		mmLoginAdmin.mock.t.Fatalf("Inspect function is already set for GoCloakMock.LoginAdmin")
	}

	mmLoginAdmin.mock.inspectFuncLoginAdmin = f

	return mmLoginAdmin
}

// Return sets up results that will be returned by GoCloak.LoginAdmin
func (mmLoginAdmin *mGoCloakMockLoginAdmin) Return(jp1 *mm_gocloak.JWT, err error) *GoCloakMock {
	if mmLoginAdmin.mock.funcLoginAdmin != nil {
		mmLoginAdmin.mock.t.Fatalf("GoCloakMock.LoginAdmin mock is already set by Set")
	}

	if mmLoginAdmin.defaultExpectation == nil {
		mmLoginAdmin.defaultExpectation = &GoCloakMockLoginAdminExpectation{mock: mmLoginAdmin.mock}
	}
	mmLoginAdmin.defaultExpectation.results = &GoCloakMockLoginAdminResults{jp1, err}
	return mmLoginAdmin.mock
}

//Set uses given function f to mock the GoCloak.LoginAdmin method
func (mmLoginAdmin *mGoCloakMockLoginAdmin) Set(f func(username string, password string, realm string) (jp1 *mm_gocloak.JWT, err error)) *GoCloakMock {
	if mmLoginAdmin.defaultExpectation != nil {
		mmLoginAdmin.mock.t.Fatalf("Default expectation is already set for the GoCloak.LoginAdmin method")
	}

	if len(mmLoginAdmin.expectations) > 0 {
		mmLoginAdmin.mock.t.Fatalf("Some expectations are already set for the GoCloak.LoginAdmin method")
	}

	mmLoginAdmin.mock.funcLoginAdmin = f
	return mmLoginAdmin.mock
}

// When sets expectation for the GoCloak.LoginAdmin which will trigger the result defined by the following
// Then helper
func (mmLoginAdmin *mGoCloakMockLoginAdmin) When(username string, password string, realm string) *GoCloakMockLoginAdminExpectation {
	if mmLoginAdmin.mock.funcLoginAdmin != nil {
		mmLoginAdmin.mock.t.Fatalf("GoCloakMock.LoginAdmin mock is already set by Set")
	}

	expectation := &GoCloakMockLoginAdminExpectation{
		mock:   mmLoginAdmin.mock,
		params: &GoCloakMockLoginAdminParams{username, password, realm},
	}
	mmLoginAdmin.expectations = append(mmLoginAdmin.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.LoginAdmin return parameters for the expectation previously defined by the When method
func (e *GoCloakMockLoginAdminExpectation) Then(jp1 *mm_gocloak.JWT, err error) *GoCloakMock {
	e.results = &GoCloakMockLoginAdminResults{jp1, err}
	return e.mock
}

// LoginAdmin implements gocloak.GoCloak
func (mmLoginAdmin *GoCloakMock) LoginAdmin(username string, password string, realm string) (jp1 *mm_gocloak.JWT, err error) {
	mm_atomic.AddUint64(&mmLoginAdmin.beforeLoginAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmLoginAdmin.afterLoginAdminCounter, 1)

	if mmLoginAdmin.inspectFuncLoginAdmin != nil {
		mmLoginAdmin.inspectFuncLoginAdmin(username, password, realm)
	}

	mm_params := &GoCloakMockLoginAdminParams{username, password, realm}

	// Record call args
	mmLoginAdmin.LoginAdminMock.mutex.Lock()
	mmLoginAdmin.LoginAdminMock.callArgs = append(mmLoginAdmin.LoginAdminMock.callArgs, mm_params)
	mmLoginAdmin.LoginAdminMock.mutex.Unlock()

	for _, e := range mmLoginAdmin.LoginAdminMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.jp1, e.results.err
		}
	}

	if mmLoginAdmin.LoginAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLoginAdmin.LoginAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmLoginAdmin.LoginAdminMock.defaultExpectation.params
		mm_got := GoCloakMockLoginAdminParams{username, password, realm}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLoginAdmin.t.Errorf("GoCloakMock.LoginAdmin got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLoginAdmin.LoginAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmLoginAdmin.t.Fatal("No results are set for the GoCloakMock.LoginAdmin")
		}
		return (*mm_results).jp1, (*mm_results).err
	}
	if mmLoginAdmin.funcLoginAdmin != nil {
		return mmLoginAdmin.funcLoginAdmin(username, password, realm)
	}
	mmLoginAdmin.t.Fatalf("Unexpected call to GoCloakMock.LoginAdmin. %v %v %v", username, password, realm)
	return
}

// LoginAdminAfterCounter returns a count of finished GoCloakMock.LoginAdmin invocations
func (mmLoginAdmin *GoCloakMock) LoginAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLoginAdmin.afterLoginAdminCounter)
}

// LoginAdminBeforeCounter returns a count of GoCloakMock.LoginAdmin invocations
func (mmLoginAdmin *GoCloakMock) LoginAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLoginAdmin.beforeLoginAdminCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.LoginAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLoginAdmin *mGoCloakMockLoginAdmin) Calls() []*GoCloakMockLoginAdminParams {
	mmLoginAdmin.mutex.RLock()

	argCopy := make([]*GoCloakMockLoginAdminParams, len(mmLoginAdmin.callArgs))
	copy(argCopy, mmLoginAdmin.callArgs)

	mmLoginAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockLoginAdminDone returns true if the count of the LoginAdmin invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockLoginAdminDone() bool {
	for _, e := range m.LoginAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LoginAdminMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLoginAdminCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLoginAdmin != nil && mm_atomic.LoadUint64(&m.afterLoginAdminCounter) < 1 {
		return false
	}
	return true
}

// MinimockLoginAdminInspect logs each unmet expectation
func (m *GoCloakMock) MinimockLoginAdminInspect() {
	for _, e := range m.LoginAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.LoginAdmin with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LoginAdminMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLoginAdminCounter) < 1 {
		if m.LoginAdminMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.LoginAdmin")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.LoginAdmin with params: %#v", *m.LoginAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLoginAdmin != nil && mm_atomic.LoadUint64(&m.afterLoginAdminCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.LoginAdmin")
	}
}

type mGoCloakMockLoginClient struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockLoginClientExpectation
	expectations       []*GoCloakMockLoginClientExpectation

	callArgs []*GoCloakMockLoginClientParams
	mutex    sync.RWMutex
}

// GoCloakMockLoginClientExpectation specifies expectation struct of the GoCloak.LoginClient
type GoCloakMockLoginClientExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockLoginClientParams
	results *GoCloakMockLoginClientResults
	Counter uint64
}

// GoCloakMockLoginClientParams contains parameters of the GoCloak.LoginClient
type GoCloakMockLoginClientParams struct {
	clientID     string
	clientSecret string
	realm        string
}

// GoCloakMockLoginClientResults contains results of the GoCloak.LoginClient
type GoCloakMockLoginClientResults struct {
	jp1 *mm_gocloak.JWT
	err error
}

// Expect sets up expected params for GoCloak.LoginClient
func (mmLoginClient *mGoCloakMockLoginClient) Expect(clientID string, clientSecret string, realm string) *mGoCloakMockLoginClient {
	if mmLoginClient.mock.funcLoginClient != nil {
		mmLoginClient.mock.t.Fatalf("GoCloakMock.LoginClient mock is already set by Set")
	}

	if mmLoginClient.defaultExpectation == nil {
		mmLoginClient.defaultExpectation = &GoCloakMockLoginClientExpectation{}
	}

	mmLoginClient.defaultExpectation.params = &GoCloakMockLoginClientParams{clientID, clientSecret, realm}
	for _, e := range mmLoginClient.expectations {
		if minimock.Equal(e.params, mmLoginClient.defaultExpectation.params) {
			mmLoginClient.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLoginClient.defaultExpectation.params)
		}
	}

	return mmLoginClient
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.LoginClient
func (mmLoginClient *mGoCloakMockLoginClient) Inspect(f func(clientID string, clientSecret string, realm string)) *mGoCloakMockLoginClient {
	if mmLoginClient.mock.inspectFuncLoginClient != nil {
		mmLoginClient.mock.t.Fatalf("Inspect function is already set for GoCloakMock.LoginClient")
	}

	mmLoginClient.mock.inspectFuncLoginClient = f

	return mmLoginClient
}

// Return sets up results that will be returned by GoCloak.LoginClient
func (mmLoginClient *mGoCloakMockLoginClient) Return(jp1 *mm_gocloak.JWT, err error) *GoCloakMock {
	if mmLoginClient.mock.funcLoginClient != nil {
		mmLoginClient.mock.t.Fatalf("GoCloakMock.LoginClient mock is already set by Set")
	}

	if mmLoginClient.defaultExpectation == nil {
		mmLoginClient.defaultExpectation = &GoCloakMockLoginClientExpectation{mock: mmLoginClient.mock}
	}
	mmLoginClient.defaultExpectation.results = &GoCloakMockLoginClientResults{jp1, err}
	return mmLoginClient.mock
}

//Set uses given function f to mock the GoCloak.LoginClient method
func (mmLoginClient *mGoCloakMockLoginClient) Set(f func(clientID string, clientSecret string, realm string) (jp1 *mm_gocloak.JWT, err error)) *GoCloakMock {
	if mmLoginClient.defaultExpectation != nil {
		mmLoginClient.mock.t.Fatalf("Default expectation is already set for the GoCloak.LoginClient method")
	}

	if len(mmLoginClient.expectations) > 0 {
		mmLoginClient.mock.t.Fatalf("Some expectations are already set for the GoCloak.LoginClient method")
	}

	mmLoginClient.mock.funcLoginClient = f
	return mmLoginClient.mock
}

// When sets expectation for the GoCloak.LoginClient which will trigger the result defined by the following
// Then helper
func (mmLoginClient *mGoCloakMockLoginClient) When(clientID string, clientSecret string, realm string) *GoCloakMockLoginClientExpectation {
	if mmLoginClient.mock.funcLoginClient != nil {
		mmLoginClient.mock.t.Fatalf("GoCloakMock.LoginClient mock is already set by Set")
	}

	expectation := &GoCloakMockLoginClientExpectation{
		mock:   mmLoginClient.mock,
		params: &GoCloakMockLoginClientParams{clientID, clientSecret, realm},
	}
	mmLoginClient.expectations = append(mmLoginClient.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.LoginClient return parameters for the expectation previously defined by the When method
func (e *GoCloakMockLoginClientExpectation) Then(jp1 *mm_gocloak.JWT, err error) *GoCloakMock {
	e.results = &GoCloakMockLoginClientResults{jp1, err}
	return e.mock
}

// LoginClient implements gocloak.GoCloak
func (mmLoginClient *GoCloakMock) LoginClient(clientID string, clientSecret string, realm string) (jp1 *mm_gocloak.JWT, err error) {
	mm_atomic.AddUint64(&mmLoginClient.beforeLoginClientCounter, 1)
	defer mm_atomic.AddUint64(&mmLoginClient.afterLoginClientCounter, 1)

	if mmLoginClient.inspectFuncLoginClient != nil {
		mmLoginClient.inspectFuncLoginClient(clientID, clientSecret, realm)
	}

	mm_params := &GoCloakMockLoginClientParams{clientID, clientSecret, realm}

	// Record call args
	mmLoginClient.LoginClientMock.mutex.Lock()
	mmLoginClient.LoginClientMock.callArgs = append(mmLoginClient.LoginClientMock.callArgs, mm_params)
	mmLoginClient.LoginClientMock.mutex.Unlock()

	for _, e := range mmLoginClient.LoginClientMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.jp1, e.results.err
		}
	}

	if mmLoginClient.LoginClientMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLoginClient.LoginClientMock.defaultExpectation.Counter, 1)
		mm_want := mmLoginClient.LoginClientMock.defaultExpectation.params
		mm_got := GoCloakMockLoginClientParams{clientID, clientSecret, realm}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLoginClient.t.Errorf("GoCloakMock.LoginClient got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLoginClient.LoginClientMock.defaultExpectation.results
		if mm_results == nil {
			mmLoginClient.t.Fatal("No results are set for the GoCloakMock.LoginClient")
		}
		return (*mm_results).jp1, (*mm_results).err
	}
	if mmLoginClient.funcLoginClient != nil {
		return mmLoginClient.funcLoginClient(clientID, clientSecret, realm)
	}
	mmLoginClient.t.Fatalf("Unexpected call to GoCloakMock.LoginClient. %v %v %v", clientID, clientSecret, realm)
	return
}

// LoginClientAfterCounter returns a count of finished GoCloakMock.LoginClient invocations
func (mmLoginClient *GoCloakMock) LoginClientAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLoginClient.afterLoginClientCounter)
}

// LoginClientBeforeCounter returns a count of GoCloakMock.LoginClient invocations
func (mmLoginClient *GoCloakMock) LoginClientBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLoginClient.beforeLoginClientCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.LoginClient.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLoginClient *mGoCloakMockLoginClient) Calls() []*GoCloakMockLoginClientParams {
	mmLoginClient.mutex.RLock()

	argCopy := make([]*GoCloakMockLoginClientParams, len(mmLoginClient.callArgs))
	copy(argCopy, mmLoginClient.callArgs)

	mmLoginClient.mutex.RUnlock()

	return argCopy
}

// MinimockLoginClientDone returns true if the count of the LoginClient invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockLoginClientDone() bool {
	for _, e := range m.LoginClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LoginClientMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLoginClientCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLoginClient != nil && mm_atomic.LoadUint64(&m.afterLoginClientCounter) < 1 {
		return false
	}
	return true
}

// MinimockLoginClientInspect logs each unmet expectation
func (m *GoCloakMock) MinimockLoginClientInspect() {
	for _, e := range m.LoginClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.LoginClient with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LoginClientMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLoginClientCounter) < 1 {
		if m.LoginClientMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.LoginClient")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.LoginClient with params: %#v", *m.LoginClientMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLoginClient != nil && mm_atomic.LoadUint64(&m.afterLoginClientCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.LoginClient")
	}
}

type mGoCloakMockRefreshToken struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockRefreshTokenExpectation
	expectations       []*GoCloakMockRefreshTokenExpectation

	callArgs []*GoCloakMockRefreshTokenParams
	mutex    sync.RWMutex
}

// GoCloakMockRefreshTokenExpectation specifies expectation struct of the GoCloak.RefreshToken
type GoCloakMockRefreshTokenExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockRefreshTokenParams
	results *GoCloakMockRefreshTokenResults
	Counter uint64
}

// GoCloakMockRefreshTokenParams contains parameters of the GoCloak.RefreshToken
type GoCloakMockRefreshTokenParams struct {
	refreshToken string
	clientID     string
	clientSecret string
	realm        string
}

// GoCloakMockRefreshTokenResults contains results of the GoCloak.RefreshToken
type GoCloakMockRefreshTokenResults struct {
	jp1 *mm_gocloak.JWT
	err error
}

// Expect sets up expected params for GoCloak.RefreshToken
func (mmRefreshToken *mGoCloakMockRefreshToken) Expect(refreshToken string, clientID string, clientSecret string, realm string) *mGoCloakMockRefreshToken {
	if mmRefreshToken.mock.funcRefreshToken != nil {
		mmRefreshToken.mock.t.Fatalf("GoCloakMock.RefreshToken mock is already set by Set")
	}

	if mmRefreshToken.defaultExpectation == nil {
		mmRefreshToken.defaultExpectation = &GoCloakMockRefreshTokenExpectation{}
	}

	mmRefreshToken.defaultExpectation.params = &GoCloakMockRefreshTokenParams{refreshToken, clientID, clientSecret, realm}
	for _, e := range mmRefreshToken.expectations {
		if minimock.Equal(e.params, mmRefreshToken.defaultExpectation.params) {
			mmRefreshToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRefreshToken.defaultExpectation.params)
		}
	}

	return mmRefreshToken
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.RefreshToken
func (mmRefreshToken *mGoCloakMockRefreshToken) Inspect(f func(refreshToken string, clientID string, clientSecret string, realm string)) *mGoCloakMockRefreshToken {
	if mmRefreshToken.mock.inspectFuncRefreshToken != nil {
		mmRefreshToken.mock.t.Fatalf("Inspect function is already set for GoCloakMock.RefreshToken")
	}

	mmRefreshToken.mock.inspectFuncRefreshToken = f

	return mmRefreshToken
}

// Return sets up results that will be returned by GoCloak.RefreshToken
func (mmRefreshToken *mGoCloakMockRefreshToken) Return(jp1 *mm_gocloak.JWT, err error) *GoCloakMock {
	if mmRefreshToken.mock.funcRefreshToken != nil {
		mmRefreshToken.mock.t.Fatalf("GoCloakMock.RefreshToken mock is already set by Set")
	}

	if mmRefreshToken.defaultExpectation == nil {
		mmRefreshToken.defaultExpectation = &GoCloakMockRefreshTokenExpectation{mock: mmRefreshToken.mock}
	}
	mmRefreshToken.defaultExpectation.results = &GoCloakMockRefreshTokenResults{jp1, err}
	return mmRefreshToken.mock
}

//Set uses given function f to mock the GoCloak.RefreshToken method
func (mmRefreshToken *mGoCloakMockRefreshToken) Set(f func(refreshToken string, clientID string, clientSecret string, realm string) (jp1 *mm_gocloak.JWT, err error)) *GoCloakMock {
	if mmRefreshToken.defaultExpectation != nil {
		mmRefreshToken.mock.t.Fatalf("Default expectation is already set for the GoCloak.RefreshToken method")
	}

	if len(mmRefreshToken.expectations) > 0 {
		mmRefreshToken.mock.t.Fatalf("Some expectations are already set for the GoCloak.RefreshToken method")
	}

	mmRefreshToken.mock.funcRefreshToken = f
	return mmRefreshToken.mock
}

// When sets expectation for the GoCloak.RefreshToken which will trigger the result defined by the following
// Then helper
func (mmRefreshToken *mGoCloakMockRefreshToken) When(refreshToken string, clientID string, clientSecret string, realm string) *GoCloakMockRefreshTokenExpectation {
	if mmRefreshToken.mock.funcRefreshToken != nil {
		mmRefreshToken.mock.t.Fatalf("GoCloakMock.RefreshToken mock is already set by Set")
	}

	expectation := &GoCloakMockRefreshTokenExpectation{
		mock:   mmRefreshToken.mock,
		params: &GoCloakMockRefreshTokenParams{refreshToken, clientID, clientSecret, realm},
	}
	mmRefreshToken.expectations = append(mmRefreshToken.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.RefreshToken return parameters for the expectation previously defined by the When method
func (e *GoCloakMockRefreshTokenExpectation) Then(jp1 *mm_gocloak.JWT, err error) *GoCloakMock {
	e.results = &GoCloakMockRefreshTokenResults{jp1, err}
	return e.mock
}

// RefreshToken implements gocloak.GoCloak
func (mmRefreshToken *GoCloakMock) RefreshToken(refreshToken string, clientID string, clientSecret string, realm string) (jp1 *mm_gocloak.JWT, err error) {
	mm_atomic.AddUint64(&mmRefreshToken.beforeRefreshTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmRefreshToken.afterRefreshTokenCounter, 1)

	if mmRefreshToken.inspectFuncRefreshToken != nil {
		mmRefreshToken.inspectFuncRefreshToken(refreshToken, clientID, clientSecret, realm)
	}

	mm_params := &GoCloakMockRefreshTokenParams{refreshToken, clientID, clientSecret, realm}

	// Record call args
	mmRefreshToken.RefreshTokenMock.mutex.Lock()
	mmRefreshToken.RefreshTokenMock.callArgs = append(mmRefreshToken.RefreshTokenMock.callArgs, mm_params)
	mmRefreshToken.RefreshTokenMock.mutex.Unlock()

	for _, e := range mmRefreshToken.RefreshTokenMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.jp1, e.results.err
		}
	}

	if mmRefreshToken.RefreshTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRefreshToken.RefreshTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmRefreshToken.RefreshTokenMock.defaultExpectation.params
		mm_got := GoCloakMockRefreshTokenParams{refreshToken, clientID, clientSecret, realm}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRefreshToken.t.Errorf("GoCloakMock.RefreshToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRefreshToken.RefreshTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmRefreshToken.t.Fatal("No results are set for the GoCloakMock.RefreshToken")
		}
		return (*mm_results).jp1, (*mm_results).err
	}
	if mmRefreshToken.funcRefreshToken != nil {
		return mmRefreshToken.funcRefreshToken(refreshToken, clientID, clientSecret, realm)
	}
	mmRefreshToken.t.Fatalf("Unexpected call to GoCloakMock.RefreshToken. %v %v %v %v", refreshToken, clientID, clientSecret, realm)
	return
}

// RefreshTokenAfterCounter returns a count of finished GoCloakMock.RefreshToken invocations
func (mmRefreshToken *GoCloakMock) RefreshTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRefreshToken.afterRefreshTokenCounter)
}

// RefreshTokenBeforeCounter returns a count of GoCloakMock.RefreshToken invocations
func (mmRefreshToken *GoCloakMock) RefreshTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRefreshToken.beforeRefreshTokenCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.RefreshToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRefreshToken *mGoCloakMockRefreshToken) Calls() []*GoCloakMockRefreshTokenParams {
	mmRefreshToken.mutex.RLock()

	argCopy := make([]*GoCloakMockRefreshTokenParams, len(mmRefreshToken.callArgs))
	copy(argCopy, mmRefreshToken.callArgs)

	mmRefreshToken.mutex.RUnlock()

	return argCopy
}

// MinimockRefreshTokenDone returns true if the count of the RefreshToken invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockRefreshTokenDone() bool {
	for _, e := range m.RefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RefreshTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRefreshTokenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRefreshToken != nil && mm_atomic.LoadUint64(&m.afterRefreshTokenCounter) < 1 {
		return false
	}
	return true
}

// MinimockRefreshTokenInspect logs each unmet expectation
func (m *GoCloakMock) MinimockRefreshTokenInspect() {
	for _, e := range m.RefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.RefreshToken with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RefreshTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRefreshTokenCounter) < 1 {
		if m.RefreshTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.RefreshToken")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.RefreshToken with params: %#v", *m.RefreshTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRefreshToken != nil && mm_atomic.LoadUint64(&m.afterRefreshTokenCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.RefreshToken")
	}
}

type mGoCloakMockRequestPermission struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockRequestPermissionExpectation
	expectations       []*GoCloakMockRequestPermissionExpectation

	callArgs []*GoCloakMockRequestPermissionParams
	mutex    sync.RWMutex
}

// GoCloakMockRequestPermissionExpectation specifies expectation struct of the GoCloak.RequestPermission
type GoCloakMockRequestPermissionExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockRequestPermissionParams
	results *GoCloakMockRequestPermissionResults
	Counter uint64
}

// GoCloakMockRequestPermissionParams contains parameters of the GoCloak.RequestPermission
type GoCloakMockRequestPermissionParams struct {
	clientID     string
	clientSecret string
	realm        string
	username     string
	password     string
	permission   string
}

// GoCloakMockRequestPermissionResults contains results of the GoCloak.RequestPermission
type GoCloakMockRequestPermissionResults struct {
	jp1 *mm_gocloak.JWT
	err error
}

// Expect sets up expected params for GoCloak.RequestPermission
func (mmRequestPermission *mGoCloakMockRequestPermission) Expect(clientID string, clientSecret string, realm string, username string, password string, permission string) *mGoCloakMockRequestPermission {
	if mmRequestPermission.mock.funcRequestPermission != nil {
		mmRequestPermission.mock.t.Fatalf("GoCloakMock.RequestPermission mock is already set by Set")
	}

	if mmRequestPermission.defaultExpectation == nil {
		mmRequestPermission.defaultExpectation = &GoCloakMockRequestPermissionExpectation{}
	}

	mmRequestPermission.defaultExpectation.params = &GoCloakMockRequestPermissionParams{clientID, clientSecret, realm, username, password, permission}
	for _, e := range mmRequestPermission.expectations {
		if minimock.Equal(e.params, mmRequestPermission.defaultExpectation.params) {
			mmRequestPermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRequestPermission.defaultExpectation.params)
		}
	}

	return mmRequestPermission
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.RequestPermission
func (mmRequestPermission *mGoCloakMockRequestPermission) Inspect(f func(clientID string, clientSecret string, realm string, username string, password string, permission string)) *mGoCloakMockRequestPermission {
	if mmRequestPermission.mock.inspectFuncRequestPermission != nil {
		mmRequestPermission.mock.t.Fatalf("Inspect function is already set for GoCloakMock.RequestPermission")
	}

	mmRequestPermission.mock.inspectFuncRequestPermission = f

	return mmRequestPermission
}

// Return sets up results that will be returned by GoCloak.RequestPermission
func (mmRequestPermission *mGoCloakMockRequestPermission) Return(jp1 *mm_gocloak.JWT, err error) *GoCloakMock {
	if mmRequestPermission.mock.funcRequestPermission != nil {
		mmRequestPermission.mock.t.Fatalf("GoCloakMock.RequestPermission mock is already set by Set")
	}

	if mmRequestPermission.defaultExpectation == nil {
		mmRequestPermission.defaultExpectation = &GoCloakMockRequestPermissionExpectation{mock: mmRequestPermission.mock}
	}
	mmRequestPermission.defaultExpectation.results = &GoCloakMockRequestPermissionResults{jp1, err}
	return mmRequestPermission.mock
}

//Set uses given function f to mock the GoCloak.RequestPermission method
func (mmRequestPermission *mGoCloakMockRequestPermission) Set(f func(clientID string, clientSecret string, realm string, username string, password string, permission string) (jp1 *mm_gocloak.JWT, err error)) *GoCloakMock {
	if mmRequestPermission.defaultExpectation != nil {
		mmRequestPermission.mock.t.Fatalf("Default expectation is already set for the GoCloak.RequestPermission method")
	}

	if len(mmRequestPermission.expectations) > 0 {
		mmRequestPermission.mock.t.Fatalf("Some expectations are already set for the GoCloak.RequestPermission method")
	}

	mmRequestPermission.mock.funcRequestPermission = f
	return mmRequestPermission.mock
}

// When sets expectation for the GoCloak.RequestPermission which will trigger the result defined by the following
// Then helper
func (mmRequestPermission *mGoCloakMockRequestPermission) When(clientID string, clientSecret string, realm string, username string, password string, permission string) *GoCloakMockRequestPermissionExpectation {
	if mmRequestPermission.mock.funcRequestPermission != nil {
		mmRequestPermission.mock.t.Fatalf("GoCloakMock.RequestPermission mock is already set by Set")
	}

	expectation := &GoCloakMockRequestPermissionExpectation{
		mock:   mmRequestPermission.mock,
		params: &GoCloakMockRequestPermissionParams{clientID, clientSecret, realm, username, password, permission},
	}
	mmRequestPermission.expectations = append(mmRequestPermission.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.RequestPermission return parameters for the expectation previously defined by the When method
func (e *GoCloakMockRequestPermissionExpectation) Then(jp1 *mm_gocloak.JWT, err error) *GoCloakMock {
	e.results = &GoCloakMockRequestPermissionResults{jp1, err}
	return e.mock
}

// RequestPermission implements gocloak.GoCloak
func (mmRequestPermission *GoCloakMock) RequestPermission(clientID string, clientSecret string, realm string, username string, password string, permission string) (jp1 *mm_gocloak.JWT, err error) {
	mm_atomic.AddUint64(&mmRequestPermission.beforeRequestPermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmRequestPermission.afterRequestPermissionCounter, 1)

	if mmRequestPermission.inspectFuncRequestPermission != nil {
		mmRequestPermission.inspectFuncRequestPermission(clientID, clientSecret, realm, username, password, permission)
	}

	mm_params := &GoCloakMockRequestPermissionParams{clientID, clientSecret, realm, username, password, permission}

	// Record call args
	mmRequestPermission.RequestPermissionMock.mutex.Lock()
	mmRequestPermission.RequestPermissionMock.callArgs = append(mmRequestPermission.RequestPermissionMock.callArgs, mm_params)
	mmRequestPermission.RequestPermissionMock.mutex.Unlock()

	for _, e := range mmRequestPermission.RequestPermissionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.jp1, e.results.err
		}
	}

	if mmRequestPermission.RequestPermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRequestPermission.RequestPermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmRequestPermission.RequestPermissionMock.defaultExpectation.params
		mm_got := GoCloakMockRequestPermissionParams{clientID, clientSecret, realm, username, password, permission}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRequestPermission.t.Errorf("GoCloakMock.RequestPermission got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRequestPermission.RequestPermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmRequestPermission.t.Fatal("No results are set for the GoCloakMock.RequestPermission")
		}
		return (*mm_results).jp1, (*mm_results).err
	}
	if mmRequestPermission.funcRequestPermission != nil {
		return mmRequestPermission.funcRequestPermission(clientID, clientSecret, realm, username, password, permission)
	}
	mmRequestPermission.t.Fatalf("Unexpected call to GoCloakMock.RequestPermission. %v %v %v %v %v %v", clientID, clientSecret, realm, username, password, permission)
	return
}

// RequestPermissionAfterCounter returns a count of finished GoCloakMock.RequestPermission invocations
func (mmRequestPermission *GoCloakMock) RequestPermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRequestPermission.afterRequestPermissionCounter)
}

// RequestPermissionBeforeCounter returns a count of GoCloakMock.RequestPermission invocations
func (mmRequestPermission *GoCloakMock) RequestPermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRequestPermission.beforeRequestPermissionCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.RequestPermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRequestPermission *mGoCloakMockRequestPermission) Calls() []*GoCloakMockRequestPermissionParams {
	mmRequestPermission.mutex.RLock()

	argCopy := make([]*GoCloakMockRequestPermissionParams, len(mmRequestPermission.callArgs))
	copy(argCopy, mmRequestPermission.callArgs)

	mmRequestPermission.mutex.RUnlock()

	return argCopy
}

// MinimockRequestPermissionDone returns true if the count of the RequestPermission invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockRequestPermissionDone() bool {
	for _, e := range m.RequestPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RequestPermissionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRequestPermissionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRequestPermission != nil && mm_atomic.LoadUint64(&m.afterRequestPermissionCounter) < 1 {
		return false
	}
	return true
}

// MinimockRequestPermissionInspect logs each unmet expectation
func (m *GoCloakMock) MinimockRequestPermissionInspect() {
	for _, e := range m.RequestPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.RequestPermission with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RequestPermissionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRequestPermissionCounter) < 1 {
		if m.RequestPermissionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.RequestPermission")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.RequestPermission with params: %#v", *m.RequestPermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRequestPermission != nil && mm_atomic.LoadUint64(&m.afterRequestPermissionCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.RequestPermission")
	}
}

type mGoCloakMockRetrospectToken struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockRetrospectTokenExpectation
	expectations       []*GoCloakMockRetrospectTokenExpectation

	callArgs []*GoCloakMockRetrospectTokenParams
	mutex    sync.RWMutex
}

// GoCloakMockRetrospectTokenExpectation specifies expectation struct of the GoCloak.RetrospectToken
type GoCloakMockRetrospectTokenExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockRetrospectTokenParams
	results *GoCloakMockRetrospectTokenResults
	Counter uint64
}

// GoCloakMockRetrospectTokenParams contains parameters of the GoCloak.RetrospectToken
type GoCloakMockRetrospectTokenParams struct {
	accessToken  string
	clientID     string
	clientSecret string
	realm        string
}

// GoCloakMockRetrospectTokenResults contains results of the GoCloak.RetrospectToken
type GoCloakMockRetrospectTokenResults struct {
	rp1 *mm_gocloak.RetrospecTokenResult
	err error
}

// Expect sets up expected params for GoCloak.RetrospectToken
func (mmRetrospectToken *mGoCloakMockRetrospectToken) Expect(accessToken string, clientID string, clientSecret string, realm string) *mGoCloakMockRetrospectToken {
	if mmRetrospectToken.mock.funcRetrospectToken != nil {
		mmRetrospectToken.mock.t.Fatalf("GoCloakMock.RetrospectToken mock is already set by Set")
	}

	if mmRetrospectToken.defaultExpectation == nil {
		mmRetrospectToken.defaultExpectation = &GoCloakMockRetrospectTokenExpectation{}
	}

	mmRetrospectToken.defaultExpectation.params = &GoCloakMockRetrospectTokenParams{accessToken, clientID, clientSecret, realm}
	for _, e := range mmRetrospectToken.expectations {
		if minimock.Equal(e.params, mmRetrospectToken.defaultExpectation.params) {
			mmRetrospectToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRetrospectToken.defaultExpectation.params)
		}
	}

	return mmRetrospectToken
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.RetrospectToken
func (mmRetrospectToken *mGoCloakMockRetrospectToken) Inspect(f func(accessToken string, clientID string, clientSecret string, realm string)) *mGoCloakMockRetrospectToken {
	if mmRetrospectToken.mock.inspectFuncRetrospectToken != nil {
		mmRetrospectToken.mock.t.Fatalf("Inspect function is already set for GoCloakMock.RetrospectToken")
	}

	mmRetrospectToken.mock.inspectFuncRetrospectToken = f

	return mmRetrospectToken
}

// Return sets up results that will be returned by GoCloak.RetrospectToken
func (mmRetrospectToken *mGoCloakMockRetrospectToken) Return(rp1 *mm_gocloak.RetrospecTokenResult, err error) *GoCloakMock {
	if mmRetrospectToken.mock.funcRetrospectToken != nil {
		mmRetrospectToken.mock.t.Fatalf("GoCloakMock.RetrospectToken mock is already set by Set")
	}

	if mmRetrospectToken.defaultExpectation == nil {
		mmRetrospectToken.defaultExpectation = &GoCloakMockRetrospectTokenExpectation{mock: mmRetrospectToken.mock}
	}
	mmRetrospectToken.defaultExpectation.results = &GoCloakMockRetrospectTokenResults{rp1, err}
	return mmRetrospectToken.mock
}

//Set uses given function f to mock the GoCloak.RetrospectToken method
func (mmRetrospectToken *mGoCloakMockRetrospectToken) Set(f func(accessToken string, clientID string, clientSecret string, realm string) (rp1 *mm_gocloak.RetrospecTokenResult, err error)) *GoCloakMock {
	if mmRetrospectToken.defaultExpectation != nil {
		mmRetrospectToken.mock.t.Fatalf("Default expectation is already set for the GoCloak.RetrospectToken method")
	}

	if len(mmRetrospectToken.expectations) > 0 {
		mmRetrospectToken.mock.t.Fatalf("Some expectations are already set for the GoCloak.RetrospectToken method")
	}

	mmRetrospectToken.mock.funcRetrospectToken = f
	return mmRetrospectToken.mock
}

// When sets expectation for the GoCloak.RetrospectToken which will trigger the result defined by the following
// Then helper
func (mmRetrospectToken *mGoCloakMockRetrospectToken) When(accessToken string, clientID string, clientSecret string, realm string) *GoCloakMockRetrospectTokenExpectation {
	if mmRetrospectToken.mock.funcRetrospectToken != nil {
		mmRetrospectToken.mock.t.Fatalf("GoCloakMock.RetrospectToken mock is already set by Set")
	}

	expectation := &GoCloakMockRetrospectTokenExpectation{
		mock:   mmRetrospectToken.mock,
		params: &GoCloakMockRetrospectTokenParams{accessToken, clientID, clientSecret, realm},
	}
	mmRetrospectToken.expectations = append(mmRetrospectToken.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.RetrospectToken return parameters for the expectation previously defined by the When method
func (e *GoCloakMockRetrospectTokenExpectation) Then(rp1 *mm_gocloak.RetrospecTokenResult, err error) *GoCloakMock {
	e.results = &GoCloakMockRetrospectTokenResults{rp1, err}
	return e.mock
}

// RetrospectToken implements gocloak.GoCloak
func (mmRetrospectToken *GoCloakMock) RetrospectToken(accessToken string, clientID string, clientSecret string, realm string) (rp1 *mm_gocloak.RetrospecTokenResult, err error) {
	mm_atomic.AddUint64(&mmRetrospectToken.beforeRetrospectTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmRetrospectToken.afterRetrospectTokenCounter, 1)

	if mmRetrospectToken.inspectFuncRetrospectToken != nil {
		mmRetrospectToken.inspectFuncRetrospectToken(accessToken, clientID, clientSecret, realm)
	}

	mm_params := &GoCloakMockRetrospectTokenParams{accessToken, clientID, clientSecret, realm}

	// Record call args
	mmRetrospectToken.RetrospectTokenMock.mutex.Lock()
	mmRetrospectToken.RetrospectTokenMock.callArgs = append(mmRetrospectToken.RetrospectTokenMock.callArgs, mm_params)
	mmRetrospectToken.RetrospectTokenMock.mutex.Unlock()

	for _, e := range mmRetrospectToken.RetrospectTokenMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmRetrospectToken.RetrospectTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRetrospectToken.RetrospectTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmRetrospectToken.RetrospectTokenMock.defaultExpectation.params
		mm_got := GoCloakMockRetrospectTokenParams{accessToken, clientID, clientSecret, realm}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRetrospectToken.t.Errorf("GoCloakMock.RetrospectToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRetrospectToken.RetrospectTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmRetrospectToken.t.Fatal("No results are set for the GoCloakMock.RetrospectToken")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmRetrospectToken.funcRetrospectToken != nil {
		return mmRetrospectToken.funcRetrospectToken(accessToken, clientID, clientSecret, realm)
	}
	mmRetrospectToken.t.Fatalf("Unexpected call to GoCloakMock.RetrospectToken. %v %v %v %v", accessToken, clientID, clientSecret, realm)
	return
}

// RetrospectTokenAfterCounter returns a count of finished GoCloakMock.RetrospectToken invocations
func (mmRetrospectToken *GoCloakMock) RetrospectTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRetrospectToken.afterRetrospectTokenCounter)
}

// RetrospectTokenBeforeCounter returns a count of GoCloakMock.RetrospectToken invocations
func (mmRetrospectToken *GoCloakMock) RetrospectTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRetrospectToken.beforeRetrospectTokenCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.RetrospectToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRetrospectToken *mGoCloakMockRetrospectToken) Calls() []*GoCloakMockRetrospectTokenParams {
	mmRetrospectToken.mutex.RLock()

	argCopy := make([]*GoCloakMockRetrospectTokenParams, len(mmRetrospectToken.callArgs))
	copy(argCopy, mmRetrospectToken.callArgs)

	mmRetrospectToken.mutex.RUnlock()

	return argCopy
}

// MinimockRetrospectTokenDone returns true if the count of the RetrospectToken invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockRetrospectTokenDone() bool {
	for _, e := range m.RetrospectTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RetrospectTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRetrospectTokenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRetrospectToken != nil && mm_atomic.LoadUint64(&m.afterRetrospectTokenCounter) < 1 {
		return false
	}
	return true
}

// MinimockRetrospectTokenInspect logs each unmet expectation
func (m *GoCloakMock) MinimockRetrospectTokenInspect() {
	for _, e := range m.RetrospectTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.RetrospectToken with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RetrospectTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRetrospectTokenCounter) < 1 {
		if m.RetrospectTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.RetrospectToken")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.RetrospectToken with params: %#v", *m.RetrospectTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRetrospectToken != nil && mm_atomic.LoadUint64(&m.afterRetrospectTokenCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.RetrospectToken")
	}
}

type mGoCloakMockSetPassword struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockSetPasswordExpectation
	expectations       []*GoCloakMockSetPasswordExpectation

	callArgs []*GoCloakMockSetPasswordParams
	mutex    sync.RWMutex
}

// GoCloakMockSetPasswordExpectation specifies expectation struct of the GoCloak.SetPassword
type GoCloakMockSetPasswordExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockSetPasswordParams
	results *GoCloakMockSetPasswordResults
	Counter uint64
}

// GoCloakMockSetPasswordParams contains parameters of the GoCloak.SetPassword
type GoCloakMockSetPasswordParams struct {
	token     string
	userID    string
	realm     string
	password  string
	temporary bool
}

// GoCloakMockSetPasswordResults contains results of the GoCloak.SetPassword
type GoCloakMockSetPasswordResults struct {
	err error
}

// Expect sets up expected params for GoCloak.SetPassword
func (mmSetPassword *mGoCloakMockSetPassword) Expect(token string, userID string, realm string, password string, temporary bool) *mGoCloakMockSetPassword {
	if mmSetPassword.mock.funcSetPassword != nil {
		mmSetPassword.mock.t.Fatalf("GoCloakMock.SetPassword mock is already set by Set")
	}

	if mmSetPassword.defaultExpectation == nil {
		mmSetPassword.defaultExpectation = &GoCloakMockSetPasswordExpectation{}
	}

	mmSetPassword.defaultExpectation.params = &GoCloakMockSetPasswordParams{token, userID, realm, password, temporary}
	for _, e := range mmSetPassword.expectations {
		if minimock.Equal(e.params, mmSetPassword.defaultExpectation.params) {
			mmSetPassword.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetPassword.defaultExpectation.params)
		}
	}

	return mmSetPassword
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.SetPassword
func (mmSetPassword *mGoCloakMockSetPassword) Inspect(f func(token string, userID string, realm string, password string, temporary bool)) *mGoCloakMockSetPassword {
	if mmSetPassword.mock.inspectFuncSetPassword != nil {
		mmSetPassword.mock.t.Fatalf("Inspect function is already set for GoCloakMock.SetPassword")
	}

	mmSetPassword.mock.inspectFuncSetPassword = f

	return mmSetPassword
}

// Return sets up results that will be returned by GoCloak.SetPassword
func (mmSetPassword *mGoCloakMockSetPassword) Return(err error) *GoCloakMock {
	if mmSetPassword.mock.funcSetPassword != nil {
		mmSetPassword.mock.t.Fatalf("GoCloakMock.SetPassword mock is already set by Set")
	}

	if mmSetPassword.defaultExpectation == nil {
		mmSetPassword.defaultExpectation = &GoCloakMockSetPasswordExpectation{mock: mmSetPassword.mock}
	}
	mmSetPassword.defaultExpectation.results = &GoCloakMockSetPasswordResults{err}
	return mmSetPassword.mock
}

//Set uses given function f to mock the GoCloak.SetPassword method
func (mmSetPassword *mGoCloakMockSetPassword) Set(f func(token string, userID string, realm string, password string, temporary bool) (err error)) *GoCloakMock {
	if mmSetPassword.defaultExpectation != nil {
		mmSetPassword.mock.t.Fatalf("Default expectation is already set for the GoCloak.SetPassword method")
	}

	if len(mmSetPassword.expectations) > 0 {
		mmSetPassword.mock.t.Fatalf("Some expectations are already set for the GoCloak.SetPassword method")
	}

	mmSetPassword.mock.funcSetPassword = f
	return mmSetPassword.mock
}

// When sets expectation for the GoCloak.SetPassword which will trigger the result defined by the following
// Then helper
func (mmSetPassword *mGoCloakMockSetPassword) When(token string, userID string, realm string, password string, temporary bool) *GoCloakMockSetPasswordExpectation {
	if mmSetPassword.mock.funcSetPassword != nil {
		mmSetPassword.mock.t.Fatalf("GoCloakMock.SetPassword mock is already set by Set")
	}

	expectation := &GoCloakMockSetPasswordExpectation{
		mock:   mmSetPassword.mock,
		params: &GoCloakMockSetPasswordParams{token, userID, realm, password, temporary},
	}
	mmSetPassword.expectations = append(mmSetPassword.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.SetPassword return parameters for the expectation previously defined by the When method
func (e *GoCloakMockSetPasswordExpectation) Then(err error) *GoCloakMock {
	e.results = &GoCloakMockSetPasswordResults{err}
	return e.mock
}

// SetPassword implements gocloak.GoCloak
func (mmSetPassword *GoCloakMock) SetPassword(token string, userID string, realm string, password string, temporary bool) (err error) {
	mm_atomic.AddUint64(&mmSetPassword.beforeSetPasswordCounter, 1)
	defer mm_atomic.AddUint64(&mmSetPassword.afterSetPasswordCounter, 1)

	if mmSetPassword.inspectFuncSetPassword != nil {
		mmSetPassword.inspectFuncSetPassword(token, userID, realm, password, temporary)
	}

	mm_params := &GoCloakMockSetPasswordParams{token, userID, realm, password, temporary}

	// Record call args
	mmSetPassword.SetPasswordMock.mutex.Lock()
	mmSetPassword.SetPasswordMock.callArgs = append(mmSetPassword.SetPasswordMock.callArgs, mm_params)
	mmSetPassword.SetPasswordMock.mutex.Unlock()

	for _, e := range mmSetPassword.SetPasswordMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetPassword.SetPasswordMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetPassword.SetPasswordMock.defaultExpectation.Counter, 1)
		mm_want := mmSetPassword.SetPasswordMock.defaultExpectation.params
		mm_got := GoCloakMockSetPasswordParams{token, userID, realm, password, temporary}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetPassword.t.Errorf("GoCloakMock.SetPassword got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetPassword.SetPasswordMock.defaultExpectation.results
		if mm_results == nil {
			mmSetPassword.t.Fatal("No results are set for the GoCloakMock.SetPassword")
		}
		return (*mm_results).err
	}
	if mmSetPassword.funcSetPassword != nil {
		return mmSetPassword.funcSetPassword(token, userID, realm, password, temporary)
	}
	mmSetPassword.t.Fatalf("Unexpected call to GoCloakMock.SetPassword. %v %v %v %v %v", token, userID, realm, password, temporary)
	return
}

// SetPasswordAfterCounter returns a count of finished GoCloakMock.SetPassword invocations
func (mmSetPassword *GoCloakMock) SetPasswordAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPassword.afterSetPasswordCounter)
}

// SetPasswordBeforeCounter returns a count of GoCloakMock.SetPassword invocations
func (mmSetPassword *GoCloakMock) SetPasswordBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPassword.beforeSetPasswordCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.SetPassword.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetPassword *mGoCloakMockSetPassword) Calls() []*GoCloakMockSetPasswordParams {
	mmSetPassword.mutex.RLock()

	argCopy := make([]*GoCloakMockSetPasswordParams, len(mmSetPassword.callArgs))
	copy(argCopy, mmSetPassword.callArgs)

	mmSetPassword.mutex.RUnlock()

	return argCopy
}

// MinimockSetPasswordDone returns true if the count of the SetPassword invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockSetPasswordDone() bool {
	for _, e := range m.SetPasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetPasswordMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetPasswordCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetPassword != nil && mm_atomic.LoadUint64(&m.afterSetPasswordCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetPasswordInspect logs each unmet expectation
func (m *GoCloakMock) MinimockSetPasswordInspect() {
	for _, e := range m.SetPasswordMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.SetPassword with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetPasswordMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetPasswordCounter) < 1 {
		if m.SetPasswordMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.SetPassword")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.SetPassword with params: %#v", *m.SetPasswordMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetPassword != nil && mm_atomic.LoadUint64(&m.afterSetPasswordCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.SetPassword")
	}
}

type mGoCloakMockUpdateClient struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockUpdateClientExpectation
	expectations       []*GoCloakMockUpdateClientExpectation

	callArgs []*GoCloakMockUpdateClientParams
	mutex    sync.RWMutex
}

// GoCloakMockUpdateClientExpectation specifies expectation struct of the GoCloak.UpdateClient
type GoCloakMockUpdateClientExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockUpdateClientParams
	results *GoCloakMockUpdateClientResults
	Counter uint64
}

// GoCloakMockUpdateClientParams contains parameters of the GoCloak.UpdateClient
type GoCloakMockUpdateClientParams struct {
	accessToken string
	realm       string
	clientID    mm_gocloak.Client
}

// GoCloakMockUpdateClientResults contains results of the GoCloak.UpdateClient
type GoCloakMockUpdateClientResults struct {
	err error
}

// Expect sets up expected params for GoCloak.UpdateClient
func (mmUpdateClient *mGoCloakMockUpdateClient) Expect(accessToken string, realm string, clientID mm_gocloak.Client) *mGoCloakMockUpdateClient {
	if mmUpdateClient.mock.funcUpdateClient != nil {
		mmUpdateClient.mock.t.Fatalf("GoCloakMock.UpdateClient mock is already set by Set")
	}

	if mmUpdateClient.defaultExpectation == nil {
		mmUpdateClient.defaultExpectation = &GoCloakMockUpdateClientExpectation{}
	}

	mmUpdateClient.defaultExpectation.params = &GoCloakMockUpdateClientParams{accessToken, realm, clientID}
	for _, e := range mmUpdateClient.expectations {
		if minimock.Equal(e.params, mmUpdateClient.defaultExpectation.params) {
			mmUpdateClient.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateClient.defaultExpectation.params)
		}
	}

	return mmUpdateClient
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.UpdateClient
func (mmUpdateClient *mGoCloakMockUpdateClient) Inspect(f func(accessToken string, realm string, clientID mm_gocloak.Client)) *mGoCloakMockUpdateClient {
	if mmUpdateClient.mock.inspectFuncUpdateClient != nil {
		mmUpdateClient.mock.t.Fatalf("Inspect function is already set for GoCloakMock.UpdateClient")
	}

	mmUpdateClient.mock.inspectFuncUpdateClient = f

	return mmUpdateClient
}

// Return sets up results that will be returned by GoCloak.UpdateClient
func (mmUpdateClient *mGoCloakMockUpdateClient) Return(err error) *GoCloakMock {
	if mmUpdateClient.mock.funcUpdateClient != nil {
		mmUpdateClient.mock.t.Fatalf("GoCloakMock.UpdateClient mock is already set by Set")
	}

	if mmUpdateClient.defaultExpectation == nil {
		mmUpdateClient.defaultExpectation = &GoCloakMockUpdateClientExpectation{mock: mmUpdateClient.mock}
	}
	mmUpdateClient.defaultExpectation.results = &GoCloakMockUpdateClientResults{err}
	return mmUpdateClient.mock
}

//Set uses given function f to mock the GoCloak.UpdateClient method
func (mmUpdateClient *mGoCloakMockUpdateClient) Set(f func(accessToken string, realm string, clientID mm_gocloak.Client) (err error)) *GoCloakMock {
	if mmUpdateClient.defaultExpectation != nil {
		mmUpdateClient.mock.t.Fatalf("Default expectation is already set for the GoCloak.UpdateClient method")
	}

	if len(mmUpdateClient.expectations) > 0 {
		mmUpdateClient.mock.t.Fatalf("Some expectations are already set for the GoCloak.UpdateClient method")
	}

	mmUpdateClient.mock.funcUpdateClient = f
	return mmUpdateClient.mock
}

// When sets expectation for the GoCloak.UpdateClient which will trigger the result defined by the following
// Then helper
func (mmUpdateClient *mGoCloakMockUpdateClient) When(accessToken string, realm string, clientID mm_gocloak.Client) *GoCloakMockUpdateClientExpectation {
	if mmUpdateClient.mock.funcUpdateClient != nil {
		mmUpdateClient.mock.t.Fatalf("GoCloakMock.UpdateClient mock is already set by Set")
	}

	expectation := &GoCloakMockUpdateClientExpectation{
		mock:   mmUpdateClient.mock,
		params: &GoCloakMockUpdateClientParams{accessToken, realm, clientID},
	}
	mmUpdateClient.expectations = append(mmUpdateClient.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.UpdateClient return parameters for the expectation previously defined by the When method
func (e *GoCloakMockUpdateClientExpectation) Then(err error) *GoCloakMock {
	e.results = &GoCloakMockUpdateClientResults{err}
	return e.mock
}

// UpdateClient implements gocloak.GoCloak
func (mmUpdateClient *GoCloakMock) UpdateClient(accessToken string, realm string, clientID mm_gocloak.Client) (err error) {
	mm_atomic.AddUint64(&mmUpdateClient.beforeUpdateClientCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateClient.afterUpdateClientCounter, 1)

	if mmUpdateClient.inspectFuncUpdateClient != nil {
		mmUpdateClient.inspectFuncUpdateClient(accessToken, realm, clientID)
	}

	mm_params := &GoCloakMockUpdateClientParams{accessToken, realm, clientID}

	// Record call args
	mmUpdateClient.UpdateClientMock.mutex.Lock()
	mmUpdateClient.UpdateClientMock.callArgs = append(mmUpdateClient.UpdateClientMock.callArgs, mm_params)
	mmUpdateClient.UpdateClientMock.mutex.Unlock()

	for _, e := range mmUpdateClient.UpdateClientMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateClient.UpdateClientMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateClient.UpdateClientMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateClient.UpdateClientMock.defaultExpectation.params
		mm_got := GoCloakMockUpdateClientParams{accessToken, realm, clientID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateClient.t.Errorf("GoCloakMock.UpdateClient got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateClient.UpdateClientMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateClient.t.Fatal("No results are set for the GoCloakMock.UpdateClient")
		}
		return (*mm_results).err
	}
	if mmUpdateClient.funcUpdateClient != nil {
		return mmUpdateClient.funcUpdateClient(accessToken, realm, clientID)
	}
	mmUpdateClient.t.Fatalf("Unexpected call to GoCloakMock.UpdateClient. %v %v %v", accessToken, realm, clientID)
	return
}

// UpdateClientAfterCounter returns a count of finished GoCloakMock.UpdateClient invocations
func (mmUpdateClient *GoCloakMock) UpdateClientAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateClient.afterUpdateClientCounter)
}

// UpdateClientBeforeCounter returns a count of GoCloakMock.UpdateClient invocations
func (mmUpdateClient *GoCloakMock) UpdateClientBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateClient.beforeUpdateClientCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.UpdateClient.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateClient *mGoCloakMockUpdateClient) Calls() []*GoCloakMockUpdateClientParams {
	mmUpdateClient.mutex.RLock()

	argCopy := make([]*GoCloakMockUpdateClientParams, len(mmUpdateClient.callArgs))
	copy(argCopy, mmUpdateClient.callArgs)

	mmUpdateClient.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateClientDone returns true if the count of the UpdateClient invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockUpdateClientDone() bool {
	for _, e := range m.UpdateClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateClientMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateClientCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateClient != nil && mm_atomic.LoadUint64(&m.afterUpdateClientCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateClientInspect logs each unmet expectation
func (m *GoCloakMock) MinimockUpdateClientInspect() {
	for _, e := range m.UpdateClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.UpdateClient with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateClientMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateClientCounter) < 1 {
		if m.UpdateClientMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.UpdateClient")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.UpdateClient with params: %#v", *m.UpdateClientMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateClient != nil && mm_atomic.LoadUint64(&m.afterUpdateClientCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.UpdateClient")
	}
}

type mGoCloakMockUpdateClientScope struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockUpdateClientScopeExpectation
	expectations       []*GoCloakMockUpdateClientScopeExpectation

	callArgs []*GoCloakMockUpdateClientScopeParams
	mutex    sync.RWMutex
}

// GoCloakMockUpdateClientScopeExpectation specifies expectation struct of the GoCloak.UpdateClientScope
type GoCloakMockUpdateClientScopeExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockUpdateClientScopeParams
	results *GoCloakMockUpdateClientScopeResults
	Counter uint64
}

// GoCloakMockUpdateClientScopeParams contains parameters of the GoCloak.UpdateClientScope
type GoCloakMockUpdateClientScopeParams struct {
	accessToken string
	realm       string
	scope       mm_gocloak.ClientScope
}

// GoCloakMockUpdateClientScopeResults contains results of the GoCloak.UpdateClientScope
type GoCloakMockUpdateClientScopeResults struct {
	err error
}

// Expect sets up expected params for GoCloak.UpdateClientScope
func (mmUpdateClientScope *mGoCloakMockUpdateClientScope) Expect(accessToken string, realm string, scope mm_gocloak.ClientScope) *mGoCloakMockUpdateClientScope {
	if mmUpdateClientScope.mock.funcUpdateClientScope != nil {
		mmUpdateClientScope.mock.t.Fatalf("GoCloakMock.UpdateClientScope mock is already set by Set")
	}

	if mmUpdateClientScope.defaultExpectation == nil {
		mmUpdateClientScope.defaultExpectation = &GoCloakMockUpdateClientScopeExpectation{}
	}

	mmUpdateClientScope.defaultExpectation.params = &GoCloakMockUpdateClientScopeParams{accessToken, realm, scope}
	for _, e := range mmUpdateClientScope.expectations {
		if minimock.Equal(e.params, mmUpdateClientScope.defaultExpectation.params) {
			mmUpdateClientScope.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateClientScope.defaultExpectation.params)
		}
	}

	return mmUpdateClientScope
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.UpdateClientScope
func (mmUpdateClientScope *mGoCloakMockUpdateClientScope) Inspect(f func(accessToken string, realm string, scope mm_gocloak.ClientScope)) *mGoCloakMockUpdateClientScope {
	if mmUpdateClientScope.mock.inspectFuncUpdateClientScope != nil {
		mmUpdateClientScope.mock.t.Fatalf("Inspect function is already set for GoCloakMock.UpdateClientScope")
	}

	mmUpdateClientScope.mock.inspectFuncUpdateClientScope = f

	return mmUpdateClientScope
}

// Return sets up results that will be returned by GoCloak.UpdateClientScope
func (mmUpdateClientScope *mGoCloakMockUpdateClientScope) Return(err error) *GoCloakMock {
	if mmUpdateClientScope.mock.funcUpdateClientScope != nil {
		mmUpdateClientScope.mock.t.Fatalf("GoCloakMock.UpdateClientScope mock is already set by Set")
	}

	if mmUpdateClientScope.defaultExpectation == nil {
		mmUpdateClientScope.defaultExpectation = &GoCloakMockUpdateClientScopeExpectation{mock: mmUpdateClientScope.mock}
	}
	mmUpdateClientScope.defaultExpectation.results = &GoCloakMockUpdateClientScopeResults{err}
	return mmUpdateClientScope.mock
}

//Set uses given function f to mock the GoCloak.UpdateClientScope method
func (mmUpdateClientScope *mGoCloakMockUpdateClientScope) Set(f func(accessToken string, realm string, scope mm_gocloak.ClientScope) (err error)) *GoCloakMock {
	if mmUpdateClientScope.defaultExpectation != nil {
		mmUpdateClientScope.mock.t.Fatalf("Default expectation is already set for the GoCloak.UpdateClientScope method")
	}

	if len(mmUpdateClientScope.expectations) > 0 {
		mmUpdateClientScope.mock.t.Fatalf("Some expectations are already set for the GoCloak.UpdateClientScope method")
	}

	mmUpdateClientScope.mock.funcUpdateClientScope = f
	return mmUpdateClientScope.mock
}

// When sets expectation for the GoCloak.UpdateClientScope which will trigger the result defined by the following
// Then helper
func (mmUpdateClientScope *mGoCloakMockUpdateClientScope) When(accessToken string, realm string, scope mm_gocloak.ClientScope) *GoCloakMockUpdateClientScopeExpectation {
	if mmUpdateClientScope.mock.funcUpdateClientScope != nil {
		mmUpdateClientScope.mock.t.Fatalf("GoCloakMock.UpdateClientScope mock is already set by Set")
	}

	expectation := &GoCloakMockUpdateClientScopeExpectation{
		mock:   mmUpdateClientScope.mock,
		params: &GoCloakMockUpdateClientScopeParams{accessToken, realm, scope},
	}
	mmUpdateClientScope.expectations = append(mmUpdateClientScope.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.UpdateClientScope return parameters for the expectation previously defined by the When method
func (e *GoCloakMockUpdateClientScopeExpectation) Then(err error) *GoCloakMock {
	e.results = &GoCloakMockUpdateClientScopeResults{err}
	return e.mock
}

// UpdateClientScope implements gocloak.GoCloak
func (mmUpdateClientScope *GoCloakMock) UpdateClientScope(accessToken string, realm string, scope mm_gocloak.ClientScope) (err error) {
	mm_atomic.AddUint64(&mmUpdateClientScope.beforeUpdateClientScopeCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateClientScope.afterUpdateClientScopeCounter, 1)

	if mmUpdateClientScope.inspectFuncUpdateClientScope != nil {
		mmUpdateClientScope.inspectFuncUpdateClientScope(accessToken, realm, scope)
	}

	mm_params := &GoCloakMockUpdateClientScopeParams{accessToken, realm, scope}

	// Record call args
	mmUpdateClientScope.UpdateClientScopeMock.mutex.Lock()
	mmUpdateClientScope.UpdateClientScopeMock.callArgs = append(mmUpdateClientScope.UpdateClientScopeMock.callArgs, mm_params)
	mmUpdateClientScope.UpdateClientScopeMock.mutex.Unlock()

	for _, e := range mmUpdateClientScope.UpdateClientScopeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateClientScope.UpdateClientScopeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateClientScope.UpdateClientScopeMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateClientScope.UpdateClientScopeMock.defaultExpectation.params
		mm_got := GoCloakMockUpdateClientScopeParams{accessToken, realm, scope}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateClientScope.t.Errorf("GoCloakMock.UpdateClientScope got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateClientScope.UpdateClientScopeMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateClientScope.t.Fatal("No results are set for the GoCloakMock.UpdateClientScope")
		}
		return (*mm_results).err
	}
	if mmUpdateClientScope.funcUpdateClientScope != nil {
		return mmUpdateClientScope.funcUpdateClientScope(accessToken, realm, scope)
	}
	mmUpdateClientScope.t.Fatalf("Unexpected call to GoCloakMock.UpdateClientScope. %v %v %v", accessToken, realm, scope)
	return
}

// UpdateClientScopeAfterCounter returns a count of finished GoCloakMock.UpdateClientScope invocations
func (mmUpdateClientScope *GoCloakMock) UpdateClientScopeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateClientScope.afterUpdateClientScopeCounter)
}

// UpdateClientScopeBeforeCounter returns a count of GoCloakMock.UpdateClientScope invocations
func (mmUpdateClientScope *GoCloakMock) UpdateClientScopeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateClientScope.beforeUpdateClientScopeCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.UpdateClientScope.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateClientScope *mGoCloakMockUpdateClientScope) Calls() []*GoCloakMockUpdateClientScopeParams {
	mmUpdateClientScope.mutex.RLock()

	argCopy := make([]*GoCloakMockUpdateClientScopeParams, len(mmUpdateClientScope.callArgs))
	copy(argCopy, mmUpdateClientScope.callArgs)

	mmUpdateClientScope.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateClientScopeDone returns true if the count of the UpdateClientScope invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockUpdateClientScopeDone() bool {
	for _, e := range m.UpdateClientScopeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateClientScopeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateClientScopeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateClientScope != nil && mm_atomic.LoadUint64(&m.afterUpdateClientScopeCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateClientScopeInspect logs each unmet expectation
func (m *GoCloakMock) MinimockUpdateClientScopeInspect() {
	for _, e := range m.UpdateClientScopeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.UpdateClientScope with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateClientScopeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateClientScopeCounter) < 1 {
		if m.UpdateClientScopeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.UpdateClientScope")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.UpdateClientScope with params: %#v", *m.UpdateClientScopeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateClientScope != nil && mm_atomic.LoadUint64(&m.afterUpdateClientScopeCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.UpdateClientScope")
	}
}

type mGoCloakMockUpdateGroup struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockUpdateGroupExpectation
	expectations       []*GoCloakMockUpdateGroupExpectation

	callArgs []*GoCloakMockUpdateGroupParams
	mutex    sync.RWMutex
}

// GoCloakMockUpdateGroupExpectation specifies expectation struct of the GoCloak.UpdateGroup
type GoCloakMockUpdateGroupExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockUpdateGroupParams
	results *GoCloakMockUpdateGroupResults
	Counter uint64
}

// GoCloakMockUpdateGroupParams contains parameters of the GoCloak.UpdateGroup
type GoCloakMockUpdateGroupParams struct {
	accessToken string
	realm       string
	group       mm_gocloak.Group
}

// GoCloakMockUpdateGroupResults contains results of the GoCloak.UpdateGroup
type GoCloakMockUpdateGroupResults struct {
	err error
}

// Expect sets up expected params for GoCloak.UpdateGroup
func (mmUpdateGroup *mGoCloakMockUpdateGroup) Expect(accessToken string, realm string, group mm_gocloak.Group) *mGoCloakMockUpdateGroup {
	if mmUpdateGroup.mock.funcUpdateGroup != nil {
		mmUpdateGroup.mock.t.Fatalf("GoCloakMock.UpdateGroup mock is already set by Set")
	}

	if mmUpdateGroup.defaultExpectation == nil {
		mmUpdateGroup.defaultExpectation = &GoCloakMockUpdateGroupExpectation{}
	}

	mmUpdateGroup.defaultExpectation.params = &GoCloakMockUpdateGroupParams{accessToken, realm, group}
	for _, e := range mmUpdateGroup.expectations {
		if minimock.Equal(e.params, mmUpdateGroup.defaultExpectation.params) {
			mmUpdateGroup.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateGroup.defaultExpectation.params)
		}
	}

	return mmUpdateGroup
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.UpdateGroup
func (mmUpdateGroup *mGoCloakMockUpdateGroup) Inspect(f func(accessToken string, realm string, group mm_gocloak.Group)) *mGoCloakMockUpdateGroup {
	if mmUpdateGroup.mock.inspectFuncUpdateGroup != nil {
		mmUpdateGroup.mock.t.Fatalf("Inspect function is already set for GoCloakMock.UpdateGroup")
	}

	mmUpdateGroup.mock.inspectFuncUpdateGroup = f

	return mmUpdateGroup
}

// Return sets up results that will be returned by GoCloak.UpdateGroup
func (mmUpdateGroup *mGoCloakMockUpdateGroup) Return(err error) *GoCloakMock {
	if mmUpdateGroup.mock.funcUpdateGroup != nil {
		mmUpdateGroup.mock.t.Fatalf("GoCloakMock.UpdateGroup mock is already set by Set")
	}

	if mmUpdateGroup.defaultExpectation == nil {
		mmUpdateGroup.defaultExpectation = &GoCloakMockUpdateGroupExpectation{mock: mmUpdateGroup.mock}
	}
	mmUpdateGroup.defaultExpectation.results = &GoCloakMockUpdateGroupResults{err}
	return mmUpdateGroup.mock
}

//Set uses given function f to mock the GoCloak.UpdateGroup method
func (mmUpdateGroup *mGoCloakMockUpdateGroup) Set(f func(accessToken string, realm string, group mm_gocloak.Group) (err error)) *GoCloakMock {
	if mmUpdateGroup.defaultExpectation != nil {
		mmUpdateGroup.mock.t.Fatalf("Default expectation is already set for the GoCloak.UpdateGroup method")
	}

	if len(mmUpdateGroup.expectations) > 0 {
		mmUpdateGroup.mock.t.Fatalf("Some expectations are already set for the GoCloak.UpdateGroup method")
	}

	mmUpdateGroup.mock.funcUpdateGroup = f
	return mmUpdateGroup.mock
}

// When sets expectation for the GoCloak.UpdateGroup which will trigger the result defined by the following
// Then helper
func (mmUpdateGroup *mGoCloakMockUpdateGroup) When(accessToken string, realm string, group mm_gocloak.Group) *GoCloakMockUpdateGroupExpectation {
	if mmUpdateGroup.mock.funcUpdateGroup != nil {
		mmUpdateGroup.mock.t.Fatalf("GoCloakMock.UpdateGroup mock is already set by Set")
	}

	expectation := &GoCloakMockUpdateGroupExpectation{
		mock:   mmUpdateGroup.mock,
		params: &GoCloakMockUpdateGroupParams{accessToken, realm, group},
	}
	mmUpdateGroup.expectations = append(mmUpdateGroup.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.UpdateGroup return parameters for the expectation previously defined by the When method
func (e *GoCloakMockUpdateGroupExpectation) Then(err error) *GoCloakMock {
	e.results = &GoCloakMockUpdateGroupResults{err}
	return e.mock
}

// UpdateGroup implements gocloak.GoCloak
func (mmUpdateGroup *GoCloakMock) UpdateGroup(accessToken string, realm string, group mm_gocloak.Group) (err error) {
	mm_atomic.AddUint64(&mmUpdateGroup.beforeUpdateGroupCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateGroup.afterUpdateGroupCounter, 1)

	if mmUpdateGroup.inspectFuncUpdateGroup != nil {
		mmUpdateGroup.inspectFuncUpdateGroup(accessToken, realm, group)
	}

	mm_params := &GoCloakMockUpdateGroupParams{accessToken, realm, group}

	// Record call args
	mmUpdateGroup.UpdateGroupMock.mutex.Lock()
	mmUpdateGroup.UpdateGroupMock.callArgs = append(mmUpdateGroup.UpdateGroupMock.callArgs, mm_params)
	mmUpdateGroup.UpdateGroupMock.mutex.Unlock()

	for _, e := range mmUpdateGroup.UpdateGroupMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateGroup.UpdateGroupMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateGroup.UpdateGroupMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateGroup.UpdateGroupMock.defaultExpectation.params
		mm_got := GoCloakMockUpdateGroupParams{accessToken, realm, group}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateGroup.t.Errorf("GoCloakMock.UpdateGroup got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateGroup.UpdateGroupMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateGroup.t.Fatal("No results are set for the GoCloakMock.UpdateGroup")
		}
		return (*mm_results).err
	}
	if mmUpdateGroup.funcUpdateGroup != nil {
		return mmUpdateGroup.funcUpdateGroup(accessToken, realm, group)
	}
	mmUpdateGroup.t.Fatalf("Unexpected call to GoCloakMock.UpdateGroup. %v %v %v", accessToken, realm, group)
	return
}

// UpdateGroupAfterCounter returns a count of finished GoCloakMock.UpdateGroup invocations
func (mmUpdateGroup *GoCloakMock) UpdateGroupAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateGroup.afterUpdateGroupCounter)
}

// UpdateGroupBeforeCounter returns a count of GoCloakMock.UpdateGroup invocations
func (mmUpdateGroup *GoCloakMock) UpdateGroupBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateGroup.beforeUpdateGroupCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.UpdateGroup.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateGroup *mGoCloakMockUpdateGroup) Calls() []*GoCloakMockUpdateGroupParams {
	mmUpdateGroup.mutex.RLock()

	argCopy := make([]*GoCloakMockUpdateGroupParams, len(mmUpdateGroup.callArgs))
	copy(argCopy, mmUpdateGroup.callArgs)

	mmUpdateGroup.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateGroupDone returns true if the count of the UpdateGroup invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockUpdateGroupDone() bool {
	for _, e := range m.UpdateGroupMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateGroupMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateGroupCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateGroup != nil && mm_atomic.LoadUint64(&m.afterUpdateGroupCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateGroupInspect logs each unmet expectation
func (m *GoCloakMock) MinimockUpdateGroupInspect() {
	for _, e := range m.UpdateGroupMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.UpdateGroup with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateGroupMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateGroupCounter) < 1 {
		if m.UpdateGroupMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.UpdateGroup")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.UpdateGroup with params: %#v", *m.UpdateGroupMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateGroup != nil && mm_atomic.LoadUint64(&m.afterUpdateGroupCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.UpdateGroup")
	}
}

type mGoCloakMockUpdateRole struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockUpdateRoleExpectation
	expectations       []*GoCloakMockUpdateRoleExpectation

	callArgs []*GoCloakMockUpdateRoleParams
	mutex    sync.RWMutex
}

// GoCloakMockUpdateRoleExpectation specifies expectation struct of the GoCloak.UpdateRole
type GoCloakMockUpdateRoleExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockUpdateRoleParams
	results *GoCloakMockUpdateRoleResults
	Counter uint64
}

// GoCloakMockUpdateRoleParams contains parameters of the GoCloak.UpdateRole
type GoCloakMockUpdateRoleParams struct {
	accessToken string
	realm       string
	clientID    string
	role        mm_gocloak.Role
}

// GoCloakMockUpdateRoleResults contains results of the GoCloak.UpdateRole
type GoCloakMockUpdateRoleResults struct {
	err error
}

// Expect sets up expected params for GoCloak.UpdateRole
func (mmUpdateRole *mGoCloakMockUpdateRole) Expect(accessToken string, realm string, clientID string, role mm_gocloak.Role) *mGoCloakMockUpdateRole {
	if mmUpdateRole.mock.funcUpdateRole != nil {
		mmUpdateRole.mock.t.Fatalf("GoCloakMock.UpdateRole mock is already set by Set")
	}

	if mmUpdateRole.defaultExpectation == nil {
		mmUpdateRole.defaultExpectation = &GoCloakMockUpdateRoleExpectation{}
	}

	mmUpdateRole.defaultExpectation.params = &GoCloakMockUpdateRoleParams{accessToken, realm, clientID, role}
	for _, e := range mmUpdateRole.expectations {
		if minimock.Equal(e.params, mmUpdateRole.defaultExpectation.params) {
			mmUpdateRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateRole.defaultExpectation.params)
		}
	}

	return mmUpdateRole
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.UpdateRole
func (mmUpdateRole *mGoCloakMockUpdateRole) Inspect(f func(accessToken string, realm string, clientID string, role mm_gocloak.Role)) *mGoCloakMockUpdateRole {
	if mmUpdateRole.mock.inspectFuncUpdateRole != nil {
		mmUpdateRole.mock.t.Fatalf("Inspect function is already set for GoCloakMock.UpdateRole")
	}

	mmUpdateRole.mock.inspectFuncUpdateRole = f

	return mmUpdateRole
}

// Return sets up results that will be returned by GoCloak.UpdateRole
func (mmUpdateRole *mGoCloakMockUpdateRole) Return(err error) *GoCloakMock {
	if mmUpdateRole.mock.funcUpdateRole != nil {
		mmUpdateRole.mock.t.Fatalf("GoCloakMock.UpdateRole mock is already set by Set")
	}

	if mmUpdateRole.defaultExpectation == nil {
		mmUpdateRole.defaultExpectation = &GoCloakMockUpdateRoleExpectation{mock: mmUpdateRole.mock}
	}
	mmUpdateRole.defaultExpectation.results = &GoCloakMockUpdateRoleResults{err}
	return mmUpdateRole.mock
}

//Set uses given function f to mock the GoCloak.UpdateRole method
func (mmUpdateRole *mGoCloakMockUpdateRole) Set(f func(accessToken string, realm string, clientID string, role mm_gocloak.Role) (err error)) *GoCloakMock {
	if mmUpdateRole.defaultExpectation != nil {
		mmUpdateRole.mock.t.Fatalf("Default expectation is already set for the GoCloak.UpdateRole method")
	}

	if len(mmUpdateRole.expectations) > 0 {
		mmUpdateRole.mock.t.Fatalf("Some expectations are already set for the GoCloak.UpdateRole method")
	}

	mmUpdateRole.mock.funcUpdateRole = f
	return mmUpdateRole.mock
}

// When sets expectation for the GoCloak.UpdateRole which will trigger the result defined by the following
// Then helper
func (mmUpdateRole *mGoCloakMockUpdateRole) When(accessToken string, realm string, clientID string, role mm_gocloak.Role) *GoCloakMockUpdateRoleExpectation {
	if mmUpdateRole.mock.funcUpdateRole != nil {
		mmUpdateRole.mock.t.Fatalf("GoCloakMock.UpdateRole mock is already set by Set")
	}

	expectation := &GoCloakMockUpdateRoleExpectation{
		mock:   mmUpdateRole.mock,
		params: &GoCloakMockUpdateRoleParams{accessToken, realm, clientID, role},
	}
	mmUpdateRole.expectations = append(mmUpdateRole.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.UpdateRole return parameters for the expectation previously defined by the When method
func (e *GoCloakMockUpdateRoleExpectation) Then(err error) *GoCloakMock {
	e.results = &GoCloakMockUpdateRoleResults{err}
	return e.mock
}

// UpdateRole implements gocloak.GoCloak
func (mmUpdateRole *GoCloakMock) UpdateRole(accessToken string, realm string, clientID string, role mm_gocloak.Role) (err error) {
	mm_atomic.AddUint64(&mmUpdateRole.beforeUpdateRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateRole.afterUpdateRoleCounter, 1)

	if mmUpdateRole.inspectFuncUpdateRole != nil {
		mmUpdateRole.inspectFuncUpdateRole(accessToken, realm, clientID, role)
	}

	mm_params := &GoCloakMockUpdateRoleParams{accessToken, realm, clientID, role}

	// Record call args
	mmUpdateRole.UpdateRoleMock.mutex.Lock()
	mmUpdateRole.UpdateRoleMock.callArgs = append(mmUpdateRole.UpdateRoleMock.callArgs, mm_params)
	mmUpdateRole.UpdateRoleMock.mutex.Unlock()

	for _, e := range mmUpdateRole.UpdateRoleMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateRole.UpdateRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateRole.UpdateRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateRole.UpdateRoleMock.defaultExpectation.params
		mm_got := GoCloakMockUpdateRoleParams{accessToken, realm, clientID, role}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateRole.t.Errorf("GoCloakMock.UpdateRole got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateRole.UpdateRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateRole.t.Fatal("No results are set for the GoCloakMock.UpdateRole")
		}
		return (*mm_results).err
	}
	if mmUpdateRole.funcUpdateRole != nil {
		return mmUpdateRole.funcUpdateRole(accessToken, realm, clientID, role)
	}
	mmUpdateRole.t.Fatalf("Unexpected call to GoCloakMock.UpdateRole. %v %v %v %v", accessToken, realm, clientID, role)
	return
}

// UpdateRoleAfterCounter returns a count of finished GoCloakMock.UpdateRole invocations
func (mmUpdateRole *GoCloakMock) UpdateRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateRole.afterUpdateRoleCounter)
}

// UpdateRoleBeforeCounter returns a count of GoCloakMock.UpdateRole invocations
func (mmUpdateRole *GoCloakMock) UpdateRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateRole.beforeUpdateRoleCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.UpdateRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateRole *mGoCloakMockUpdateRole) Calls() []*GoCloakMockUpdateRoleParams {
	mmUpdateRole.mutex.RLock()

	argCopy := make([]*GoCloakMockUpdateRoleParams, len(mmUpdateRole.callArgs))
	copy(argCopy, mmUpdateRole.callArgs)

	mmUpdateRole.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateRoleDone returns true if the count of the UpdateRole invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockUpdateRoleDone() bool {
	for _, e := range m.UpdateRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateRoleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateRoleCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateRole != nil && mm_atomic.LoadUint64(&m.afterUpdateRoleCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateRoleInspect logs each unmet expectation
func (m *GoCloakMock) MinimockUpdateRoleInspect() {
	for _, e := range m.UpdateRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.UpdateRole with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateRoleMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateRoleCounter) < 1 {
		if m.UpdateRoleMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.UpdateRole")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.UpdateRole with params: %#v", *m.UpdateRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateRole != nil && mm_atomic.LoadUint64(&m.afterUpdateRoleCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.UpdateRole")
	}
}

type mGoCloakMockUpdateUser struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockUpdateUserExpectation
	expectations       []*GoCloakMockUpdateUserExpectation

	callArgs []*GoCloakMockUpdateUserParams
	mutex    sync.RWMutex
}

// GoCloakMockUpdateUserExpectation specifies expectation struct of the GoCloak.UpdateUser
type GoCloakMockUpdateUserExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockUpdateUserParams
	results *GoCloakMockUpdateUserResults
	Counter uint64
}

// GoCloakMockUpdateUserParams contains parameters of the GoCloak.UpdateUser
type GoCloakMockUpdateUserParams struct {
	accessToken string
	realm       string
	user        mm_gocloak.User
}

// GoCloakMockUpdateUserResults contains results of the GoCloak.UpdateUser
type GoCloakMockUpdateUserResults struct {
	err error
}

// Expect sets up expected params for GoCloak.UpdateUser
func (mmUpdateUser *mGoCloakMockUpdateUser) Expect(accessToken string, realm string, user mm_gocloak.User) *mGoCloakMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("GoCloakMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &GoCloakMockUpdateUserExpectation{}
	}

	mmUpdateUser.defaultExpectation.params = &GoCloakMockUpdateUserParams{accessToken, realm, user}
	for _, e := range mmUpdateUser.expectations {
		if minimock.Equal(e.params, mmUpdateUser.defaultExpectation.params) {
			mmUpdateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUser.defaultExpectation.params)
		}
	}

	return mmUpdateUser
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.UpdateUser
func (mmUpdateUser *mGoCloakMockUpdateUser) Inspect(f func(accessToken string, realm string, user mm_gocloak.User)) *mGoCloakMockUpdateUser {
	if mmUpdateUser.mock.inspectFuncUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("Inspect function is already set for GoCloakMock.UpdateUser")
	}

	mmUpdateUser.mock.inspectFuncUpdateUser = f

	return mmUpdateUser
}

// Return sets up results that will be returned by GoCloak.UpdateUser
func (mmUpdateUser *mGoCloakMockUpdateUser) Return(err error) *GoCloakMock {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("GoCloakMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &GoCloakMockUpdateUserExpectation{mock: mmUpdateUser.mock}
	}
	mmUpdateUser.defaultExpectation.results = &GoCloakMockUpdateUserResults{err}
	return mmUpdateUser.mock
}

//Set uses given function f to mock the GoCloak.UpdateUser method
func (mmUpdateUser *mGoCloakMockUpdateUser) Set(f func(accessToken string, realm string, user mm_gocloak.User) (err error)) *GoCloakMock {
	if mmUpdateUser.defaultExpectation != nil {
		mmUpdateUser.mock.t.Fatalf("Default expectation is already set for the GoCloak.UpdateUser method")
	}

	if len(mmUpdateUser.expectations) > 0 {
		mmUpdateUser.mock.t.Fatalf("Some expectations are already set for the GoCloak.UpdateUser method")
	}

	mmUpdateUser.mock.funcUpdateUser = f
	return mmUpdateUser.mock
}

// When sets expectation for the GoCloak.UpdateUser which will trigger the result defined by the following
// Then helper
func (mmUpdateUser *mGoCloakMockUpdateUser) When(accessToken string, realm string, user mm_gocloak.User) *GoCloakMockUpdateUserExpectation {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("GoCloakMock.UpdateUser mock is already set by Set")
	}

	expectation := &GoCloakMockUpdateUserExpectation{
		mock:   mmUpdateUser.mock,
		params: &GoCloakMockUpdateUserParams{accessToken, realm, user},
	}
	mmUpdateUser.expectations = append(mmUpdateUser.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.UpdateUser return parameters for the expectation previously defined by the When method
func (e *GoCloakMockUpdateUserExpectation) Then(err error) *GoCloakMock {
	e.results = &GoCloakMockUpdateUserResults{err}
	return e.mock
}

// UpdateUser implements gocloak.GoCloak
func (mmUpdateUser *GoCloakMock) UpdateUser(accessToken string, realm string, user mm_gocloak.User) (err error) {
	mm_atomic.AddUint64(&mmUpdateUser.beforeUpdateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUser.afterUpdateUserCounter, 1)

	if mmUpdateUser.inspectFuncUpdateUser != nil {
		mmUpdateUser.inspectFuncUpdateUser(accessToken, realm, user)
	}

	mm_params := &GoCloakMockUpdateUserParams{accessToken, realm, user}

	// Record call args
	mmUpdateUser.UpdateUserMock.mutex.Lock()
	mmUpdateUser.UpdateUserMock.callArgs = append(mmUpdateUser.UpdateUserMock.callArgs, mm_params)
	mmUpdateUser.UpdateUserMock.mutex.Unlock()

	for _, e := range mmUpdateUser.UpdateUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateUser.UpdateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUser.UpdateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUser.UpdateUserMock.defaultExpectation.params
		mm_got := GoCloakMockUpdateUserParams{accessToken, realm, user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUser.t.Errorf("GoCloakMock.UpdateUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUser.UpdateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUser.t.Fatal("No results are set for the GoCloakMock.UpdateUser")
		}
		return (*mm_results).err
	}
	if mmUpdateUser.funcUpdateUser != nil {
		return mmUpdateUser.funcUpdateUser(accessToken, realm, user)
	}
	mmUpdateUser.t.Fatalf("Unexpected call to GoCloakMock.UpdateUser. %v %v %v", accessToken, realm, user)
	return
}

// UpdateUserAfterCounter returns a count of finished GoCloakMock.UpdateUser invocations
func (mmUpdateUser *GoCloakMock) UpdateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.afterUpdateUserCounter)
}

// UpdateUserBeforeCounter returns a count of GoCloakMock.UpdateUser invocations
func (mmUpdateUser *GoCloakMock) UpdateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.beforeUpdateUserCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.UpdateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUser *mGoCloakMockUpdateUser) Calls() []*GoCloakMockUpdateUserParams {
	mmUpdateUser.mutex.RLock()

	argCopy := make([]*GoCloakMockUpdateUserParams, len(mmUpdateUser.callArgs))
	copy(argCopy, mmUpdateUser.callArgs)

	mmUpdateUser.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserDone returns true if the count of the UpdateUser invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockUpdateUserDone() bool {
	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUser != nil && mm_atomic.LoadUint64(&m.afterUpdateUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateUserInspect logs each unmet expectation
func (m *GoCloakMock) MinimockUpdateUserInspect() {
	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.UpdateUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateUserCounter) < 1 {
		if m.UpdateUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.UpdateUser")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.UpdateUser with params: %#v", *m.UpdateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUser != nil && mm_atomic.LoadUint64(&m.afterUpdateUserCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.UpdateUser")
	}
}

type mGoCloakMockUserAttributeContains struct {
	mock               *GoCloakMock
	defaultExpectation *GoCloakMockUserAttributeContainsExpectation
	expectations       []*GoCloakMockUserAttributeContainsExpectation

	callArgs []*GoCloakMockUserAttributeContainsParams
	mutex    sync.RWMutex
}

// GoCloakMockUserAttributeContainsExpectation specifies expectation struct of the GoCloak.UserAttributeContains
type GoCloakMockUserAttributeContainsExpectation struct {
	mock    *GoCloakMock
	params  *GoCloakMockUserAttributeContainsParams
	results *GoCloakMockUserAttributeContainsResults
	Counter uint64
}

// GoCloakMockUserAttributeContainsParams contains parameters of the GoCloak.UserAttributeContains
type GoCloakMockUserAttributeContainsParams struct {
	attributes map[string][]string
	attribute  string
	value      string
}

// GoCloakMockUserAttributeContainsResults contains results of the GoCloak.UserAttributeContains
type GoCloakMockUserAttributeContainsResults struct {
	b1 bool
}

// Expect sets up expected params for GoCloak.UserAttributeContains
func (mmUserAttributeContains *mGoCloakMockUserAttributeContains) Expect(attributes map[string][]string, attribute string, value string) *mGoCloakMockUserAttributeContains {
	if mmUserAttributeContains.mock.funcUserAttributeContains != nil {
		mmUserAttributeContains.mock.t.Fatalf("GoCloakMock.UserAttributeContains mock is already set by Set")
	}

	if mmUserAttributeContains.defaultExpectation == nil {
		mmUserAttributeContains.defaultExpectation = &GoCloakMockUserAttributeContainsExpectation{}
	}

	mmUserAttributeContains.defaultExpectation.params = &GoCloakMockUserAttributeContainsParams{attributes, attribute, value}
	for _, e := range mmUserAttributeContains.expectations {
		if minimock.Equal(e.params, mmUserAttributeContains.defaultExpectation.params) {
			mmUserAttributeContains.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUserAttributeContains.defaultExpectation.params)
		}
	}

	return mmUserAttributeContains
}

// Inspect accepts an inspector function that has same arguments as the GoCloak.UserAttributeContains
func (mmUserAttributeContains *mGoCloakMockUserAttributeContains) Inspect(f func(attributes map[string][]string, attribute string, value string)) *mGoCloakMockUserAttributeContains {
	if mmUserAttributeContains.mock.inspectFuncUserAttributeContains != nil {
		mmUserAttributeContains.mock.t.Fatalf("Inspect function is already set for GoCloakMock.UserAttributeContains")
	}

	mmUserAttributeContains.mock.inspectFuncUserAttributeContains = f

	return mmUserAttributeContains
}

// Return sets up results that will be returned by GoCloak.UserAttributeContains
func (mmUserAttributeContains *mGoCloakMockUserAttributeContains) Return(b1 bool) *GoCloakMock {
	if mmUserAttributeContains.mock.funcUserAttributeContains != nil {
		mmUserAttributeContains.mock.t.Fatalf("GoCloakMock.UserAttributeContains mock is already set by Set")
	}

	if mmUserAttributeContains.defaultExpectation == nil {
		mmUserAttributeContains.defaultExpectation = &GoCloakMockUserAttributeContainsExpectation{mock: mmUserAttributeContains.mock}
	}
	mmUserAttributeContains.defaultExpectation.results = &GoCloakMockUserAttributeContainsResults{b1}
	return mmUserAttributeContains.mock
}

//Set uses given function f to mock the GoCloak.UserAttributeContains method
func (mmUserAttributeContains *mGoCloakMockUserAttributeContains) Set(f func(attributes map[string][]string, attribute string, value string) (b1 bool)) *GoCloakMock {
	if mmUserAttributeContains.defaultExpectation != nil {
		mmUserAttributeContains.mock.t.Fatalf("Default expectation is already set for the GoCloak.UserAttributeContains method")
	}

	if len(mmUserAttributeContains.expectations) > 0 {
		mmUserAttributeContains.mock.t.Fatalf("Some expectations are already set for the GoCloak.UserAttributeContains method")
	}

	mmUserAttributeContains.mock.funcUserAttributeContains = f
	return mmUserAttributeContains.mock
}

// When sets expectation for the GoCloak.UserAttributeContains which will trigger the result defined by the following
// Then helper
func (mmUserAttributeContains *mGoCloakMockUserAttributeContains) When(attributes map[string][]string, attribute string, value string) *GoCloakMockUserAttributeContainsExpectation {
	if mmUserAttributeContains.mock.funcUserAttributeContains != nil {
		mmUserAttributeContains.mock.t.Fatalf("GoCloakMock.UserAttributeContains mock is already set by Set")
	}

	expectation := &GoCloakMockUserAttributeContainsExpectation{
		mock:   mmUserAttributeContains.mock,
		params: &GoCloakMockUserAttributeContainsParams{attributes, attribute, value},
	}
	mmUserAttributeContains.expectations = append(mmUserAttributeContains.expectations, expectation)
	return expectation
}

// Then sets up GoCloak.UserAttributeContains return parameters for the expectation previously defined by the When method
func (e *GoCloakMockUserAttributeContainsExpectation) Then(b1 bool) *GoCloakMock {
	e.results = &GoCloakMockUserAttributeContainsResults{b1}
	return e.mock
}

// UserAttributeContains implements gocloak.GoCloak
func (mmUserAttributeContains *GoCloakMock) UserAttributeContains(attributes map[string][]string, attribute string, value string) (b1 bool) {
	mm_atomic.AddUint64(&mmUserAttributeContains.beforeUserAttributeContainsCounter, 1)
	defer mm_atomic.AddUint64(&mmUserAttributeContains.afterUserAttributeContainsCounter, 1)

	if mmUserAttributeContains.inspectFuncUserAttributeContains != nil {
		mmUserAttributeContains.inspectFuncUserAttributeContains(attributes, attribute, value)
	}

	mm_params := &GoCloakMockUserAttributeContainsParams{attributes, attribute, value}

	// Record call args
	mmUserAttributeContains.UserAttributeContainsMock.mutex.Lock()
	mmUserAttributeContains.UserAttributeContainsMock.callArgs = append(mmUserAttributeContains.UserAttributeContainsMock.callArgs, mm_params)
	mmUserAttributeContains.UserAttributeContainsMock.mutex.Unlock()

	for _, e := range mmUserAttributeContains.UserAttributeContainsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmUserAttributeContains.UserAttributeContainsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUserAttributeContains.UserAttributeContainsMock.defaultExpectation.Counter, 1)
		mm_want := mmUserAttributeContains.UserAttributeContainsMock.defaultExpectation.params
		mm_got := GoCloakMockUserAttributeContainsParams{attributes, attribute, value}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUserAttributeContains.t.Errorf("GoCloakMock.UserAttributeContains got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUserAttributeContains.UserAttributeContainsMock.defaultExpectation.results
		if mm_results == nil {
			mmUserAttributeContains.t.Fatal("No results are set for the GoCloakMock.UserAttributeContains")
		}
		return (*mm_results).b1
	}
	if mmUserAttributeContains.funcUserAttributeContains != nil {
		return mmUserAttributeContains.funcUserAttributeContains(attributes, attribute, value)
	}
	mmUserAttributeContains.t.Fatalf("Unexpected call to GoCloakMock.UserAttributeContains. %v %v %v", attributes, attribute, value)
	return
}

// UserAttributeContainsAfterCounter returns a count of finished GoCloakMock.UserAttributeContains invocations
func (mmUserAttributeContains *GoCloakMock) UserAttributeContainsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserAttributeContains.afterUserAttributeContainsCounter)
}

// UserAttributeContainsBeforeCounter returns a count of GoCloakMock.UserAttributeContains invocations
func (mmUserAttributeContains *GoCloakMock) UserAttributeContainsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserAttributeContains.beforeUserAttributeContainsCounter)
}

// Calls returns a list of arguments used in each call to GoCloakMock.UserAttributeContains.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUserAttributeContains *mGoCloakMockUserAttributeContains) Calls() []*GoCloakMockUserAttributeContainsParams {
	mmUserAttributeContains.mutex.RLock()

	argCopy := make([]*GoCloakMockUserAttributeContainsParams, len(mmUserAttributeContains.callArgs))
	copy(argCopy, mmUserAttributeContains.callArgs)

	mmUserAttributeContains.mutex.RUnlock()

	return argCopy
}

// MinimockUserAttributeContainsDone returns true if the count of the UserAttributeContains invocations corresponds
// the number of defined expectations
func (m *GoCloakMock) MinimockUserAttributeContainsDone() bool {
	for _, e := range m.UserAttributeContainsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UserAttributeContainsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUserAttributeContainsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserAttributeContains != nil && mm_atomic.LoadUint64(&m.afterUserAttributeContainsCounter) < 1 {
		return false
	}
	return true
}

// MinimockUserAttributeContainsInspect logs each unmet expectation
func (m *GoCloakMock) MinimockUserAttributeContainsInspect() {
	for _, e := range m.UserAttributeContainsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GoCloakMock.UserAttributeContains with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UserAttributeContainsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUserAttributeContainsCounter) < 1 {
		if m.UserAttributeContainsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to GoCloakMock.UserAttributeContains")
		} else {
			m.t.Errorf("Expected call to GoCloakMock.UserAttributeContains with params: %#v", *m.UserAttributeContainsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserAttributeContains != nil && mm_atomic.LoadUint64(&m.afterUserAttributeContainsCounter) < 1 {
		m.t.Error("Expected call to GoCloakMock.UserAttributeContains")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *GoCloakMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateClientInspect()

		m.MinimockCreateClientScopeInspect()

		m.MinimockCreateComponentInspect()

		m.MinimockCreateGroupInspect()

		m.MinimockCreateRoleInspect()

		m.MinimockCreateUserInspect()

		m.MinimockDecodeAccessTokenInspect()

		m.MinimockDecodeAccessTokenCustomClaimsInspect()

		m.MinimockDeleteClientInspect()

		m.MinimockDeleteClientScopeInspect()

		m.MinimockDeleteComponentInspect()

		m.MinimockDeleteGroupInspect()

		m.MinimockDeleteRoleInspect()

		m.MinimockDeleteUserInspect()

		m.MinimockGetCertsInspect()

		m.MinimockGetClientsInspect()

		m.MinimockGetComponentsInspect()

		m.MinimockGetGroupInspect()

		m.MinimockGetGroupsInspect()

		m.MinimockGetIssuerInspect()

		m.MinimockGetKeyStoreConfigInspect()

		m.MinimockGetRealmRolesByGroupIDInspect()

		m.MinimockGetRealmRolesByUserIDInspect()

		m.MinimockGetRoleMappingByGroupIDInspect()

		m.MinimockGetRoleMappingByUserIDInspect()

		m.MinimockGetRolesInspect()

		m.MinimockGetRolesByClientIDInspect()

		m.MinimockGetUserByIDInspect()

		m.MinimockGetUserCountInspect()

		m.MinimockGetUserGroupsInspect()

		m.MinimockGetUsersInspect()

		m.MinimockGetUsersByRoleNameInspect()

		m.MinimockLoginInspect()

		m.MinimockLoginAdminInspect()

		m.MinimockLoginClientInspect()

		m.MinimockRefreshTokenInspect()

		m.MinimockRequestPermissionInspect()

		m.MinimockRetrospectTokenInspect()

		m.MinimockSetPasswordInspect()

		m.MinimockUpdateClientInspect()

		m.MinimockUpdateClientScopeInspect()

		m.MinimockUpdateGroupInspect()

		m.MinimockUpdateRoleInspect()

		m.MinimockUpdateUserInspect()

		m.MinimockUserAttributeContainsInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *GoCloakMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *GoCloakMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateClientDone() &&
		m.MinimockCreateClientScopeDone() &&
		m.MinimockCreateComponentDone() &&
		m.MinimockCreateGroupDone() &&
		m.MinimockCreateRoleDone() &&
		m.MinimockCreateUserDone() &&
		m.MinimockDecodeAccessTokenDone() &&
		m.MinimockDecodeAccessTokenCustomClaimsDone() &&
		m.MinimockDeleteClientDone() &&
		m.MinimockDeleteClientScopeDone() &&
		m.MinimockDeleteComponentDone() &&
		m.MinimockDeleteGroupDone() &&
		m.MinimockDeleteRoleDone() &&
		m.MinimockDeleteUserDone() &&
		m.MinimockGetCertsDone() &&
		m.MinimockGetClientsDone() &&
		m.MinimockGetComponentsDone() &&
		m.MinimockGetGroupDone() &&
		m.MinimockGetGroupsDone() &&
		m.MinimockGetIssuerDone() &&
		m.MinimockGetKeyStoreConfigDone() &&
		m.MinimockGetRealmRolesByGroupIDDone() &&
		m.MinimockGetRealmRolesByUserIDDone() &&
		m.MinimockGetRoleMappingByGroupIDDone() &&
		m.MinimockGetRoleMappingByUserIDDone() &&
		m.MinimockGetRolesDone() &&
		m.MinimockGetRolesByClientIDDone() &&
		m.MinimockGetUserByIDDone() &&
		m.MinimockGetUserCountDone() &&
		m.MinimockGetUserGroupsDone() &&
		m.MinimockGetUsersDone() &&
		m.MinimockGetUsersByRoleNameDone() &&
		m.MinimockLoginDone() &&
		m.MinimockLoginAdminDone() &&
		m.MinimockLoginClientDone() &&
		m.MinimockRefreshTokenDone() &&
		m.MinimockRequestPermissionDone() &&
		m.MinimockRetrospectTokenDone() &&
		m.MinimockSetPasswordDone() &&
		m.MinimockUpdateClientDone() &&
		m.MinimockUpdateClientScopeDone() &&
		m.MinimockUpdateGroupDone() &&
		m.MinimockUpdateRoleDone() &&
		m.MinimockUpdateUserDone() &&
		m.MinimockUserAttributeContainsDone()
}
